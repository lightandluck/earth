/*!
 * Project-specific code is Copyright (c) 2018 Cameron Beccario
 *
 * See https://earth.nullschool.net/bundle.js for a readable version of this source, including licenses.
 * See https://github.com/cambecc/earth for a free version of this project.
 *
 */

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/d3-array/index.js":
/*!****************************************!*\
  !*** ./node_modules/d3-array/index.js ***!
  \****************************************/
/*! exports provided: bisect, bisectRight, bisectLeft, ascending, bisector, cross, descending, deviation, extent, histogram, thresholdFreedmanDiaconis, thresholdScott, thresholdSturges, max, mean, median, merge, min, pairs, permute, quantile, range, scan, shuffle, sum, ticks, tickIncrement, tickStep, transpose, variance, zip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_bisect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisect", function() { return _src_bisect__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return _src_bisect__WEBPACK_IMPORTED_MODULE_0__["bisectRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return _src_bisect__WEBPACK_IMPORTED_MODULE_0__["bisectLeft"]; });

/* harmony import */ var _src_ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ascending", function() { return _src_ascending__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_bisector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/bisector */ "./node_modules/d3-array/src/bisector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisector", function() { return _src_bisector__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_cross__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/cross */ "./node_modules/d3-array/src/cross.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return _src_cross__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_descending__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/descending */ "./node_modules/d3-array/src/descending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "descending", function() { return _src_descending__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_deviation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/deviation */ "./node_modules/d3-array/src/deviation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deviation", function() { return _src_deviation__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/extent */ "./node_modules/d3-array/src/extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extent", function() { return _src_extent__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_histogram__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/histogram */ "./node_modules/d3-array/src/histogram.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return _src_histogram__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/threshold/freedmanDiaconis */ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return _src_threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_threshold_scott__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/threshold/scott */ "./node_modules/d3-array/src/threshold/scott.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return _src_threshold_scott__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _src_threshold_sturges__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return _src_threshold_sturges__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _src_max__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/max */ "./node_modules/d3-array/src/max.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _src_max__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _src_mean__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/mean */ "./node_modules/d3-array/src/mean.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _src_mean__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _src_median__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/median */ "./node_modules/d3-array/src/median.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "median", function() { return _src_median__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _src_merge__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/merge */ "./node_modules/d3-array/src/merge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _src_merge__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _src_min__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/min */ "./node_modules/d3-array/src/min.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _src_min__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _src_pairs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/pairs */ "./node_modules/d3-array/src/pairs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _src_pairs__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _src_permute__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/permute */ "./node_modules/d3-array/src/permute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "permute", function() { return _src_permute__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _src_quantile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/quantile */ "./node_modules/d3-array/src/quantile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantile", function() { return _src_quantile__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _src_range__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/range */ "./node_modules/d3-array/src/range.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _src_range__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _src_scan__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/scan */ "./node_modules/d3-array/src/scan.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return _src_scan__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _src_shuffle__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/shuffle */ "./node_modules/d3-array/src/shuffle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return _src_shuffle__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _src_sum__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/sum */ "./node_modules/d3-array/src/sum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _src_sum__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _src_ticks__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ticks", function() { return _src_ticks__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return _src_ticks__WEBPACK_IMPORTED_MODULE_23__["tickIncrement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return _src_ticks__WEBPACK_IMPORTED_MODULE_23__["tickStep"]; });

/* harmony import */ var _src_transpose__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/transpose */ "./node_modules/d3-array/src/transpose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _src_transpose__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _src_variance__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/variance */ "./node_modules/d3-array/src/variance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variance", function() { return _src_variance__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _src_zip__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/zip */ "./node_modules/d3-array/src/zip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _src_zip__WEBPACK_IMPORTED_MODULE_26__["default"]; });





























/***/ }),

/***/ "./node_modules/d3-array/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/array.js ***!
  \********************************************/
/*! exports provided: slice, map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

/***/ }),

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});

/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/*! exports provided: bisectRight, bisectLeft, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return bisectRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return bisectLeft; });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisector */ "./node_modules/d3-array/src/bisector.js");


var ascendingBisect = Object(_bisector__WEBPACK_IMPORTED_MODULE_1__["default"])(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ __webpack_exports__["default"] = (bisectRight);

/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");

/* harmony default export */ __webpack_exports__["default"] = (function (compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function left(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
      }

      return lo;
    },
    right: function right(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
      }

      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function (d, x) {
    return Object(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
  };
}

/***/ }),

/***/ "./node_modules/d3-array/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/constant.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-array/src/cross.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/cross.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pairs */ "./node_modules/d3-array/src/pairs.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;
  if (reduce == null) reduce = _pairs__WEBPACK_IMPORTED_MODULE_0__["pair"];

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});

/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

/***/ }),

/***/ "./node_modules/d3-array/src/deviation.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/deviation.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance */ "./node_modules/d3-array/src/variance.js");

/* harmony default export */ __webpack_exports__["default"] = (function (array, f) {
  var v = Object(_variance__WEBPACK_IMPORTED_MODULE_0__["default"])(array, f);
  return v ? Math.sqrt(v) : v;
});

/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});

/***/ }),

/***/ "./node_modules/d3-array/src/histogram.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/histogram.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-array/src/constant.js");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-array/src/identity.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./range */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");








/* harmony default export */ __webpack_exports__["default"] = (function () {
  var value = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      domain = _extent__WEBPACK_IMPORTED_MODULE_3__["default"],
      threshold = _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__["default"];

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1); // Convert number of thresholds into uniform thresholds.

    if (!Array.isArray(tz)) {
      tz = Object(_ticks__WEBPACK_IMPORTED_MODULE_6__["tickStep"])(x0, x1, tz);
      tz = Object(_range__WEBPACK_IMPORTED_MODULE_5__["default"])(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    } // Remove any thresholds outside the domain.


    var m = tz.length;

    while (tz[0] <= x0) {
      tz.shift(), --m;
    }

    while (tz[m - 1] > x1) {
      tz.pop(), --m;
    }

    var bins = new Array(m + 1),
        bin; // Initialize bins.

    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    } // Assign data to bins by value, ignoring any outside the domain.


    for (i = 0; i < n; ++i) {
      x = values[i];

      if (x0 <= x && x <= x1) {
        bins[Object(_bisect__WEBPACK_IMPORTED_MODULE_1__["default"])(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : value;
  };

  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_)) : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : threshold;
  };

  return histogram;
});

/***/ }),

/***/ "./node_modules/d3-array/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/identity.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x;
});

/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});

/***/ }),

/***/ "./node_modules/d3-array/src/mean.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/mean.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) sum += value;else --m;
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) sum += value;else --m;
    }
  }

  if (m) return sum / m;
});

/***/ }),

/***/ "./node_modules/d3-array/src/median.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/median.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-array/src/quantile.js");



/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_1__["default"])(values[i]))) {
        numbers.push(value);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_1__["default"])(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return Object(_quantile__WEBPACK_IMPORTED_MODULE_2__["default"])(numbers.sort(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]), 0.5);
});

/***/ }),

/***/ "./node_modules/d3-array/src/merge.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/merge.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) {
    j += arrays[i].length;
  }

  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;

    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});

/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});

/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x === null ? NaN : +x;
});

/***/ }),

/***/ "./node_modules/d3-array/src/pairs.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/pairs.js ***!
  \********************************************/
/*! exports provided: default, pair */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pair", function() { return pair; });
/* harmony default export */ __webpack_exports__["default"] = (function (array, f) {
  if (f == null) f = pair;
  var i = 0,
      n = array.length - 1,
      p = array[0],
      pairs = new Array(n < 0 ? 0 : n);

  while (i < n) {
    pairs[i] = f(p, p = array[++i]);
  }

  return pairs;
});
function pair(a, b) {
  return [a, b];
}

/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array, indexes) {
  var i = indexes.length,
      permutes = new Array(i);

  while (i--) {
    permutes[i] = array[indexes[i]];
  }

  return permutes;
});

/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values, p, valueof) {
  if (valueof == null) valueof = _number__WEBPACK_IMPORTED_MODULE_0__["default"];
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});

/***/ }),

/***/ "./node_modules/d3-array/src/range.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/range.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});

/***/ }),

/***/ "./node_modules/d3-array/src/scan.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/scan.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];
  if (compare == null) compare = _ascending__WEBPACK_IMPORTED_MODULE_0__["default"];

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});

/***/ }),

/***/ "./node_modules/d3-array/src/shuffle.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/shuffle.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});

/***/ }),

/***/ "./node_modules/d3-array/src/sum.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/sum.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  } else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});

/***/ }),

/***/ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/freedmanDiaconis.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../quantile */ "./node_modules/d3-array/src/quantile.js");




/* harmony default export */ __webpack_exports__["default"] = (function (values, min, max) {
  values = _array__WEBPACK_IMPORTED_MODULE_0__["map"].call(values, _number__WEBPACK_IMPORTED_MODULE_2__["default"]).sort(_ascending__WEBPACK_IMPORTED_MODULE_1__["default"]);
  return Math.ceil((max - min) / (2 * (Object(_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.75) - Object(_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});

/***/ }),

/***/ "./node_modules/d3-array/src/threshold/scott.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/scott.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deviation */ "./node_modules/d3-array/src/deviation.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values, min, max) {
  return Math.ceil((max - min) / (3.5 * Object(_deviation__WEBPACK_IMPORTED_MODULE_0__["default"])(values) * Math.pow(values.length, -1 / 3)));
});

/***/ }),

/***/ "./node_modules/d3-array/src/threshold/sturges.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/sturges.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});

/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/*! exports provided: default, tickIncrement, tickStep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return tickIncrement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return tickStep; });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);
/* harmony default export */ __webpack_exports__["default"] = (function (start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));

    while (++i < n) {
      ticks[i] = (start + i) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));

    while (++i < n) {
      ticks[i] = (start - i) / step;
    }
  }

  if (reverse) ticks.reverse();
  return ticks;
});
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

/***/ }),

/***/ "./node_modules/d3-array/src/transpose.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/transpose.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./min */ "./node_modules/d3-array/src/min.js");

/* harmony default export */ __webpack_exports__["default"] = (function (matrix) {
  if (!(n = matrix.length)) return [];

  for (var i = -1, m = Object(_min__WEBPACK_IMPORTED_MODULE_0__["default"])(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }

  return transpose;
});

function length(d) {
  return d.length;
}

/***/ }),

/***/ "./node_modules/d3-array/src/variance.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/variance.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});

/***/ }),

/***/ "./node_modules/d3-array/src/zip.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/zip.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transpose */ "./node_modules/d3-array/src/transpose.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_transpose__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments);
});

/***/ }),

/***/ "./node_modules/d3-collection/index.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-collection/index.js ***!
  \*********************************************/
/*! exports provided: nest, set, map, keys, values, entries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_nest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/nest */ "./node_modules/d3-collection/src/nest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nest", function() { return _src_nest__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/set */ "./node_modules/d3-collection/src/set.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "set", function() { return _src_set__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/map */ "./node_modules/d3-collection/src/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _src_map__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/keys */ "./node_modules/d3-collection/src/keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _src_keys__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/values */ "./node_modules/d3-collection/src/values.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _src_values__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_entries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/entries */ "./node_modules/d3-collection/src/entries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "entries", function() { return _src_entries__WEBPACK_IMPORTED_MODULE_5__["default"]; });








/***/ }),

/***/ "./node_modules/d3-collection/src/entries.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-collection/src/entries.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (map) {
  var entries = [];

  for (var key in map) {
    entries.push({
      key: key,
      value: map[key]
    });
  }

  return entries;
});

/***/ }),

/***/ "./node_modules/d3-collection/src/keys.js":
/*!************************************************!*\
  !*** ./node_modules/d3-collection/src/keys.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (map) {
  var keys = [];

  for (var key in map) {
    keys.push(key);
  }

  return keys;
});

/***/ }),

/***/ "./node_modules/d3-collection/src/map.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-collection/src/map.js ***!
  \***********************************************/
/*! exports provided: prefix, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefix", function() { return prefix; });
var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function has(key) {
    return prefix + key in this;
  },
  get: function get(key) {
    return this[prefix + key];
  },
  set: function set(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function remove(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function clear() {
    for (var property in this) {
      if (property[0] === prefix) delete this[property];
    }
  },
  keys: function keys() {
    var keys = [];

    for (var property in this) {
      if (property[0] === prefix) keys.push(property.slice(1));
    }

    return keys;
  },
  values: function values() {
    var values = [];

    for (var property in this) {
      if (property[0] === prefix) values.push(this[property]);
    }

    return values;
  },
  entries: function entries() {
    var entries = [];

    for (var property in this) {
      if (property[0] === prefix) entries.push({
        key: property.slice(1),
        value: this[property]
      });
    }

    return entries;
  },
  size: function size() {
    var size = 0;

    for (var property in this) {
      if (property[0] === prefix) ++size;
    }

    return size;
  },
  empty: function empty() {
    for (var property in this) {
      if (property[0] === prefix) return false;
    }

    return true;
  },
  each: function each(f) {
    for (var property in this) {
      if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
  }
};

function map(object, f) {
  var map = new Map(); // Copy constructor.

  if (object instanceof Map) object.each(function (value, key) {
    map.set(key, value);
  }); // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;
      if (f == null) while (++i < n) {
        map.set(i, object[i]);
      } else while (++i < n) {
        map.set(f(o = object[i], i, object), o);
      }
    } // Convert object to map.
    else if (object) for (var key in object) {
        map.set(key, object[key]);
      }
  return map;
}

/* harmony default export */ __webpack_exports__["default"] = (map);

/***/ }),

/***/ "./node_modules/d3-collection/src/nest.js":
/*!************************************************!*\
  !*** ./node_modules/d3-collection/src/nest.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./node_modules/d3-collection/src/map.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var keys = [],
      _sortKeys = [],
      _sortValues,
      _rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (_sortValues != null) array.sort(_sortValues);
      return _rollup != null ? _rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = Object(_map__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function (values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });
    return result;
  }

  function _entries(map, depth) {
    if (++depth > keys.length) return map;
    var array,
        sortKey = _sortKeys[depth - 1];
    if (_rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
      array.push({
        key: k,
        values: _entries(v, depth)
      });
    });
    return sortKey != null ? array.sort(function (a, b) {
      return sortKey(a.key, b.key);
    }) : array;
  }

  return nest = {
    object: function object(array) {
      return apply(array, 0, createObject, setObject);
    },
    map: function map(array) {
      return apply(array, 0, createMap, setMap);
    },
    entries: function entries(array) {
      return _entries(apply(array, 0, createMap, setMap), 0);
    },
    key: function key(d) {
      keys.push(d);
      return nest;
    },
    sortKeys: function sortKeys(order) {
      _sortKeys[keys.length - 1] = order;
      return nest;
    },
    sortValues: function sortValues(order) {
      _sortValues = order;
      return nest;
    },
    rollup: function rollup(f) {
      _rollup = f;
      return nest;
    }
  };
});

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return Object(_map__WEBPACK_IMPORTED_MODULE_0__["default"])();
}

function setMap(map, key, value) {
  map.set(key, value);
}

/***/ }),

/***/ "./node_modules/d3-collection/src/set.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-collection/src/set.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./node_modules/d3-collection/src/map.js");


function Set() {}

var proto = _map__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;
Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function add(value) {
    value += "";
    this[_map__WEBPACK_IMPORTED_MODULE_0__["prefix"] + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set(); // Copy constructor.

  if (object instanceof Set) object.each(function (value) {
    set.add(value);
  }); // Otherwise, assume it’s an array.
  else if (object) {
      var i = -1,
          n = object.length;
      if (f == null) while (++i < n) {
        set.add(object[i]);
      } else while (++i < n) {
        set.add(f(object[i], i, object));
      }
    }
  return set;
}

/* harmony default export */ __webpack_exports__["default"] = (set);

/***/ }),

/***/ "./node_modules/d3-collection/src/values.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-collection/src/values.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (map) {
  var values = [];

  for (var key in map) {
    values.push(map[key]);
  }

  return values;
});

/***/ }),

/***/ "./node_modules/d3-color/index.js":
/*!****************************************!*\
  !*** ./node_modules/d3-color/index.js ***!
  \****************************************/
/*! exports provided: color, rgb, hsl, lab, hcl, lch, gray, cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/color */ "./node_modules/d3-color/src/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _src_color__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return _src_color__WEBPACK_IMPORTED_MODULE_0__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return _src_color__WEBPACK_IMPORTED_MODULE_0__["hsl"]; });

/* harmony import */ var _src_lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/lab */ "./node_modules/d3-color/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return _src_lab__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return _src_lab__WEBPACK_IMPORTED_MODULE_1__["hcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return _src_lab__WEBPACK_IMPORTED_MODULE_1__["lch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return _src_lab__WEBPACK_IMPORTED_MODULE_1__["gray"]; });

/* harmony import */ var _src_cubehelix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/cubehelix */ "./node_modules/d3-color/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return _src_cubehelix__WEBPACK_IMPORTED_MODULE_2__["default"]; });





/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/*! exports provided: Color, darker, brighter, default, rgbConvert, rgb, Rgb, hslConvert, hsl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darker", function() { return _darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighter", function() { return _brighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbConvert", function() { return rgbConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rgb", function() { return Rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslConvert", function() { return hslConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* harmony import */ var _define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define */ "./node_modules/d3-color/src/define.js");

function Color() {}
var _darker = 0.7;


var _brighter = 1 / _darker;


var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  displayable: function displayable() {
    return this.rgb().displayable();
  },
  hex: function hex() {
    return this.rgb().hex();
  },
  toString: function toString() {
    return this.rgb() + "";
  }
});
function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb(m >> 8 & 0xf | m >> 4 & 0x0f0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  ) : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
  : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function rgb() {
    return this;
  },
  displayable: function displayable() {
    return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: function hex() {
    return "#" + _hex(this.r) + _hex(this.g) + _hex(this.b);
  },
  toString: function toString() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function _hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;

  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }

  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  displayable: function displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  }
}));
/* From FvD 13.37, CSS Color Module Level 3 */

function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

/***/ }),

/***/ "./node_modules/d3-color/src/cubehelix.js":
/*!************************************************!*\
  !*** ./node_modules/d3-color/src/cubehelix.js ***!
  \************************************************/
/*! exports provided: default, Cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cubehelix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubehelix", function() { return Cubehelix; });
/* harmony import */ var _define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-color/src/math.js");



var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
      // NaN if l=0 or l=1
  h = s ? Math.atan2(k, bl) * _math__WEBPACK_IMPORTED_MODULE_2__["rad2deg"] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Cubehelix, cubehelix, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function brighter(k) {
    k = k == null ? _color__WEBPACK_IMPORTED_MODULE_1__["brighter"] : Math.pow(_color__WEBPACK_IMPORTED_MODULE_1__["brighter"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _color__WEBPACK_IMPORTED_MODULE_1__["darker"] : Math.pow(_color__WEBPACK_IMPORTED_MODULE_1__["darker"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math__WEBPACK_IMPORTED_MODULE_2__["deg2rad"],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"](255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
  }
}));

/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/*! exports provided: default, extend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony default export */ __webpack_exports__["default"] = (function (constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);

  for (var key in definition) {
    prototype[key] = definition[key];
  }

  return prototype;
}

/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/*! exports provided: gray, default, Lab, lch, hcl, Hcl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return gray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lab", function() { return Lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return lch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return hcl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hcl", function() { return Hcl; });
/* harmony import */ var _define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-color/src/math.js");


 // https://beta.observablehq.com/@mbostock/lab-and-rgb

var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);

  if (o instanceof Hcl) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * _math__WEBPACK_IMPORTED_MODULE_2__["deg2rad"];
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }

  if (!(o instanceof _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn),
      x,
      z;
  if (r === g && g === b) x = z = y;else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Lab, lab, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"](lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math__WEBPACK_IMPORTED_MODULE_2__["rad2deg"];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Hcl, hcl, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function rgb() {
    return labConvert(this).rgb();
  }
}));

/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/*! exports provided: deg2rad, rad2deg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg2rad", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rad2deg", function() { return rad2deg; });
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

/***/ }),

/***/ "./node_modules/d3-dispatch/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-dispatch/index.js ***!
  \*******************************************/
/*! exports provided: dispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return _src_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var noop = {
  value: function value() {}
};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _) throw new Error("illegal type: " + t);
    _[t] = [];
  }

  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {
      type: t,
      name: name
    };
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function on(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length; // If no callback was specified, return the callback of the given type and name.

    if (arguments.length < 2) {
      while (++i < n) {
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      }

      return;
    } // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.


    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);

    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) {
        _[t] = set(_[t], typename.name, null);
      }
    }

    return this;
  },
  copy: function copy() {
    var copy = {},
        _ = this._;

    for (var t in _) {
      copy[t] = _[t].slice();
    }

    return new Dispatch(copy);
  },
  call: function call(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) {
      args[i] = arguments[i + 2];
    }
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (t = this._[type], i = 0, n = t.length; i < n; ++i) {
      t[i].value.apply(that, args);
    }
  },
  apply: function apply(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) {
      t[i].value.apply(that, args);
    }
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }

  if (callback != null) type.push({
    name: name,
    value: callback
  });
  return type;
}

/* harmony default export */ __webpack_exports__["default"] = (dispatch);

/***/ }),

/***/ "./node_modules/d3-drag/index.js":
/*!***************************************!*\
  !*** ./node_modules/d3-drag/index.js ***!
  \***************************************/
/*! exports provided: drag, dragDisable, dragEnable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/drag */ "./node_modules/d3-drag/src/drag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return _src_drag__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_nodrag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/nodrag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return _src_nodrag__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return _src_nodrag__WEBPACK_IMPORTED_MODULE_1__["yesdrag"]; });




/***/ }),

/***/ "./node_modules/d3-drag/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-drag/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-drag/src/drag.js":
/*!******************************************!*\
  !*** ./node_modules/d3-drag/src/drag.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event */ "./node_modules/d3-drag/src/event.js");





 // Ignore right-click, since that should open the context menu.

function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {
    x: d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].x,
    y: d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].y
  } : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3_selection__WEBPACK_IMPORTED_MODULE_1__["mouse"], this, arguments);
    if (!gesture) return;
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    Object(_nodrag__WEBPACK_IMPORTED_MODULE_2__["default"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view);
    Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
    mousemoving = false;
    mousedownx = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientX;
    mousedowny = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientY;
    gesture("start");
  }

  function mousemoved() {
    Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();

    if (!mousemoving) {
      var dx = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientX - mousedownx,
          dy = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }

    gestures.mouse("drag");
  }

  function mouseupped() {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view).on("mousemove.drag mouseup.drag", null);
    Object(_nodrag__WEBPACK_IMPORTED_MODULE_2__["yesdrag"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view, mousemoving);
    Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        c = container.apply(this, arguments),
        n = touches.length,
        i,
        gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3_selection__WEBPACK_IMPORTED_MODULE_1__["touch"], this, arguments)) {
        Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        n = touches.length,
        i,
        gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        n = touches.length,
        i,
        gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, 500); // Ghost clicks are delayed!

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id),
        s,
        dx,
        dy,
        sublisteners = listeners.copy();
    if (!Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["customEvent"])(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function () {
      if ((d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;
    return function gesture(type) {
      var p0 = p,
          n;

      switch (type) {
        case "start":
          gestures[id] = gesture, n = active++;
          break;

        case "end":
          delete gestures[id], --active;
        // nobreak

        case "drag":
          p = point(container, id), n = active;
          break;
      }

      Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["customEvent"])(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function (_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function (_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});

/***/ }),

/***/ "./node_modules/d3-drag/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragEvent; });
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function () {
  var value = this._.on.apply(this._, arguments);

  return value === this._ ? this : value;
};

/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/*! exports provided: default, yesdrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yesdrag", function() { return yesdrag; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-drag/src/noevent.js");


/* harmony default export */ __webpack_exports__["default"] = (function (view) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);

  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});
function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", null);

  if (noclick) {
    selection.on("click.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
    setTimeout(function () {
      selection.on("click.drag", null);
    }, 0);
  }

  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");

function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
});

/***/ }),

/***/ "./node_modules/d3-dsv/index.js":
/*!**************************************!*\
  !*** ./node_modules/d3-dsv/index.js ***!
  \**************************************/
/*! exports provided: dsvFormat, csvParse, csvParseRows, csvFormat, csvFormatRows, tsvParse, tsvParseRows, tsvFormat, tsvFormatRows */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dsvFormat", function() { return _src_dsv__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_csv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/csv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return _src_csv__WEBPACK_IMPORTED_MODULE_1__["csvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return _src_csv__WEBPACK_IMPORTED_MODULE_1__["csvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return _src_csv__WEBPACK_IMPORTED_MODULE_1__["csvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return _src_csv__WEBPACK_IMPORTED_MODULE_1__["csvFormatRows"]; });

/* harmony import */ var _src_tsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/tsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return _src_tsv__WEBPACK_IMPORTED_MODULE_2__["tsvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return _src_tsv__WEBPACK_IMPORTED_MODULE_2__["tsvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return _src_tsv__WEBPACK_IMPORTED_MODULE_2__["tsvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return _src_tsv__WEBPACK_IMPORTED_MODULE_2__["tsvFormatRows"]; });





/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/*! exports provided: csvParse, csvParseRows, csvFormat, csvFormatRows */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return csvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return csvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return csvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return csvFormatRows; });
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-dsv/src/dsv.js");

var csv = Object(_dsv__WEBPACK_IMPORTED_MODULE_0__["default"])(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;

/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function (name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function (row, i) {
    return f(object(row), i, columns);
  };
} // Compute unique columns in order of discovery.


function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];
  rows.forEach(function (row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}

/* harmony default export */ __webpack_exports__["default"] = (function (delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert,
        columns,
        rows = parseRows(text, function (row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [],
        // output rows
    N = text.length,
        I = 0,
        // current character index
    n = 0,
        // current line number
    t,
        // current token
    eof = N <= 0,
        // current token followed by EOF?
    eol = false; // current token followed by EOL?
    // Strip the trailing newline.

    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL; // Unescape quotes.

      var i,
          j = I,
          c;

      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) {
          ;
        }

        if ((i = I) >= N) eof = true;else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      } // Find next delimiter or newline.


      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      } // Return last token before EOF.


      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];

      while (t !== EOL && t !== EOF) {
        row.push(t), t = token();
      }

      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
      return columns.map(function (column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? "" : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\"" : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
});

/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/*! exports provided: tsvParse, tsvParseRows, tsvFormat, tsvFormatRows */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return tsvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return tsvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return tsvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return tsvFormatRows; });
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-dsv/src/dsv.js");

var tsv = Object(_dsv__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;

/***/ }),

/***/ "./node_modules/d3-ease/index.js":
/*!***************************************!*\
  !*** ./node_modules/d3-ease/index.js ***!
  \***************************************/
/*! exports provided: easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/linear */ "./node_modules/d3-ease/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return _src_linear__WEBPACK_IMPORTED_MODULE_0__["linear"]; });

/* harmony import */ var _src_quad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/quad */ "./node_modules/d3-ease/src/quad.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return _src_quad__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return _src_quad__WEBPACK_IMPORTED_MODULE_1__["quadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return _src_quad__WEBPACK_IMPORTED_MODULE_1__["quadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return _src_quad__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony import */ var _src_cubic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/cubic */ "./node_modules/d3-ease/src/cubic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return _src_cubic__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return _src_cubic__WEBPACK_IMPORTED_MODULE_2__["cubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return _src_cubic__WEBPACK_IMPORTED_MODULE_2__["cubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return _src_cubic__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony import */ var _src_poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/poly */ "./node_modules/d3-ease/src/poly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return _src_poly__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return _src_poly__WEBPACK_IMPORTED_MODULE_3__["polyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return _src_poly__WEBPACK_IMPORTED_MODULE_3__["polyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return _src_poly__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony import */ var _src_sin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/sin */ "./node_modules/d3-ease/src/sin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return _src_sin__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return _src_sin__WEBPACK_IMPORTED_MODULE_4__["sinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return _src_sin__WEBPACK_IMPORTED_MODULE_4__["sinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return _src_sin__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony import */ var _src_exp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/exp */ "./node_modules/d3-ease/src/exp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return _src_exp__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return _src_exp__WEBPACK_IMPORTED_MODULE_5__["expIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return _src_exp__WEBPACK_IMPORTED_MODULE_5__["expOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return _src_exp__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony import */ var _src_circle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/circle */ "./node_modules/d3-ease/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_6__["circleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_6__["circleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony import */ var _src_bounce__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/bounce */ "./node_modules/d3-ease/src/bounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return _src_bounce__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return _src_bounce__WEBPACK_IMPORTED_MODULE_7__["bounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return _src_bounce__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return _src_bounce__WEBPACK_IMPORTED_MODULE_7__["bounceInOut"]; });

/* harmony import */ var _src_back__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/back */ "./node_modules/d3-ease/src/back.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return _src_back__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return _src_back__WEBPACK_IMPORTED_MODULE_8__["backIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return _src_back__WEBPACK_IMPORTED_MODULE_8__["backOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return _src_back__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony import */ var _src_elastic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/elastic */ "./node_modules/d3-ease/src/elastic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return _src_elastic__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return _src_elastic__WEBPACK_IMPORTED_MODULE_9__["elasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return _src_elastic__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return _src_elastic__WEBPACK_IMPORTED_MODULE_9__["elasticInOut"]; });












/***/ }),

/***/ "./node_modules/d3-ease/src/back.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/back.js ***!
  \******************************************/
/*! exports provided: backIn, backOut, backInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backIn", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backOut", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backInOut", function() { return backInOut; });
var overshoot = 1.70158;
var backIn = function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;
  return backIn;
}(overshoot);
var backOut = function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;
  return backOut;
}(overshoot);
var backInOut = function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;
  return backInOut;
}(overshoot);

/***/ }),

/***/ "./node_modules/d3-ease/src/bounce.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/bounce.js ***!
  \********************************************/
/*! exports provided: bounceIn, bounceOut, bounceInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceIn", function() { return bounceIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceOut", function() { return bounceOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceInOut", function() { return bounceInOut; });
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/circle.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/circle.js ***!
  \********************************************/
/*! exports provided: circleIn, circleOut, circleInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleIn", function() { return circleIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleOut", function() { return circleOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleInOut", function() { return circleInOut; });
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/*! exports provided: cubicIn, cubicOut, cubicInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicIn", function() { return cubicIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicOut", function() { return cubicOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicInOut", function() { return cubicInOut; });
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/elastic.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-ease/src/elastic.js ***!
  \*********************************************/
/*! exports provided: elasticIn, elasticOut, elasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticIn", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticOut", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticInOut", function() { return elasticInOut; });
var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;
var elasticIn = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticIn.period = function (p) {
    return custom(a, p);
  };

  return elasticIn;
}(amplitude, period);
var elasticOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticOut.period = function (p) {
    return custom(a, p);
  };

  return elasticOut;
}(amplitude, period);
var elasticInOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0 ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p) : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticInOut.period = function (p) {
    return custom(a, p);
  };

  return elasticInOut;
}(amplitude, period);

/***/ }),

/***/ "./node_modules/d3-ease/src/exp.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/exp.js ***!
  \*****************************************/
/*! exports provided: expIn, expOut, expInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expIn", function() { return expIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expOut", function() { return expOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expInOut", function() { return expInOut; });
function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}
function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/linear.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/linear.js ***!
  \********************************************/
/*! exports provided: linear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
function linear(t) {
  return +t;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/poly.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/poly.js ***!
  \******************************************/
/*! exports provided: polyIn, polyOut, polyInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyIn", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyOut", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyInOut", function() { return polyInOut; });
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;
  return polyIn;
}(exponent);
var polyOut = function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;
  return polyOut;
}(exponent);
var polyInOut = function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;
  return polyInOut;
}(exponent);

/***/ }),

/***/ "./node_modules/d3-ease/src/quad.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/quad.js ***!
  \******************************************/
/*! exports provided: quadIn, quadOut, quadInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadIn", function() { return quadIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadOut", function() { return quadOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadInOut", function() { return quadInOut; });
function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/sin.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/sin.js ***!
  \*****************************************/
/*! exports provided: sinIn, sinOut, sinInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinIn", function() { return sinIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinOut", function() { return sinOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinInOut", function() { return sinInOut; });
var pi = Math.PI,
    halfPi = pi / 2;
function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
  return Math.sin(t * halfPi);
}
function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo-projection/index.js ***!
  \*************************************************/
/*! exports provided: geoAiry, geoAiryRaw, geoAitoff, geoAitoffRaw, geoArmadillo, geoArmadilloRaw, geoAugust, geoAugustRaw, geoBaker, geoBakerRaw, geoBerghaus, geoBerghausRaw, geoBertin1953, geoBertin1953Raw, geoBoggs, geoBoggsRaw, geoBonne, geoBonneRaw, geoBottomley, geoBottomleyRaw, geoBromley, geoBromleyRaw, geoChamberlin, geoChamberlinRaw, geoChamberlinAfrica, geoCollignon, geoCollignonRaw, geoCraig, geoCraigRaw, geoCraster, geoCrasterRaw, geoCylindricalEqualArea, geoCylindricalEqualAreaRaw, geoCylindricalStereographic, geoCylindricalStereographicRaw, geoEckert1, geoEckert1Raw, geoEckert2, geoEckert2Raw, geoEckert3, geoEckert3Raw, geoEckert4, geoEckert4Raw, geoEckert5, geoEckert5Raw, geoEckert6, geoEckert6Raw, geoEisenlohr, geoEisenlohrRaw, geoFahey, geoFaheyRaw, geoFoucaut, geoFoucautRaw, geoGilbert, geoGingery, geoGingeryRaw, geoGinzburg4, geoGinzburg4Raw, geoGinzburg5, geoGinzburg5Raw, geoGinzburg6, geoGinzburg6Raw, geoGinzburg8, geoGinzburg8Raw, geoGinzburg9, geoGinzburg9Raw, geoGringorten, geoGringortenRaw, geoGuyou, geoGuyouRaw, geoHammer, geoHammerRaw, geoHammerRetroazimuthal, geoHammerRetroazimuthalRaw, geoHealpix, geoHealpixRaw, geoHill, geoHillRaw, geoHomolosine, geoHomolosineRaw, geoHyperelliptical, geoHyperellipticalRaw, geoInterrupt, geoInterruptedBoggs, geoInterruptedHomolosine, geoInterruptedMollweide, geoInterruptedMollweideHemispheres, geoInterruptedSinuMollweide, geoInterruptedSinusoidal, geoKavrayskiy7, geoKavrayskiy7Raw, geoLagrange, geoLagrangeRaw, geoLarrivee, geoLarriveeRaw, geoLaskowski, geoLaskowskiRaw, geoLittrow, geoLittrowRaw, geoLoximuthal, geoLoximuthalRaw, geoMiller, geoMillerRaw, geoModifiedStereographic, geoModifiedStereographicRaw, geoModifiedStereographicAlaska, geoModifiedStereographicGs48, geoModifiedStereographicGs50, geoModifiedStereographicMiller, geoModifiedStereographicLee, geoMollweide, geoMollweideRaw, geoMtFlatPolarParabolic, geoMtFlatPolarParabolicRaw, geoMtFlatPolarQuartic, geoMtFlatPolarQuarticRaw, geoMtFlatPolarSinusoidal, geoMtFlatPolarSinusoidalRaw, geoNaturalEarth, geoNaturalEarthRaw, geoNaturalEarth2, geoNaturalEarth2Raw, geoNellHammer, geoNellHammerRaw, geoPatterson, geoPattersonRaw, geoPolyconic, geoPolyconicRaw, geoPolyhedral, geoPolyhedralButterfly, geoPolyhedralCollignon, geoPolyhedralWaterman, geoProject, geoGringortenQuincuncial, geoPeirceQuincuncial, geoPierceQuincuncial, geoQuantize, geoQuincuncial, geoRectangularPolyconic, geoRectangularPolyconicRaw, geoRobinson, geoRobinsonRaw, geoSatellite, geoSatelliteRaw, geoSinuMollweide, geoSinuMollweideRaw, geoSinusoidal, geoSinusoidalRaw, geoStitch, geoTimes, geoTimesRaw, geoTwoPointAzimuthal, geoTwoPointAzimuthalRaw, geoTwoPointAzimuthalUsa, geoTwoPointEquidistant, geoTwoPointEquidistantRaw, geoTwoPointEquidistantUsa, geoVanDerGrinten, geoVanDerGrintenRaw, geoVanDerGrinten2, geoVanDerGrinten2Raw, geoVanDerGrinten3, geoVanDerGrinten3Raw, geoVanDerGrinten4, geoVanDerGrinten4Raw, geoWagner4, geoWagner4Raw, geoWagner6, geoWagner6Raw, geoWagner7, geoWagner7Raw, geoWiechel, geoWiechelRaw, geoWinkel3, geoWinkel3Raw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_airy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/airy */ "./node_modules/d3-geo-projection/src/airy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAiry", function() { return _src_airy__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAiryRaw", function() { return _src_airy__WEBPACK_IMPORTED_MODULE_0__["airyRaw"]; });

/* harmony import */ var _src_aitoff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/aitoff */ "./node_modules/d3-geo-projection/src/aitoff.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAitoff", function() { return _src_aitoff__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAitoffRaw", function() { return _src_aitoff__WEBPACK_IMPORTED_MODULE_1__["aitoffRaw"]; });

/* harmony import */ var _src_armadillo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/armadillo */ "./node_modules/d3-geo-projection/src/armadillo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArmadillo", function() { return _src_armadillo__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArmadilloRaw", function() { return _src_armadillo__WEBPACK_IMPORTED_MODULE_2__["armadilloRaw"]; });

/* harmony import */ var _src_august__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/august */ "./node_modules/d3-geo-projection/src/august.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAugust", function() { return _src_august__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAugustRaw", function() { return _src_august__WEBPACK_IMPORTED_MODULE_3__["augustRaw"]; });

/* harmony import */ var _src_baker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/baker */ "./node_modules/d3-geo-projection/src/baker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBaker", function() { return _src_baker__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBakerRaw", function() { return _src_baker__WEBPACK_IMPORTED_MODULE_4__["bakerRaw"]; });

/* harmony import */ var _src_berghaus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/berghaus */ "./node_modules/d3-geo-projection/src/berghaus.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBerghaus", function() { return _src_berghaus__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBerghausRaw", function() { return _src_berghaus__WEBPACK_IMPORTED_MODULE_5__["berghausRaw"]; });

/* harmony import */ var _src_bertin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/bertin */ "./node_modules/d3-geo-projection/src/bertin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBertin1953", function() { return _src_bertin__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBertin1953Raw", function() { return _src_bertin__WEBPACK_IMPORTED_MODULE_6__["bertin1953Raw"]; });

/* harmony import */ var _src_boggs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/boggs */ "./node_modules/d3-geo-projection/src/boggs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBoggs", function() { return _src_boggs__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBoggsRaw", function() { return _src_boggs__WEBPACK_IMPORTED_MODULE_7__["boggsRaw"]; });

/* harmony import */ var _src_bonne__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/bonne */ "./node_modules/d3-geo-projection/src/bonne.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBonne", function() { return _src_bonne__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBonneRaw", function() { return _src_bonne__WEBPACK_IMPORTED_MODULE_8__["bonneRaw"]; });

/* harmony import */ var _src_bottomley__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/bottomley */ "./node_modules/d3-geo-projection/src/bottomley.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBottomley", function() { return _src_bottomley__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBottomleyRaw", function() { return _src_bottomley__WEBPACK_IMPORTED_MODULE_9__["bottomleyRaw"]; });

/* harmony import */ var _src_bromley__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/bromley */ "./node_modules/d3-geo-projection/src/bromley.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBromley", function() { return _src_bromley__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBromleyRaw", function() { return _src_bromley__WEBPACK_IMPORTED_MODULE_10__["bromleyRaw"]; });

/* harmony import */ var _src_chamberlin__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/chamberlin */ "./node_modules/d3-geo-projection/src/chamberlin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlin", function() { return _src_chamberlin__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlinRaw", function() { return _src_chamberlin__WEBPACK_IMPORTED_MODULE_11__["chamberlinRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlinAfrica", function() { return _src_chamberlin__WEBPACK_IMPORTED_MODULE_11__["chamberlinAfrica"]; });

/* harmony import */ var _src_collignon__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/collignon */ "./node_modules/d3-geo-projection/src/collignon.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCollignon", function() { return _src_collignon__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCollignonRaw", function() { return _src_collignon__WEBPACK_IMPORTED_MODULE_12__["collignonRaw"]; });

/* harmony import */ var _src_craig__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/craig */ "./node_modules/d3-geo-projection/src/craig.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraig", function() { return _src_craig__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraigRaw", function() { return _src_craig__WEBPACK_IMPORTED_MODULE_13__["craigRaw"]; });

/* harmony import */ var _src_craster__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/craster */ "./node_modules/d3-geo-projection/src/craster.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraster", function() { return _src_craster__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCrasterRaw", function() { return _src_craster__WEBPACK_IMPORTED_MODULE_14__["crasterRaw"]; });

/* harmony import */ var _src_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/cylindricalEqualArea */ "./node_modules/d3-geo-projection/src/cylindricalEqualArea.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalEqualArea", function() { return _src_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalEqualAreaRaw", function() { return _src_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_15__["cylindricalEqualAreaRaw"]; });

/* harmony import */ var _src_cylindricalStereographic__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/cylindricalStereographic */ "./node_modules/d3-geo-projection/src/cylindricalStereographic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalStereographic", function() { return _src_cylindricalStereographic__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalStereographicRaw", function() { return _src_cylindricalStereographic__WEBPACK_IMPORTED_MODULE_16__["cylindricalStereographicRaw"]; });

/* harmony import */ var _src_eckert1_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/eckert1.js */ "./node_modules/d3-geo-projection/src/eckert1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert1", function() { return _src_eckert1_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert1Raw", function() { return _src_eckert1_js__WEBPACK_IMPORTED_MODULE_17__["eckert1Raw"]; });

/* harmony import */ var _src_eckert2_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/eckert2.js */ "./node_modules/d3-geo-projection/src/eckert2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert2", function() { return _src_eckert2_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert2Raw", function() { return _src_eckert2_js__WEBPACK_IMPORTED_MODULE_18__["eckert2Raw"]; });

/* harmony import */ var _src_eckert3_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/eckert3.js */ "./node_modules/d3-geo-projection/src/eckert3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert3", function() { return _src_eckert3_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert3Raw", function() { return _src_eckert3_js__WEBPACK_IMPORTED_MODULE_19__["eckert3Raw"]; });

/* harmony import */ var _src_eckert4_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/eckert4.js */ "./node_modules/d3-geo-projection/src/eckert4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert4", function() { return _src_eckert4_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert4Raw", function() { return _src_eckert4_js__WEBPACK_IMPORTED_MODULE_20__["eckert4Raw"]; });

/* harmony import */ var _src_eckert5_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/eckert5.js */ "./node_modules/d3-geo-projection/src/eckert5.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert5", function() { return _src_eckert5_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert5Raw", function() { return _src_eckert5_js__WEBPACK_IMPORTED_MODULE_21__["eckert5Raw"]; });

/* harmony import */ var _src_eckert6_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/eckert6.js */ "./node_modules/d3-geo-projection/src/eckert6.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert6", function() { return _src_eckert6_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert6Raw", function() { return _src_eckert6_js__WEBPACK_IMPORTED_MODULE_22__["eckert6Raw"]; });

/* harmony import */ var _src_eisenlohr_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/eisenlohr.js */ "./node_modules/d3-geo-projection/src/eisenlohr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEisenlohr", function() { return _src_eisenlohr_js__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEisenlohrRaw", function() { return _src_eisenlohr_js__WEBPACK_IMPORTED_MODULE_23__["eisenlohrRaw"]; });

/* harmony import */ var _src_fahey_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/fahey.js */ "./node_modules/d3-geo-projection/src/fahey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFahey", function() { return _src_fahey_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFaheyRaw", function() { return _src_fahey_js__WEBPACK_IMPORTED_MODULE_24__["faheyRaw"]; });

/* harmony import */ var _src_foucaut_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/foucaut.js */ "./node_modules/d3-geo-projection/src/foucaut.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFoucaut", function() { return _src_foucaut_js__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFoucautRaw", function() { return _src_foucaut_js__WEBPACK_IMPORTED_MODULE_25__["foucautRaw"]; });

/* harmony import */ var _src_gilbert_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/gilbert.js */ "./node_modules/d3-geo-projection/src/gilbert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGilbert", function() { return _src_gilbert_js__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _src_gingery_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/gingery.js */ "./node_modules/d3-geo-projection/src/gingery.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGingery", function() { return _src_gingery_js__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGingeryRaw", function() { return _src_gingery_js__WEBPACK_IMPORTED_MODULE_27__["gingeryRaw"]; });

/* harmony import */ var _src_ginzburg4_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/ginzburg4.js */ "./node_modules/d3-geo-projection/src/ginzburg4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg4", function() { return _src_ginzburg4_js__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg4Raw", function() { return _src_ginzburg4_js__WEBPACK_IMPORTED_MODULE_28__["ginzburg4Raw"]; });

/* harmony import */ var _src_ginzburg5_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/ginzburg5.js */ "./node_modules/d3-geo-projection/src/ginzburg5.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg5", function() { return _src_ginzburg5_js__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg5Raw", function() { return _src_ginzburg5_js__WEBPACK_IMPORTED_MODULE_29__["ginzburg5Raw"]; });

/* harmony import */ var _src_ginzburg6_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./src/ginzburg6.js */ "./node_modules/d3-geo-projection/src/ginzburg6.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg6", function() { return _src_ginzburg6_js__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg6Raw", function() { return _src_ginzburg6_js__WEBPACK_IMPORTED_MODULE_30__["ginzburg6Raw"]; });

/* harmony import */ var _src_ginzburg8_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./src/ginzburg8.js */ "./node_modules/d3-geo-projection/src/ginzburg8.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg8", function() { return _src_ginzburg8_js__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg8Raw", function() { return _src_ginzburg8_js__WEBPACK_IMPORTED_MODULE_31__["ginzburg8Raw"]; });

/* harmony import */ var _src_ginzburg9_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./src/ginzburg9.js */ "./node_modules/d3-geo-projection/src/ginzburg9.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg9", function() { return _src_ginzburg9_js__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg9Raw", function() { return _src_ginzburg9_js__WEBPACK_IMPORTED_MODULE_32__["ginzburg9Raw"]; });

/* harmony import */ var _src_gringorten_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./src/gringorten.js */ "./node_modules/d3-geo-projection/src/gringorten.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringorten", function() { return _src_gringorten_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringortenRaw", function() { return _src_gringorten_js__WEBPACK_IMPORTED_MODULE_33__["gringortenRaw"]; });

/* harmony import */ var _src_guyou_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./src/guyou.js */ "./node_modules/d3-geo-projection/src/guyou.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGuyou", function() { return _src_guyou_js__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGuyouRaw", function() { return _src_guyou_js__WEBPACK_IMPORTED_MODULE_34__["guyouRaw"]; });

/* harmony import */ var _src_hammer_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./src/hammer.js */ "./node_modules/d3-geo-projection/src/hammer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammer", function() { return _src_hammer_js__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRaw", function() { return _src_hammer_js__WEBPACK_IMPORTED_MODULE_35__["hammerRaw"]; });

/* harmony import */ var _src_hammerRetroazimuthal_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./src/hammerRetroazimuthal.js */ "./node_modules/d3-geo-projection/src/hammerRetroazimuthal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRetroazimuthal", function() { return _src_hammerRetroazimuthal_js__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRetroazimuthalRaw", function() { return _src_hammerRetroazimuthal_js__WEBPACK_IMPORTED_MODULE_36__["hammerRetroazimuthalRaw"]; });

/* harmony import */ var _src_healpix_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./src/healpix.js */ "./node_modules/d3-geo-projection/src/healpix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHealpix", function() { return _src_healpix_js__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHealpixRaw", function() { return _src_healpix_js__WEBPACK_IMPORTED_MODULE_37__["healpixRaw"]; });

/* harmony import */ var _src_hill_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./src/hill.js */ "./node_modules/d3-geo-projection/src/hill.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHill", function() { return _src_hill_js__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHillRaw", function() { return _src_hill_js__WEBPACK_IMPORTED_MODULE_38__["hillRaw"]; });

/* harmony import */ var _src_homolosine_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./src/homolosine.js */ "./node_modules/d3-geo-projection/src/homolosine.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHomolosine", function() { return _src_homolosine_js__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHomolosineRaw", function() { return _src_homolosine_js__WEBPACK_IMPORTED_MODULE_39__["homolosineRaw"]; });

/* harmony import */ var _src_hyperelliptical__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./src/hyperelliptical */ "./node_modules/d3-geo-projection/src/hyperelliptical.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHyperelliptical", function() { return _src_hyperelliptical__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHyperellipticalRaw", function() { return _src_hyperelliptical__WEBPACK_IMPORTED_MODULE_40__["hyperellipticalRaw"]; });

/* harmony import */ var _src_interrupted_index__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./src/interrupted/index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterrupt", function() { return _src_interrupted_index__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _src_interrupted_boggs__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./src/interrupted/boggs */ "./node_modules/d3-geo-projection/src/interrupted/boggs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedBoggs", function() { return _src_interrupted_boggs__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _src_interrupted_homolosine__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./src/interrupted/homolosine */ "./node_modules/d3-geo-projection/src/interrupted/homolosine.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedHomolosine", function() { return _src_interrupted_homolosine__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _src_interrupted_mollweide__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./src/interrupted/mollweide */ "./node_modules/d3-geo-projection/src/interrupted/mollweide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedMollweide", function() { return _src_interrupted_mollweide__WEBPACK_IMPORTED_MODULE_44__["default"]; });

/* harmony import */ var _src_interrupted_mollweideHemispheres__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./src/interrupted/mollweideHemispheres */ "./node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedMollweideHemispheres", function() { return _src_interrupted_mollweideHemispheres__WEBPACK_IMPORTED_MODULE_45__["default"]; });

/* harmony import */ var _src_interrupted_sinuMollweide__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./src/interrupted/sinuMollweide */ "./node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedSinuMollweide", function() { return _src_interrupted_sinuMollweide__WEBPACK_IMPORTED_MODULE_46__["default"]; });

/* harmony import */ var _src_interrupted_sinusoidal__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./src/interrupted/sinusoidal */ "./node_modules/d3-geo-projection/src/interrupted/sinusoidal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedSinusoidal", function() { return _src_interrupted_sinusoidal__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony import */ var _src_kavrayskiy7_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./src/kavrayskiy7.js */ "./node_modules/d3-geo-projection/src/kavrayskiy7.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoKavrayskiy7", function() { return _src_kavrayskiy7_js__WEBPACK_IMPORTED_MODULE_48__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoKavrayskiy7Raw", function() { return _src_kavrayskiy7_js__WEBPACK_IMPORTED_MODULE_48__["kavrayskiy7Raw"]; });

/* harmony import */ var _src_lagrange_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./src/lagrange.js */ "./node_modules/d3-geo-projection/src/lagrange.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLagrange", function() { return _src_lagrange_js__WEBPACK_IMPORTED_MODULE_49__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLagrangeRaw", function() { return _src_lagrange_js__WEBPACK_IMPORTED_MODULE_49__["lagrangeRaw"]; });

/* harmony import */ var _src_larrivee__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./src/larrivee */ "./node_modules/d3-geo-projection/src/larrivee.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLarrivee", function() { return _src_larrivee__WEBPACK_IMPORTED_MODULE_50__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLarriveeRaw", function() { return _src_larrivee__WEBPACK_IMPORTED_MODULE_50__["larriveeRaw"]; });

/* harmony import */ var _src_laskowski__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./src/laskowski */ "./node_modules/d3-geo-projection/src/laskowski.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLaskowski", function() { return _src_laskowski__WEBPACK_IMPORTED_MODULE_51__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLaskowskiRaw", function() { return _src_laskowski__WEBPACK_IMPORTED_MODULE_51__["laskowskiRaw"]; });

/* harmony import */ var _src_littrow_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./src/littrow.js */ "./node_modules/d3-geo-projection/src/littrow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLittrow", function() { return _src_littrow_js__WEBPACK_IMPORTED_MODULE_52__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLittrowRaw", function() { return _src_littrow_js__WEBPACK_IMPORTED_MODULE_52__["littrowRaw"]; });

/* harmony import */ var _src_loximuthal_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./src/loximuthal.js */ "./node_modules/d3-geo-projection/src/loximuthal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLoximuthal", function() { return _src_loximuthal_js__WEBPACK_IMPORTED_MODULE_53__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLoximuthalRaw", function() { return _src_loximuthal_js__WEBPACK_IMPORTED_MODULE_53__["loximuthalRaw"]; });

/* harmony import */ var _src_miller__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./src/miller */ "./node_modules/d3-geo-projection/src/miller.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMiller", function() { return _src_miller__WEBPACK_IMPORTED_MODULE_54__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMillerRaw", function() { return _src_miller__WEBPACK_IMPORTED_MODULE_54__["millerRaw"]; });

/* harmony import */ var _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./src/modifiedStereographic */ "./node_modules/d3-geo-projection/src/modifiedStereographic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographic", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_55__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicRaw", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_55__["modifiedStereographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicAlaska", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_55__["modifiedStereographicAlaska"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicGs48", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_55__["modifiedStereographicGs48"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicGs50", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_55__["modifiedStereographicGs50"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicMiller", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_55__["modifiedStereographicMiller"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicLee", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_55__["modifiedStereographicLee"]; });

/* harmony import */ var _src_mollweide__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./src/mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMollweide", function() { return _src_mollweide__WEBPACK_IMPORTED_MODULE_56__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMollweideRaw", function() { return _src_mollweide__WEBPACK_IMPORTED_MODULE_56__["mollweideRaw"]; });

/* harmony import */ var _src_mtFlatPolarParabolic__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./src/mtFlatPolarParabolic */ "./node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarParabolic", function() { return _src_mtFlatPolarParabolic__WEBPACK_IMPORTED_MODULE_57__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarParabolicRaw", function() { return _src_mtFlatPolarParabolic__WEBPACK_IMPORTED_MODULE_57__["mtFlatPolarParabolicRaw"]; });

/* harmony import */ var _src_mtFlatPolarQuartic__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./src/mtFlatPolarQuartic */ "./node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarQuartic", function() { return _src_mtFlatPolarQuartic__WEBPACK_IMPORTED_MODULE_58__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarQuarticRaw", function() { return _src_mtFlatPolarQuartic__WEBPACK_IMPORTED_MODULE_58__["mtFlatPolarQuarticRaw"]; });

/* harmony import */ var _src_mtFlatPolarSinusoidal__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./src/mtFlatPolarSinusoidal */ "./node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarSinusoidal", function() { return _src_mtFlatPolarSinusoidal__WEBPACK_IMPORTED_MODULE_59__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarSinusoidalRaw", function() { return _src_mtFlatPolarSinusoidal__WEBPACK_IMPORTED_MODULE_59__["mtFlatPolarSinusoidalRaw"]; });

/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_60__["geoNaturalEarth1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarthRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_60__["geoNaturalEarth1Raw"]; });

/* harmony import */ var _src_naturalEarth2__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./src/naturalEarth2 */ "./node_modules/d3-geo-projection/src/naturalEarth2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth2", function() { return _src_naturalEarth2__WEBPACK_IMPORTED_MODULE_61__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth2Raw", function() { return _src_naturalEarth2__WEBPACK_IMPORTED_MODULE_61__["naturalEarth2Raw"]; });

/* harmony import */ var _src_nellHammer__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./src/nellHammer */ "./node_modules/d3-geo-projection/src/nellHammer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNellHammer", function() { return _src_nellHammer__WEBPACK_IMPORTED_MODULE_62__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNellHammerRaw", function() { return _src_nellHammer__WEBPACK_IMPORTED_MODULE_62__["nellHammerRaw"]; });

/* harmony import */ var _src_patterson__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./src/patterson */ "./node_modules/d3-geo-projection/src/patterson.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPatterson", function() { return _src_patterson__WEBPACK_IMPORTED_MODULE_63__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPattersonRaw", function() { return _src_patterson__WEBPACK_IMPORTED_MODULE_63__["pattersonRaw"]; });

/* harmony import */ var _src_polyconic__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./src/polyconic */ "./node_modules/d3-geo-projection/src/polyconic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyconic", function() { return _src_polyconic__WEBPACK_IMPORTED_MODULE_64__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyconicRaw", function() { return _src_polyconic__WEBPACK_IMPORTED_MODULE_64__["polyconicRaw"]; });

/* harmony import */ var _src_polyhedral_index_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./src/polyhedral/index.js */ "./node_modules/d3-geo-projection/src/polyhedral/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedral", function() { return _src_polyhedral_index_js__WEBPACK_IMPORTED_MODULE_65__["default"]; });

/* harmony import */ var _src_polyhedral_butterfly_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./src/polyhedral/butterfly.js */ "./node_modules/d3-geo-projection/src/polyhedral/butterfly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralButterfly", function() { return _src_polyhedral_butterfly_js__WEBPACK_IMPORTED_MODULE_66__["default"]; });

/* harmony import */ var _src_polyhedral_collignon_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./src/polyhedral/collignon.js */ "./node_modules/d3-geo-projection/src/polyhedral/collignon.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralCollignon", function() { return _src_polyhedral_collignon_js__WEBPACK_IMPORTED_MODULE_67__["default"]; });

/* harmony import */ var _src_polyhedral_waterman_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./src/polyhedral/waterman.js */ "./node_modules/d3-geo-projection/src/polyhedral/waterman.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralWaterman", function() { return _src_polyhedral_waterman_js__WEBPACK_IMPORTED_MODULE_68__["default"]; });

/* harmony import */ var _src_project_index__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./src/project/index */ "./node_modules/d3-geo-projection/src/project/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProject", function() { return _src_project_index__WEBPACK_IMPORTED_MODULE_69__["default"]; });

/* harmony import */ var _src_quincuncial_gringorten_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./src/quincuncial/gringorten.js */ "./node_modules/d3-geo-projection/src/quincuncial/gringorten.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringortenQuincuncial", function() { return _src_quincuncial_gringorten_js__WEBPACK_IMPORTED_MODULE_70__["default"]; });

/* harmony import */ var _src_quincuncial_peirce_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./src/quincuncial/peirce.js */ "./node_modules/d3-geo-projection/src/quincuncial/peirce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPeirceQuincuncial", function() { return _src_quincuncial_peirce_js__WEBPACK_IMPORTED_MODULE_71__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPierceQuincuncial", function() { return _src_quincuncial_peirce_js__WEBPACK_IMPORTED_MODULE_71__["default"]; });

/* harmony import */ var _src_quantize__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./src/quantize */ "./node_modules/d3-geo-projection/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoQuantize", function() { return _src_quantize__WEBPACK_IMPORTED_MODULE_72__["default"]; });

/* harmony import */ var _src_quincuncial_index_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./src/quincuncial/index.js */ "./node_modules/d3-geo-projection/src/quincuncial/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoQuincuncial", function() { return _src_quincuncial_index_js__WEBPACK_IMPORTED_MODULE_73__["default"]; });

/* harmony import */ var _src_rectangularPolyconic__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./src/rectangularPolyconic */ "./node_modules/d3-geo-projection/src/rectangularPolyconic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRectangularPolyconic", function() { return _src_rectangularPolyconic__WEBPACK_IMPORTED_MODULE_74__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRectangularPolyconicRaw", function() { return _src_rectangularPolyconic__WEBPACK_IMPORTED_MODULE_74__["rectangularPolyconicRaw"]; });

/* harmony import */ var _src_robinson__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./src/robinson */ "./node_modules/d3-geo-projection/src/robinson.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRobinson", function() { return _src_robinson__WEBPACK_IMPORTED_MODULE_75__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRobinsonRaw", function() { return _src_robinson__WEBPACK_IMPORTED_MODULE_75__["robinsonRaw"]; });

/* harmony import */ var _src_satellite__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./src/satellite */ "./node_modules/d3-geo-projection/src/satellite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSatellite", function() { return _src_satellite__WEBPACK_IMPORTED_MODULE_76__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSatelliteRaw", function() { return _src_satellite__WEBPACK_IMPORTED_MODULE_76__["satelliteRaw"]; });

/* harmony import */ var _src_sinuMollweide__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./src/sinuMollweide */ "./node_modules/d3-geo-projection/src/sinuMollweide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinuMollweide", function() { return _src_sinuMollweide__WEBPACK_IMPORTED_MODULE_77__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinuMollweideRaw", function() { return _src_sinuMollweide__WEBPACK_IMPORTED_MODULE_77__["sinuMollweideRaw"]; });

/* harmony import */ var _src_sinusoidal__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./src/sinusoidal */ "./node_modules/d3-geo-projection/src/sinusoidal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinusoidal", function() { return _src_sinusoidal__WEBPACK_IMPORTED_MODULE_78__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinusoidalRaw", function() { return _src_sinusoidal__WEBPACK_IMPORTED_MODULE_78__["sinusoidalRaw"]; });

/* harmony import */ var _src_stitch__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./src/stitch */ "./node_modules/d3-geo-projection/src/stitch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStitch", function() { return _src_stitch__WEBPACK_IMPORTED_MODULE_79__["default"]; });

/* harmony import */ var _src_times__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./src/times */ "./node_modules/d3-geo-projection/src/times.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTimes", function() { return _src_times__WEBPACK_IMPORTED_MODULE_80__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTimesRaw", function() { return _src_times__WEBPACK_IMPORTED_MODULE_80__["timesRaw"]; });

/* harmony import */ var _src_twoPointAzimuthal__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./src/twoPointAzimuthal */ "./node_modules/d3-geo-projection/src/twoPointAzimuthal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthal", function() { return _src_twoPointAzimuthal__WEBPACK_IMPORTED_MODULE_81__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthalRaw", function() { return _src_twoPointAzimuthal__WEBPACK_IMPORTED_MODULE_81__["twoPointAzimuthalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthalUsa", function() { return _src_twoPointAzimuthal__WEBPACK_IMPORTED_MODULE_81__["twoPointAzimuthalUsa"]; });

/* harmony import */ var _src_twoPointEquidistant__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./src/twoPointEquidistant */ "./node_modules/d3-geo-projection/src/twoPointEquidistant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistant", function() { return _src_twoPointEquidistant__WEBPACK_IMPORTED_MODULE_82__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistantRaw", function() { return _src_twoPointEquidistant__WEBPACK_IMPORTED_MODULE_82__["twoPointEquidistantRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistantUsa", function() { return _src_twoPointEquidistant__WEBPACK_IMPORTED_MODULE_82__["twoPointEquidistantUsa"]; });

/* harmony import */ var _src_vanDerGrinten__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./src/vanDerGrinten */ "./node_modules/d3-geo-projection/src/vanDerGrinten.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten", function() { return _src_vanDerGrinten__WEBPACK_IMPORTED_MODULE_83__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrintenRaw", function() { return _src_vanDerGrinten__WEBPACK_IMPORTED_MODULE_83__["vanDerGrintenRaw"]; });

/* harmony import */ var _src_vanDerGrinten2__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./src/vanDerGrinten2 */ "./node_modules/d3-geo-projection/src/vanDerGrinten2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten2", function() { return _src_vanDerGrinten2__WEBPACK_IMPORTED_MODULE_84__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten2Raw", function() { return _src_vanDerGrinten2__WEBPACK_IMPORTED_MODULE_84__["vanDerGrinten2Raw"]; });

/* harmony import */ var _src_vanDerGrinten3__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./src/vanDerGrinten3 */ "./node_modules/d3-geo-projection/src/vanDerGrinten3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten3", function() { return _src_vanDerGrinten3__WEBPACK_IMPORTED_MODULE_85__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten3Raw", function() { return _src_vanDerGrinten3__WEBPACK_IMPORTED_MODULE_85__["vanDerGrinten3Raw"]; });

/* harmony import */ var _src_vanDerGrinten4__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./src/vanDerGrinten4 */ "./node_modules/d3-geo-projection/src/vanDerGrinten4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten4", function() { return _src_vanDerGrinten4__WEBPACK_IMPORTED_MODULE_86__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten4Raw", function() { return _src_vanDerGrinten4__WEBPACK_IMPORTED_MODULE_86__["vanDerGrinten4Raw"]; });

/* harmony import */ var _src_wagner4_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./src/wagner4.js */ "./node_modules/d3-geo-projection/src/wagner4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner4", function() { return _src_wagner4_js__WEBPACK_IMPORTED_MODULE_87__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner4Raw", function() { return _src_wagner4_js__WEBPACK_IMPORTED_MODULE_87__["wagner4Raw"]; });

/* harmony import */ var _src_wagner6_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./src/wagner6.js */ "./node_modules/d3-geo-projection/src/wagner6.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner6", function() { return _src_wagner6_js__WEBPACK_IMPORTED_MODULE_88__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner6Raw", function() { return _src_wagner6_js__WEBPACK_IMPORTED_MODULE_88__["wagner6Raw"]; });

/* harmony import */ var _src_wagner7_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./src/wagner7.js */ "./node_modules/d3-geo-projection/src/wagner7.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner7", function() { return _src_wagner7_js__WEBPACK_IMPORTED_MODULE_89__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner7Raw", function() { return _src_wagner7_js__WEBPACK_IMPORTED_MODULE_89__["wagner7Raw"]; });

/* harmony import */ var _src_wiechel_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./src/wiechel.js */ "./node_modules/d3-geo-projection/src/wiechel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWiechel", function() { return _src_wiechel_js__WEBPACK_IMPORTED_MODULE_90__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWiechelRaw", function() { return _src_wiechel_js__WEBPACK_IMPORTED_MODULE_90__["wiechelRaw"]; });

/* harmony import */ var _src_winkel3__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./src/winkel3 */ "./node_modules/d3-geo-projection/src/winkel3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWinkel3", function() { return _src_winkel3__WEBPACK_IMPORTED_MODULE_91__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWinkel3Raw", function() { return _src_winkel3__WEBPACK_IMPORTED_MODULE_91__["winkel3Raw"]; });





























































 // DEPRECATED moved to d3-geo












 // DEPRECATED misspelling






















/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/index.js ***!
  \*********************************************************************/
/*! exports provided: geoArea, geoBounds, geoCentroid, geoCircle, geoClipAntimeridian, geoClipCircle, geoClipExtent, geoClipRectangle, geoContains, geoDistance, geoGraticule, geoGraticule10, geoInterpolate, geoLength, geoPath, geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEqualAreaRaw, geoAzimuthalEquidistant, geoAzimuthalEquidistantRaw, geoConicConformal, geoConicConformalRaw, geoConicEqualArea, geoConicEqualAreaRaw, geoConicEquidistant, geoConicEquidistantRaw, geoEquirectangular, geoEquirectangularRaw, geoGnomonic, geoGnomonicRaw, geoIdentity, geoProjection, geoProjectionMutator, geoMercator, geoMercatorRaw, geoNaturalEarth1, geoNaturalEarth1Raw, geoOrthographic, geoOrthographicRaw, geoStereographic, geoStereographicRaw, geoTransverseMercator, geoTransverseMercatorRaw, geoRotation, geoStream, geoTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/area */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/area.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArea", function() { return _src_area__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/bounds */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/bounds.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBounds", function() { return _src_bounds__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_centroid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/centroid */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/centroid.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCentroid", function() { return _src_centroid__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/circle */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCircle", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_clip_antimeridian__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/clip/antimeridian */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipAntimeridian", function() { return _src_clip_antimeridian__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_clip_circle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/clip/circle */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipCircle", function() { return _src_clip_circle__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_clip_extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/clip/extent */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipExtent", function() { return _src_clip_extent__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_clip_rectangle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/clip/rectangle */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipRectangle", function() { return _src_clip_rectangle__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_contains__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/contains */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/contains.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoContains", function() { return _src_contains__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_distance__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/distance */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/distance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoDistance", function() { return _src_distance__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _src_graticule__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/graticule */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/graticule.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule", function() { return _src_graticule__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule10", function() { return _src_graticule__WEBPACK_IMPORTED_MODULE_10__["graticule10"]; });

/* harmony import */ var _src_interpolate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/interpolate */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/interpolate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterpolate", function() { return _src_interpolate__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _src_length__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/length */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/length.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLength", function() { return _src_length__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _src_path_index__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/path/index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPath", function() { return _src_path_index__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _src_projection_albers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/projection/albers */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbers", function() { return _src_projection_albers__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _src_projection_albersUsa__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/projection/albersUsa */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albersUsa.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbersUsa", function() { return _src_projection_albersUsa__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/projection/azimuthalEqualArea */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthalEqualArea.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualArea", function() { return _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualAreaRaw", function() { return _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_16__["azimuthalEqualAreaRaw"]; });

/* harmony import */ var _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/projection/azimuthalEquidistant */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthalEquidistant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistant", function() { return _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistantRaw", function() { return _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_17__["azimuthalEquidistantRaw"]; });

/* harmony import */ var _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/projection/conicConformal */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicConformal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformal", function() { return _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformalRaw", function() { return _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_18__["conicConformalRaw"]; });

/* harmony import */ var _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/projection/conicEqualArea */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualArea", function() { return _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualAreaRaw", function() { return _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_19__["conicEqualAreaRaw"]; });

/* harmony import */ var _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/projection/conicEquidistant */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEquidistant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistant", function() { return _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistantRaw", function() { return _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_20__["conicEquidistantRaw"]; });

/* harmony import */ var _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/projection/equirectangular */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/equirectangular.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangular", function() { return _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangularRaw", function() { return _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_21__["equirectangularRaw"]; });

/* harmony import */ var _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/projection/gnomonic */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/gnomonic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonic", function() { return _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonicRaw", function() { return _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_22__["gnomonicRaw"]; });

/* harmony import */ var _src_projection_identity__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/projection/identity */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/identity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoIdentity", function() { return _src_projection_identity__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _src_projection_index__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/projection/index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjection", function() { return _src_projection_index__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjectionMutator", function() { return _src_projection_index__WEBPACK_IMPORTED_MODULE_24__["projectionMutator"]; });

/* harmony import */ var _src_projection_mercator__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/projection/mercator */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/mercator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercator", function() { return _src_projection_mercator__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercatorRaw", function() { return _src_projection_mercator__WEBPACK_IMPORTED_MODULE_25__["mercatorRaw"]; });

/* harmony import */ var _src_projection_naturalEarth1__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/projection/naturalEarth1 */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/naturalEarth1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1", function() { return _src_projection_naturalEarth1__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1Raw", function() { return _src_projection_naturalEarth1__WEBPACK_IMPORTED_MODULE_26__["naturalEarth1Raw"]; });

/* harmony import */ var _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/projection/orthographic */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/orthographic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographic", function() { return _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographicRaw", function() { return _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_27__["orthographicRaw"]; });

/* harmony import */ var _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/projection/stereographic */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/stereographic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographic", function() { return _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographicRaw", function() { return _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_28__["stereographicRaw"]; });

/* harmony import */ var _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/projection/transverseMercator */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/transverseMercator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercator", function() { return _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercatorRaw", function() { return _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_29__["transverseMercatorRaw"]; });

/* harmony import */ var _src_rotation__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./src/rotation */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRotation", function() { return _src_rotation__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _src_stream__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./src/stream */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStream", function() { return _src_stream__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _src_transform__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./src/transform */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransform", function() { return _src_transform__WEBPACK_IMPORTED_MODULE_32__["default"]; });







 // DEPRECATED! Use d3.geoIdentity().clipExtent(…).




























/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/adder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/adder.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return new Adder();
});

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function reset() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function add(y) {
    _add(temp, y, this.t);

    _add(this, temp.s, this.s);

    if (this.s) this.t += temp.t;else this.s = temp.t;
  },
  valueOf: function valueOf() {
    return this.s;
  }
};
var temp = new Adder();

function _add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = a - av + (b - bv);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/area.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/area.js ***!
  \************************************************************************/
/*! exports provided: areaRingSum, areaStream, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areaRingSum", function() { return areaRingSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areaStream", function() { return areaStream; });
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js");




var areaRingSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])();
var areaSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;
var areaStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: function polygonStart() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function polygonEnd() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["tau"] + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
  },
  sphere: function sphere() {
    areaSum.add(_math__WEBPACK_IMPORTED_MODULE_1__["tau"]);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  lambda0 = lambda, cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi = phi / 2 + _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]), sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);
}

function areaPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  phi = phi / 2 + _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]; // half the angular distance from south pole
  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).

  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(adLambda),
      v = k * sdLambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(adLambda);
  areaRingSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(v, u)); // Advance the previous points.

  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

/* harmony default export */ __webpack_exports__["default"] = (function (object) {
  areaSum.reset();
  Object(_stream__WEBPACK_IMPORTED_MODULE_3__["default"])(object, areaStream);
  return areaSum * 2;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/bounds.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/bounds.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/adder.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/area.js");
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js");





var lambda0,
    phi0,
    lambda1,
    phi1,
    // bounds
lambda2,
    // previous lambda-coordinate
lambda00,
    phi00,
    // first point
p0,
    // previous 3D point
deltaSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    ranges,
    range;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function polygonStart() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].polygonStart();
  },
  polygonEnd: function polygonEnd() {
    _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (_area__WEBPACK_IMPORTED_MODULE_1__["areaRingSum"] < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > _math__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) phi1 = 90;else if (deltaSum < -_math__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesian"])([lambda * _math__WEBPACK_IMPORTED_MODULE_3__["radians"], phi * _math__WEBPACK_IMPORTED_MODULE_3__["radians"]]);

  if (p0) {
    var normal = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesianCross"])(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesianCross"])(equatorial, normal);
    Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesianNormalizeInPlace"])(inflection);
    inflection = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["spherical"])(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * _math__WEBPACK_IMPORTED_MODULE_3__["degrees"] * sign,
        phii,
        antimeridian = Object(_math__WEBPACK_IMPORTED_MODULE_3__["abs"])(delta) > 180;

    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * _math__WEBPACK_IMPORTED_MODULE_3__["degrees"];
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * _math__WEBPACK_IMPORTED_MODULE_3__["degrees"];
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  }

  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_3__["abs"])(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }

  _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);
  _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].lineEnd();
  if (Object(_math__WEBPACK_IMPORTED_MODULE_3__["abs"])(deltaSum) > _math__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
} // Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.


function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ __webpack_exports__["default"] = (function (feature) {
  var i, n, a, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  Object(_stream__WEBPACK_IMPORTED_MODULE_4__["default"])(feature, boundsStream); // First, sort ranges by their minimum longitudes.

  if (n = ranges.length) {
    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.

    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];

      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    } // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.


    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;
  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js ***!
  \*****************************************************************************/
/*! exports provided: spherical, cartesian, cartesianDot, cartesianCross, cartesianAddInPlace, cartesianScale, cartesianNormalizeInPlace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spherical", function() { return spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesian", function() { return cartesian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianDot", function() { return cartesianDot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianCross", function() { return cartesianCross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianAddInPlace", function() { return cartesianAddInPlace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianScale", function() { return cartesianScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianNormalizeInPlace", function() { return cartesianNormalizeInPlace; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");

function spherical(cartesian) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(cartesian[1], cartesian[0]), Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(cartesian[2])];
}
function cartesian(spherical) {
  var lambda = spherical[0],
      phi = spherical[1],
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  return [cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda), cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi)];
}
function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
} // TODO return a

function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
} // TODO return d

function cartesianNormalizeInPlace(d) {
  var l = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/centroid.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/centroid.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js");



var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, // first point
x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function polygonStart() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function polygonEnd() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
}; // Arithmetic mean of Cartesian vectors.

function centroidPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  centroidPointCartesian(cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda), cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  x0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda);
  y0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda);
  z0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi),
      x = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda),
      y = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda),
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi),
      w = Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
} // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).


function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  centroidStream.point = centroidRingPoint;
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  x0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda);
  y0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda);
  z0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi),
      x = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda),
      y = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda),
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(cx * cx + cy * cy + cz * cz),
      w = Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(m),
      // line weight = angle
  v = m && -w / m; // area weight multiplier

  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ __webpack_exports__["default"] = (function (object) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
  Object(_stream__WEBPACK_IMPORTED_MODULE_2__["default"])(object, centroidStream);
  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z; // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.

  if (m < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon2"]) {
    x = X1, y = Y1, z = Z1; // If the feature has zero length, fall back to arithmetic mean of point vectors.

    if (W1 < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z; // If the feature still has an undefined ccentroid, then return.

    if (m < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon2"]) return [NaN, NaN];
  }

  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(y, x) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(z / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(m)) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js ***!
  \**************************************************************************/
/*! exports provided: circleStream, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleStream", function() { return circleStream; });
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js");



 // Generates a circle centered at [0°, 0°], with a given radius and precision.

function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(radius),
      sinRadius = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(radius),
      step = direction * delta;

  if (t0 == null) {
    t0 = radius + direction * _math__WEBPACK_IMPORTED_MODULE_2__["tau"];
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math__WEBPACK_IMPORTED_MODULE_2__["tau"];
  }

  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["spherical"])([cosRadius, -sinRadius * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(t), -sinRadius * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(t)]);
    stream.point(point[0], point[1]);
  }
} // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].

function circleRadius(cosRadius, point) {
  point = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(point), point[0] -= cosRadius;
  Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianNormalizeInPlace"])(point);
  var radius = Object(_math__WEBPACK_IMPORTED_MODULE_2__["acos"])(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math__WEBPACK_IMPORTED_MODULE_2__["tau"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) % _math__WEBPACK_IMPORTED_MODULE_2__["tau"];
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var center = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([0, 0]),
      radius = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(90),
      precision = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(6),
      ring,
      rotate,
      stream = {
    point: point
  };

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math__WEBPACK_IMPORTED_MODULE_2__["degrees"], x[1] *= _math__WEBPACK_IMPORTED_MODULE_2__["degrees"];
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math__WEBPACK_IMPORTED_MODULE_2__["radians"],
        p = precision.apply(this, arguments) * _math__WEBPACK_IMPORTED_MODULE_2__["radians"];
    ring = [];
    rotate = Object(_rotation__WEBPACK_IMPORTED_MODULE_3__["rotateRadians"])(-c[0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], -c[1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], 0).invert;
    circleStream(stream, r, p, 1);
    c = {
      type: "Polygon",
      coordinates: [ring]
    };
    ring = rotate = null;
    return c;
  }

  circle.center = function (_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), circle) : radius;
  };

  circle.precision = function (_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), circle) : precision;
  };

  return circle;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_index__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  return true;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]])); // Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.

function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      _clean; // no intersections


  return {
    lineStart: function lineStart() {
      stream.lineStart();
      _clean = 1;
    },
    point: function point(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["pi"],
          delta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda1 - lambda0);

      if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta - _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
        // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        _clean = 0;
      } else if (sign0 !== sign1 && delta >= _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) {
        // line crosses antimeridian
        if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda0 - sign0) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) lambda0 -= sign0 * _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; // handle degeneracies

        if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda1 - sign1) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) lambda1 -= sign1 * _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        _clean = 0;
      }

      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function lineEnd() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function clean() {
      return 2 - _clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda0 - lambda1);
  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(sinLambda0Lambda1) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])((Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0) * (cosPhi1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi1)) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda1) - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi1) * (cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0)) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;

  if (from == null) {
    phi = direction * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"];
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
    stream.point(0, phi);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__["pi"], 0);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__["pi"], -phi);
    stream.point(0, -phi);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], -phi);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], 0);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
  } else if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(from[0] - to[0]) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
    var lambda = from[0] < to[0] ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["pi"];
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var lines = [],
      line;
  return {
    point: function point(x, y) {
      line.push([x, y]);
    },
    lineStart: function lineStart() {
      lines.push(line = []);
    },
    lineEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function rejoin() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function result() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cartesian */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pointEqual */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js");





/* harmony default export */ __webpack_exports__["default"] = (function (radius) {
  var cr = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(radius),
      delta = 6 * _math__WEBPACK_IMPORTED_MODULE_2__["radians"],
      smallRadius = cr > 0,
      notHemisphere = Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(cr) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    Object(_circle__WEBPACK_IMPORTED_MODULE_1__["circleStream"])(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda) * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi) > cr;
  } // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.


  function clipLine(stream) {
    var point0, // previous point
    c0, // code for previous point
    v0, // visibility of previous point
    v00, // visibility of first point
    _clean; // no intersections


    return {
      lineStart: function lineStart() {
        v00 = v0 = false;
        _clean = 1;
      },
      point: function point(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math__WEBPACK_IMPORTED_MODULE_2__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_2__["pi"]), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart(); // Handle degeneracies.
        // TODO ignore if not clipping polygons.

        if (v !== v0) {
          point2 = intersect(point0, point1);

          if (!point2 || Object(_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point0, point2) || Object(_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point1, point2)) {
            point1[0] += _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
            point1[1] += _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
            v = visible(point1[0], point1[1]);
          }
        }

        if (v !== v0) {
          _clean = 0;

          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }

          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t; // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.

          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            _clean = 0;

            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }

        if (v && (!point0 || !Object(_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }

        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function lineEnd() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function clean() {
        return _clean | (v00 && v0) << 1;
      }
    };
  } // Intersects the great circle between a and b with the clip circle.


  function intersect(a, b, two) {
    var pa = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(a),
        pb = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(b); // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).

    var n1 = [1, 0, 0],
        // normal
    n2 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianCross"])(pa, pb),
        n2n2 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(n2, n2),
        n1n2 = n2[0],
        // cartesianDot(n1, n2),
    determinant = n2n2 - n1n2 * n1n2; // Two polar points.

    if (!determinant) return !two && a;
    var c1 = cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianCross"])(n1, n2),
        A = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(n1, c1),
        B = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(n2, c2);
    Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(A, B); // Solve |p(t)|^2 = 1.

    var u = n1xn2,
        w = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(A, u),
        uu = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(u, u),
        t2 = w * w - uu * (Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(A, A) - 1);
    if (t2 < 0) return;
    var t = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(t2),
        q = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(u, (-w - t) / uu);
    Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(q, A);
    q = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["spherical"])(q);
    if (!two) return q; // Two intersection points.

    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta = lambda1 - lambda0,
        polar = Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(delta - _math__WEBPACK_IMPORTED_MODULE_2__["pi"]) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"],
        meridian = polar || delta < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.

    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(q[0] - lambda0) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math__WEBPACK_IMPORTED_MODULE_2__["pi"] ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(u, (-w + t) / uu);
      Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(q1, A);
      return [q, Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["spherical"])(q1)];
    }
  } // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.


  function code(lambda, phi) {
    var r = smallRadius ? radius : _math__WEBPACK_IMPORTED_MODULE_2__["pi"] - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right

    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above

    return code;
  }

  return Object(_index__WEBPACK_IMPORTED_MODULE_4__["default"])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math__WEBPACK_IMPORTED_MODULE_2__["pi"], radius - _math__WEBPACK_IMPORTED_MODULE_2__["pi"]]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/extent.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/extent.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rectangle */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;
  return clip = {
    stream: function stream(_stream) {
      return cache && cacheStream === _stream ? cache : cache = Object(_rectangle__WEBPACK_IMPORTED_MODULE_0__["default"])(x0, y0, x1, y1)(cacheStream = _stream);
    },
    extent: function extent(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _rejoin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rejoin */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../polygonContains */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");





/* harmony default export */ __webpack_exports__["default"] = (function (pointVisible, clipLine, interpolate, start) {
  return function (sink) {
    var line = clipLine(sink),
        ringBuffer = Object(_buffer__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;
    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function polygonStart() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function polygonEnd() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = Object(d3_array__WEBPACK_IMPORTED_MODULE_4__["merge"])(segments);
        var startInside = Object(_polygonContains__WEBPACK_IMPORTED_MODULE_3__["default"])(polygon, start);

        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          Object(_rejoin__WEBPACK_IMPORTED_MODULE_1__["default"])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }

        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function sphere() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i,
          n = ringSegments.length,
          m,
          segment,
          point;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return; // No intersections.

      if (clean & 1) {
        segment = ringSegments[0];

        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();

          for (i = 0; i < m; ++i) {
            sink.point((point = segment[i])[0], point[1]);
          }

          sink.lineEnd();
        }

        return;
      } // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?


      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
});

function validSegment(segment) {
  return segment.length > 1;
} // Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.


function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] : _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - a[1]) - ((b = b.x)[0] < 0 ? b[1] - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] : _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - b[1]);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;
  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;

  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;

  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;

  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;

  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return clipRectangle; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");





var clipMax = 1e9,
    clipMin = -clipMax; // TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {
  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0,
        a1 = 0;

    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do {
        stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      } while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[0] - x0) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 0 : 3 : Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[0] - x1) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 2 : 1 : Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[1] - y0) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
  }

  return function (stream) {
    var activeStream = stream,
        bufferStream = Object(_buffer__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__,
        y__,
        v__,
        // first point
    x_,
        y_,
        v_,
        // previous point
    first,
        clean;
    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];

          if (a1 <= y1) {
            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
          } else {
            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
          }
        }
      }

      return winding;
    } // Buffer geometry within a polygon and then clip it en masse.


    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = Object(d3_array__WEBPACK_IMPORTED_MODULE_4__["merge"])(segments)).length;

      if (cleanInside || visible) {
        stream.polygonStart();

        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }

        if (visible) {
          Object(_rejoin__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }

        stream.polygonEnd();
      }

      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    } // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.


    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }

      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);

      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;

        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];

          if (Object(_line__WEBPACK_IMPORTED_MODULE_2__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }

            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }

      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js");


function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection

  this.e = entry; // is an entry?

  this.v = false; // visited

  this.n = this.p = null; // next & previous
} // A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.


/* harmony default export */ __webpack_exports__["default"] = (function (segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;
  segments.forEach(function (segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n,
        p0 = segment[0],
        p1 = segment[n],
        x; // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.

    if (Object(_pointEqual__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      stream.lineStart();

      for (i = 0; i < n; ++i) {
        stream.point((p0 = segment[i])[0], p0[1]);
      }

      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;

    while (current.v) {
      if ((current = current.n) === start) return;
    }

    points = current.z;
    stream.lineStart();

    do {
      current.v = current.o.v = true;

      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) {
            stream.point((point = points[i])[0], point[1]);
          }
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }

        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;

          for (i = points.length - 1; i >= 0; --i) {
            stream.point((point = points[i])[0], point[1]);
          }
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }

        current = current.p;
      }

      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);

    stream.lineEnd();
  }
});

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;

  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }

  a.n = b = array[0];
  b.p = a;
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function (x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };
  return compose;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/contains.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/contains.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _polygonContains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polygonContains */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var _distance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distance */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/distance.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



var containsObjectType = {
  Feature: function Feature(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function FeatureCollection(object, point) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) {
      if (containsGeometry(features[i].geometry, point)) return true;
    }

    return false;
  }
};
var containsGeometryType = {
  Sphere: function Sphere() {
    return true;
  },
  Point: function Point(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function MultiPoint(object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      if (containsPoint(coordinates[i], point)) return true;
    }

    return false;
  },
  LineString: function LineString(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function MultiLineString(object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      if (containsLine(coordinates[i], point)) return true;
    }

    return false;
  },
  Polygon: function Polygon(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function MultiPolygon(object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      if (containsPolygon(coordinates[i], point)) return true;
    }

    return false;
  },
  GeometryCollection: function GeometryCollection(object, point) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) {
      if (containsGeometry(geometries[i], point)) return true;
    }

    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
}

function containsPoint(coordinates, point) {
  return Object(_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = Object(_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates[0], coordinates[1]),
      ao = Object(_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates[0], point),
      ob = Object(_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(point, coordinates[1]);
  return ao + ob <= ab + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
}

function containsPolygon(coordinates, point) {
  return !!Object(_polygonContains__WEBPACK_IMPORTED_MODULE_0__["default"])(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], point[1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"]];
}

/* harmony default export */ __webpack_exports__["default"] = (function (object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/distance.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/distance.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./length */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/length.js");

var coordinates = [null, null],
    object = {
  type: "LineString",
  coordinates: coordinates
};
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return Object(_length__WEBPACK_IMPORTED_MODULE_0__["default"])(object);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/graticule.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/graticule.js ***!
  \*****************************************************************************/
/*! exports provided: default, graticule10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return graticule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "graticule10", function() { return graticule10; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(y0, y1 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"], dy).concat(y1);
  return function (x) {
    return y.map(function (y) {
      return [x, y];
    });
  };
}

function graticuleY(x0, x1, dx) {
  var x = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(x0, x1 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"], dx).concat(x1);
  return function (y) {
    return x.map(function (x) {
      return [x, y];
    });
  };
}

function graticule() {
  var x1,
      x0,
      X1,
      X0,
      y1,
      y0,
      Y1,
      Y0,
      dx = 10,
      dy = dx,
      DX = 90,
      DY = 360,
      x,
      y,
      X,
      Y,
      precision = 2.5;

  function graticule() {
    return {
      type: "MultiLineString",
      coordinates: lines()
    };
  }

  function lines() {
    return Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(X0 / DX) * DX, X1, DX).map(X).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(Y0 / DY) * DY, Y1, DY).map(Y)).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(x0 / dx) * dx, x1, dx).filter(function (x) {
      return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x % DX) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
    }).map(x)).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(y0 / dy) * dy, y1, dy).filter(function (y) {
      return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y % DY) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
    }).map(y));
  }

  graticule.lines = function () {
    return lines().map(function (coordinates) {
      return {
        type: "LineString",
        coordinates: coordinates
      };
    });
  };

  graticule.outline = function () {
    return {
      type: "Polygon",
      coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
    };
  };

  graticule.extent = function (_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function (_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function (_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function (_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function (_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function (_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function (_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule.extentMajor([[-180, -90 + _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]], [180, 90 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]]]).extentMinor([[-180, -80 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]], [180, 80 + _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]]]);
}
function graticule10() {
  return graticule()();
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/interpolate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/interpolate.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var x0 = a[0] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      y0 = a[1] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      x1 = b[0] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      y1 = b[1] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      cy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      sy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0),
      cy1 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1),
      sy1 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y1),
      kx0 = cy0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x0),
      ky0 = cy0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x0),
      kx1 = cy1 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x1),
      ky1 = cy1 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x1),
      d = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["haversin"])(y1 - y0) + cy0 * cy1 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["haversin"])(x1 - x0))),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(d);
  var interpolate = d ? function (t) {
    var B = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(t *= d) / k,
        A = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(y, x) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(z, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + y * y)) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  } : function () {
    return [x0 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], y0 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  };
  interpolate.distance = d;
  return interpolate;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/length.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/length.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js");




var lengthSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lambda0,
    sinPhi0,
    cosPhi0;
var lengthStream = {
  sphere: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: lengthLineStart,
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"]
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
}

function lengthPointFirst(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  lambda0 = lambda, sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi), cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      delta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda - lambda0),
      cosDelta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(delta),
      sinDelta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + y * y), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}

/* harmony default export */ __webpack_exports__["default"] = (function (object) {
  lengthSum.reset();
  Object(_stream__WEBPACK_IMPORTED_MODULE_3__["default"])(object, lengthStream);
  return +lengthSum;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js ***!
  \************************************************************************/
/*! exports provided: epsilon, epsilon2, pi, halfPi, quarterPi, tau, degrees, radians, abs, atan, atan2, cos, ceil, exp, floor, log, pow, sin, sign, sqrt, tan, acos, asin, haversin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon2", function() { return epsilon2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pi", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPi", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quarterPi", function() { return quarterPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tau", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "haversin", function() { return haversin; });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function (x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}
function haversin(x) {
  return (x = sin(x / 2)) * x;
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return noop; });
function noop() {}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/area.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/area.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");



var areaSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    areaRingSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    x00,
    y00,
    x0,
    y0;
var areaStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: function polygonStart() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function polygonEnd() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
    areaSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(areaRingSum));
    areaRingSum.reset();
  },
  result: function result() {
    var area = areaSum / 2;
    areaSum.reset();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ __webpack_exports__["default"] = (areaStream);

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");

var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function result() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ __webpack_exports__["default"] = (boundsStream);

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/centroid.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/centroid.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
 // TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function polygonStart() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function polygonEnd() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function result() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ __webpack_exports__["default"] = (centroidStream);

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/context.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/context.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathContext; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");


function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function pointRadius(_) {
    return this._radius = _, this;
  },
  polygonStart: function polygonStart() {
    this._line = 0;
  },
  polygonEnd: function polygonEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function point(x, y) {
    switch (this._point) {
      case 0:
        {
          this._context.moveTo(x, y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._context.lineTo(x, y);

          break;
        }

      default:
        {
          this._context.moveTo(x + this._radius, y);

          this._context.arc(x, y, this._radius, 0, _math__WEBPACK_IMPORTED_MODULE_0__["tau"]);

          break;
        }
    }
  },
  result: _noop__WEBPACK_IMPORTED_MODULE_1__["default"]
};

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/index.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stream */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./area */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _measure__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./measure */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/measure.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./string */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/string.js");








/* harmony default export */ __webpack_exports__["default"] = (function (projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(contextStream));
    }

    return contextStream.result();
  }

  path.area = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_area__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return _area__WEBPACK_IMPORTED_MODULE_2__["default"].result();
  };

  path.measure = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_measure__WEBPACK_IMPORTED_MODULE_6__["default"]));
    return _measure__WEBPACK_IMPORTED_MODULE_6__["default"].result();
  };

  path.bounds = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_bounds__WEBPACK_IMPORTED_MODULE_3__["default"]));
    return _bounds__WEBPACK_IMPORTED_MODULE_3__["default"].result();
  };

  path.centroid = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_centroid__WEBPACK_IMPORTED_MODULE_4__["default"]));
    return _centroid__WEBPACK_IMPORTED_MODULE_4__["default"].result();
  };

  path.projection = function (_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity__WEBPACK_IMPORTED_MODULE_0__["default"]) : (projection = _).stream, path) : projection;
  };

  path.context = function (_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string__WEBPACK_IMPORTED_MODULE_7__["default"]()) : new _context__WEBPACK_IMPORTED_MODULE_5__["default"](context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function (_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/measure.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/measure.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");



var lengthSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;
var lengthStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: function lineStart() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function lineEnd() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
  },
  polygonStart: function polygonStart() {
    lengthRing = true;
  },
  polygonEnd: function polygonEnd() {
    lengthRing = null;
  },
  result: function result() {
    var length = +lengthSum;
    lengthSum.reset();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ __webpack_exports__["default"] = (lengthStream);

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/string.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/string.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathString; });
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function pointRadius(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function polygonStart() {
    this._line = 0;
  },
  polygonEnd: function polygonEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function point(x, y) {
    switch (this._point) {
      case 0:
        {
          this._string.push("M", x, ",", y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._string.push("L", x, ",", y);

          break;
        }

      default:
        {
          if (this._circle == null) this._circle = circle(this._radius);

          this._string.push("M", x, ",", y, this._circle);

          break;
        }
    }
  },
  result: function result() {
    if (this._string.length) {
      var result = this._string.join("");

      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(a[0] - b[0]) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] && Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(a[1] - b[1]) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"];
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/adder.js");
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



var sum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])();
/* harmony default export */ __webpack_exports__["default"] = (function (polygon, point) {
  var lambda = point[0],
      phi = point[1],
      sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi),
      normal = [Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(lambda), -Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda), 0],
      angle = 0,
      winding = 0;
  sum.reset();
  if (sinPhi === 1) phi = _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];else if (sinPhi === -1) phi = -_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + _math__WEBPACK_IMPORTED_MODULE_2__["quarterPi"],
        sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi0),
        cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + _math__WEBPACK_IMPORTED_MODULE_2__["quarterPi"],
          sinPhi1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi1),
          cosPhi1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math__WEBPACK_IMPORTED_MODULE_2__["pi"],
          k = sinPhi0 * sinPhi1;
      sum.add(Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(k * sign * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(absDelta), cosPhi0 * cosPhi1 + k * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(absDelta)));
      angle += antimeridian ? delta + sign * _math__WEBPACK_IMPORTED_MODULE_2__["tau"] : delta; // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?

      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianCross"])(Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesian"])(point0), Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesian"])(point1));
        Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianNormalizeInPlace"])(arc);
        var intersection = Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianCross"])(normal, arc);
        Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianNormalizeInPlace"])(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * Object(_math__WEBPACK_IMPORTED_MODULE_2__["asin"])(intersection[2]);

        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  } // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.


  return (angle < -_math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] || angle < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] && sum < -_math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) ^ winding & 1;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albers.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albers.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _conicEqualArea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./conicEqualArea */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEqualArea.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conicEqualArea__WEBPACK_IMPORTED_MODULE_0__["default"])().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albersUsa.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albersUsa.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _albers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./albers */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var _conicEqualArea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conicEqualArea */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js");



 // The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.

function multiplex(streams) {
  var n = streams.length;
  return {
    point: function point(x, y) {
      var i = -1;

      while (++i < n) {
        streams[i].point(x, y);
      }
    },
    sphere: function sphere() {
      var i = -1;

      while (++i < n) {
        streams[i].sphere();
      }
    },
    lineStart: function lineStart() {
      var i = -1;

      while (++i < n) {
        streams[i].lineStart();
      }
    },
    lineEnd: function lineEnd() {
      var i = -1;

      while (++i < n) {
        streams[i].lineEnd();
      }
    },
    polygonStart: function polygonStart() {
      var i = -1;

      while (++i < n) {
        streams[i].polygonStart();
      }
    },
    polygonEnd: function polygonEnd() {
      var i = -1;

      while (++i < n) {
        streams[i].polygonEnd();
      }
    }
  };
} // A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers


/* harmony default export */ __webpack_exports__["default"] = (function () {
  var cache,
      cacheStream,
      lower48 = Object(_albers__WEBPACK_IMPORTED_MODULE_1__["default"])(),
      lower48Point,
      alaska = Object(_conicEqualArea__WEBPACK_IMPORTED_MODULE_2__["default"])().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
      alaskaPoint,
      // EPSG:3338
  hawaii = Object(_conicEqualArea__WEBPACK_IMPORTED_MODULE_2__["default"])().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
      hawaiiPoint,
      // ESRI:102007
  _point,
      pointStream = {
    point: function point(x, y) {
      _point = [x, y];
    }
  };

  function albersUsa(coordinates) {
    var x = coordinates[0],
        y = coordinates[1];
    return _point = null, (lower48Point.point(x, y), _point) || (alaskaPoint.point(x, y), _point) || (hawaiiPoint.point(x, y), _point);
  }

  albersUsa.invert = function (coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
  };

  albersUsa.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function (_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function (_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function (_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(),
        x = +_[0],
        y = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
    alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.120 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]], [x - 0.214 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.234 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.166 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]], [x - 0.115 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.234 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]]]).stream(pointStream);
    return reset();
  };

  albersUsa.fitExtent = function (extent, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitExtent"])(albersUsa, extent, object);
  };

  albersUsa.fitSize = function (size, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitSize"])(albersUsa, size, object);
  };

  albersUsa.fitWidth = function (width, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitWidth"])(albersUsa, width, object);
  };

  albersUsa.fitHeight = function (height, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitHeight"])(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthal.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthal.js ***!
  \****************************************************************************************/
/*! exports provided: azimuthalRaw, azimuthalInvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalRaw", function() { return azimuthalRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalInvert", function() { return azimuthalInvert; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");

function azimuthalRaw(scale) {
  return function (x, y) {
    var cx = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x),
        cy = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y),
        k = scale(cx * cy);
    return [k * cy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x), k * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)];
  };
}
function azimuthalInvert(angle) {
  return function (x, y) {
    var z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + y * y),
        c = angle(z),
        sc = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(c),
        cc = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(c);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x * sc, z * cc), Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(z && y * sc / z)];
  };
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthalEqualArea.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthalEqualArea.js ***!
  \*************************************************************************************************/
/*! exports provided: azimuthalEqualAreaRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalEqualAreaRaw", function() { return azimuthalEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");



var azimuthalEqualAreaRaw = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalRaw"])(function (cxcy) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function (z) {
  return 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(z / 2);
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthalEquidistant.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthalEquidistant.js ***!
  \***************************************************************************************************/
/*! exports provided: azimuthalEquidistantRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalEquidistantRaw", function() { return azimuthalEquidistantRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");



var azimuthalEquidistantRaw = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalRaw"])(function (c) {
  return (c = Object(_math__WEBPACK_IMPORTED_MODULE_0__["acos"])(c)) && c / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(c);
});
azimuthalEquidistantRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function (z) {
  return z;
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conic.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conic.js ***!
  \************************************************************************************/
/*! exports provided: conicProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicProjection", function() { return conicProjection; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");


function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = _math__WEBPACK_IMPORTED_MODULE_0__["pi"] / 3,
      m = Object(_index__WEBPACK_IMPORTED_MODULE_1__["projectionMutator"])(projectAt),
      p = m(phi0, phi1);

  p.parallels = function (_) {
    return arguments.length ? m(phi0 = _[0] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi1 = _[1] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"]) : [phi0 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], phi1 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  };

  return p;
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicConformal.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicConformal.js ***!
  \*********************************************************************************************/
/*! exports provided: conicConformalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicConformalRaw", function() { return conicConformalRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _mercator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mercator */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/mercator.js");




function tany(y) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      n = y0 === y1 ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0) : Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(cy0 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1)) / Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(tany(y1) / tany(y0)),
      f = cy0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(tany(y0), n) / n;
  if (!n) return _mercator__WEBPACK_IMPORTED_MODULE_2__["mercatorRaw"];

  function project(x, y) {
    if (f > 0) {
      if (y < -_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) y = -_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"];
    } else {
      if (y > _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) y = _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"];
    }

    var r = f / Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(tany(y), n);
    return [r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(n * x), f - r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(n * x)];
  }

  project.invert = function (x, y) {
    var fy = f - y,
        r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(n) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + fy * fy);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(fy)) / n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(fy), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(f / r, 1 / n)) - _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
  };

  return project;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conic__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicConformalRaw).scale(109.5).parallels([30, 30]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEqualArea.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEqualArea.js ***!
  \*********************************************************************************************/
/*! exports provided: conicEqualAreaRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicEqualAreaRaw", function() { return conicEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cylindricalEqualArea */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/cylindricalEqualArea.js");



function conicEqualAreaRaw(y0, y1) {
  var sy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0),
      n = (sy0 + Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y1)) / 2; // Are the parallels symmetrical around the Equator?

  if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(n) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) return Object(_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_2__["cylindricalEqualAreaRaw"])(y0);
  var c = 1 + sy0 * (2 * n - sy0),
      r0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(c) / n;

  function project(x, y) {
    var r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(c - 2 * n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)) / n;
    return [r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x *= n), r0 - r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x)];
  }

  project.invert = function (x, y) {
    var r0y = r0 - y;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(r0y)) / n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(r0y), Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conic__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEquidistant.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEquidistant.js ***!
  \***********************************************************************************************/
/*! exports provided: conicEquidistantRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicEquidistantRaw", function() { return conicEquidistantRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _equirectangular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equirectangular */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/equirectangular.js");



function conicEquidistantRaw(y0, y1) {
  var cy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      n = y0 === y1 ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0) : (cy0 - Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1)) / (y1 - y0),
      g = cy0 / n + y0;
  if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(n) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) return _equirectangular__WEBPACK_IMPORTED_MODULE_2__["equirectangularRaw"];

  function project(x, y) {
    var gy = g - y,
        nx = n * x;
    return [gy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(nx), g - gy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(nx)];
  }

  project.invert = function (x, y) {
    var gy = g - y;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(gy)) / n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(gy), g - Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(n) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + gy * gy)];
  };

  return project;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conic__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/cylindricalEqualArea.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/cylindricalEqualArea.js ***!
  \***************************************************************************************************/
/*! exports provided: cylindricalEqualAreaRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cylindricalEqualAreaRaw", function() { return cylindricalEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi) / cosPhi0];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(y * cosPhi0)];
  };

  return forward;
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/equirectangular.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/equirectangular.js ***!
  \**********************************************************************************************/
/*! exports provided: equirectangularRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equirectangularRaw", function() { return equirectangularRaw; });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_0__["default"])(equirectangularRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js ***!
  \**********************************************************************************/
/*! exports provided: fitExtent, fitSize, fitWidth, fitHeight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitExtent", function() { return fitExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitSize", function() { return fitSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitWidth", function() { return fitWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitHeight", function() { return fitHeight; });
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  Object(_stream__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds__WEBPACK_IMPORTED_MODULE_1__["default"]));
  fitBounds(_path_bounds__WEBPACK_IMPORTED_MODULE_1__["default"].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function (b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}
function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}
function fitWidth(projection, width, object) {
  return fit(projection, function (b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}
function fitHeight(projection, height, object) {
  return fit(projection, function (b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/gnomonic.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/gnomonic.js ***!
  \***************************************************************************************/
/*! exports provided: gnomonicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gnomonicRaw", function() { return gnomonicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");



function gnomonicRaw(x, y) {
  var cy = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x) * cy;
  return [cy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x) / k, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y) / k];
}
gnomonicRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(_math__WEBPACK_IMPORTED_MODULE_0__["atan"]);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(gnomonicRaw).scale(144.049).clipAngle(60);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/identity.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/identity.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _clip_rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clip/rectangle */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js");





function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? _identity__WEBPACK_IMPORTED_MODULE_1__["default"] : Object(_transform__WEBPACK_IMPORTED_MODULE_2__["transformer"])({
    point: function point(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var k = 1,
      tx = 0,
      ty = 0,
      sx = 1,
      sy = 1,
      transform = _identity__WEBPACK_IMPORTED_MODULE_1__["default"],
      // scale, translate and reflect
  x0 = null,
      y0,
      x1,
      y1,
      // clip extent
  _postclip = _identity__WEBPACK_IMPORTED_MODULE_1__["default"],
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function stream(_stream) {
      return cache && cacheStream === _stream ? cache : cache = transform(_postclip(cacheStream = _stream));
    },
    postclip: function postclip(_) {
      return arguments.length ? (_postclip = _, x0 = y0 = x1 = y1 = null, reset()) : _postclip;
    },
    clipExtent: function clipExtent(_) {
      return arguments.length ? (_postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity__WEBPACK_IMPORTED_MODULE_1__["default"]) : Object(_clip_rectangle__WEBPACK_IMPORTED_MODULE_0__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function scale(_) {
      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function translate(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function reflectX(_) {
      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function reflectY(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function fitExtent(extent, object) {
      return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitExtent"])(projection, extent, object);
    },
    fitSize: function fitSize(size, object) {
      return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitSize"])(projection, size, object);
    },
    fitWidth: function fitWidth(width, object) {
      return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitWidth"])(projection, width, object);
    },
    fitHeight: function fitHeight(height, object) {
      return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitHeight"])(projection, height, object);
    }
  };
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js ***!
  \************************************************************************************/
/*! exports provided: default, projectionMutator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectionMutator", function() { return projectionMutator; });
/* harmony import */ var _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clip/antimeridian */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../clip/circle */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/rectangle */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../compose */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rotation */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./resample */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js");










var transformRadians = Object(_transform__WEBPACK_IMPORTED_MODULE_7__["transformer"])({
  point: function point(x, y) {
    this.stream.point(x * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], y * _math__WEBPACK_IMPORTED_MODULE_5__["radians"]);
  }
});

function transformRotate(rotate) {
  return Object(_transform__WEBPACK_IMPORTED_MODULE_7__["transformer"])({
    point: function point(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy) {
  function transform(x, y) {
    return [dx + k * x, dy - k * y];
  }

  transform.invert = function (x, y) {
    return [(x - dx) / k, (dy - y) / k];
  };

  return transform;
}

function scaleTranslateRotate(k, dx, dy, alpha) {
  var cosAlpha = Object(_math__WEBPACK_IMPORTED_MODULE_5__["cos"])(alpha),
      sinAlpha = Object(_math__WEBPACK_IMPORTED_MODULE_5__["sin"])(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;

  function transform(x, y) {
    return [a * x - b * y + dx, dy - b * x - a * y];
  }

  transform.invert = function (x, y) {
    return [ai * x - bi * y + ci, fi - bi * x - ai * y];
  };

  return transform;
}

function projection(project) {
  return projectionMutator(function () {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project,
      k = 150,
      // scale
  x = 480,
      y = 250,
      // translate
  lambda = 0,
      phi = 0,
      // center
  deltaLambda = 0,
      deltaPhi = 0,
      deltaGamma = 0,
      rotate,
      // pre-rotate
  alpha = 0,
      // post-rotate
  theta = null,
      preclip = _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__["default"],
      // pre-clip angle
  x0 = null,
      y0,
      x1,
      y1,
      postclip = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      // post-clip extent
  delta2 = 0.5,
      // precision
  projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], point[1] * _math__WEBPACK_IMPORTED_MODULE_5__["radians"]);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], point[1] * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  }

  projection.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function (_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function (_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function (_) {
    return arguments.length ? (preclip = +_ ? Object(_clip_circle__WEBPACK_IMPORTED_MODULE_1__["default"])(theta = _ * _math__WEBPACK_IMPORTED_MODULE_5__["radians"]) : (theta = null, _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__["default"]), reset()) : theta * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"];
  };

  projection.clipExtent = function (_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity__WEBPACK_IMPORTED_MODULE_4__["default"]) : Object(_clip_rectangle__WEBPACK_IMPORTED_MODULE_2__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function (_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function (_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function (_) {
    return arguments.length ? (lambda = _[0] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], phi = _[1] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], recenter()) : [lambda * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], phi * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  };

  projection.rotate = function (_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], deltaPhi = _[1] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], deltaGamma = _.length > 2 ? _[2] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"] : 0, recenter()) : [deltaLambda * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], deltaPhi * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], deltaGamma * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  };

  projection.angle = function (_) {
    return arguments.length ? (alpha = _ % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], recenter()) : alpha * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"];
  };

  projection.precision = function (_) {
    return arguments.length ? (projectResample = Object(_resample__WEBPACK_IMPORTED_MODULE_9__["default"])(projectTransform, delta2 = _ * _), reset()) : Object(_math__WEBPACK_IMPORTED_MODULE_5__["sqrt"])(delta2);
  };

  projection.fitExtent = function (extent, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_8__["fitExtent"])(projection, extent, object);
  };

  projection.fitSize = function (size, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_8__["fitSize"])(projection, size, object);
  };

  projection.fitWidth = function (width, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_8__["fitWidth"])(projection, width, object);
  };

  projection.fitHeight = function (height, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_8__["fitHeight"])(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),
        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
    rotate = Object(_rotation__WEBPACK_IMPORTED_MODULE_6__["rotateRadians"])(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = Object(_compose__WEBPACK_IMPORTED_MODULE_3__["default"])(project, transform);
    projectRotateTransform = Object(_compose__WEBPACK_IMPORTED_MODULE_3__["default"])(rotate, projectTransform);
    projectResample = Object(_resample__WEBPACK_IMPORTED_MODULE_9__["default"])(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function () {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/mercator.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/mercator.js ***!
  \***************************************************************************************/
/*! exports provided: mercatorRaw, default, mercatorProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercatorRaw", function() { return mercatorRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercatorProjection", function() { return mercatorProjection; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rotation */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");



function mercatorRaw(lambda, phi) {
  return [lambda, Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + phi) / 2))];
}

mercatorRaw.invert = function (x, y) {
  return [x, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["exp"])(y)) - _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return mercatorProjection(mercatorRaw).scale(961 / _math__WEBPACK_IMPORTED_MODULE_0__["tau"]);
});
function mercatorProjection(project) {
  var m = Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null,
      y0,
      x1,
      y1; // clip extent

  m.scale = function (_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function (_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function (_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function (_) {
    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = _math__WEBPACK_IMPORTED_MODULE_0__["pi"] * scale(),
        t = m(Object(_rotation__WEBPACK_IMPORTED_MODULE_1__["default"])(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/naturalEarth1.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/naturalEarth1.js ***!
  \********************************************************************************************/
/*! exports provided: naturalEarth1Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "naturalEarth1Raw", function() { return naturalEarth1Raw; });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");


function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi,
      phi4 = phi2 * phi2;
  return [lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))), phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))];
}

naturalEarth1Raw.invert = function (x, y) {
  var phi = y,
      i = 25,
      delta;

  do {
    var phi2 = phi * phi,
        phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  return [x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_0__["default"])(naturalEarth1Raw).scale(175.295);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/orthographic.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/orthographic.js ***!
  \*******************************************************************************************/
/*! exports provided: orthographicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orthographicRaw", function() { return orthographicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");



function orthographicRaw(x, y) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)];
}
orthographicRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(_math__WEBPACK_IMPORTED_MODULE_0__["asin"]);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(orthographicRaw).scale(249.5).clipAngle(90 + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cartesian */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js");



var maxDepth = 16,
    // maximum depth of subdivision
cosMinDistance = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(30 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]); // cos(minimum angular distance)

/* harmony default export */ __webpack_exports__["default"] = (function (project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
});

function resampleNone(project) {
  return Object(_transform__WEBPACK_IMPORTED_MODULE_2__["transformer"])({
    point: function point(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {
  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;

    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a * a + b * b + c * c),
          phi2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(c /= m),
          lambda2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(c) - 1) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda0 - lambda1) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? (lambda0 + lambda1) / 2 : Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;

      if (dz * dz / d2 > delta2 // perpendicular projected distance
      || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
      || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }

  return function (stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
    lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function polygonStart() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function polygonEnd() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])([lambda, phi]),
          p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/stereographic.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/stereographic.js ***!
  \********************************************************************************************/
/*! exports provided: stereographicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stereographicRaw", function() { return stereographicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");



function stereographicRaw(x, y) {
  var cy = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y),
      k = 1 + Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x) * cy;
  return [cy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x) / k, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y) / k];
}
stereographicRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function (z) {
  return 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(z);
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(stereographicRaw).scale(250).clipAngle(142);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/transverseMercator.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/transverseMercator.js ***!
  \*************************************************************************************************/
/*! exports provided: transverseMercatorRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transverseMercatorRaw", function() { return transverseMercatorRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/mercator.js");


function transverseMercatorRaw(lambda, phi) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function (x, y) {
  return [-y, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["exp"])(x)) - _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var m = Object(_mercator__WEBPACK_IMPORTED_MODULE_1__["mercatorProjection"])(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function (_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function (_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90]).scale(159.155);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js ***!
  \****************************************************************************/
/*! exports provided: rotateRadians, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateRadians", function() { return rotateRadians; });
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compose */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda - _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda < -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda + _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math__WEBPACK_IMPORTED_MODULE_1__["tau"]) ? deltaPhi || deltaGamma ? Object(_compose__WEBPACK_IMPORTED_MODULE_0__["default"])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}

function forwardRotationLambda(deltaLambda) {
  return function (lambda, phi) {
    return lambda += deltaLambda, [lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda - _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda < -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda + _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(deltaPhi),
      sinDeltaPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(deltaPhi),
      cosDeltaGamma = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(deltaGamma),
      sinDeltaGamma = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
        y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(k * cosDeltaGamma + y * sinDeltaGamma)];
  }

  rotation.invert = function (lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
        y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(k * cosDeltaPhi - x * sinDeltaPhi)];
  };

  return rotation;
}

/* harmony default export */ __webpack_exports__["default"] = (function (rotate) {
  rotate = rotateRadians(rotate[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], rotate[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], rotate.length > 2 ? rotate[2] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"] : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
    return coordinates[0] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates[1] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates;
  }

  forward.invert = function (coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
    return coordinates[0] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates[1] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates;
  };

  return forward;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function Feature(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function FeatureCollection(object, stream) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) {
      streamGeometry(features[i].geometry, stream);
    }
  }
};
var streamGeometryType = {
  Sphere: function Sphere(object, stream) {
    stream.sphere();
  },
  Point: function Point(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function MultiPoint(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      object = coordinates[i], stream.point(object[0], object[1], object[2]);
    }
  },
  LineString: function LineString(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function MultiLineString(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      streamLine(coordinates[i], stream, 0);
    }
  },
  Polygon: function Polygon(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function MultiPolygon(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      streamPolygon(coordinates[i], stream);
    }
  },
  GeometryCollection: function GeometryCollection(object, stream) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) {
      streamGeometry(geometries[i], stream);
    }
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1,
      n = coordinates.length - closed,
      coordinate;
  stream.lineStart();

  while (++i < n) {
    coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  }

  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1,
      n = coordinates.length;
  stream.polygonStart();

  while (++i < n) {
    streamLine(coordinates[i], stream, 1);
  }

  stream.polygonEnd();
}

/* harmony default export */ __webpack_exports__["default"] = (function (object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js ***!
  \*****************************************************************************/
/*! exports provided: default, transformer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformer", function() { return transformer; });
/* harmony default export */ __webpack_exports__["default"] = (function (methods) {
  return {
    stream: transformer(methods)
  };
});
function transformer(methods) {
  return function (stream) {
    var s = new TransformStream();

    for (var key in methods) {
      s[key] = methods[key];
    }

    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function point(x, y) {
    this.stream.point(x, y);
  },
  sphere: function sphere() {
    this.stream.sphere();
  },
  lineStart: function lineStart() {
    this.stream.lineStart();
  },
  lineEnd: function lineEnd() {
    this.stream.lineEnd();
  },
  polygonStart: function polygonStart() {
    this.stream.polygonStart();
  },
  polygonEnd: function polygonEnd() {
    this.stream.polygonEnd();
  }
};

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/airy.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/airy.js ***!
  \****************************************************/
/*! exports provided: airyRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "airyRaw", function() { return airyRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function airyRaw(beta) {
  var tanBeta_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(beta / 2),
      b = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(beta / 2)) / (tanBeta_2 * tanBeta_2);

  function forward(x, y) {
    var cosx = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(x),
        cosy = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y),
        siny = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(y),
        cosz = cosy * cosx,
        k = -((1 - cosz ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])((1 + cosz) / 2) / (1 - cosz) : -0.5) + b / (1 + cosz));
    return [k * cosy * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x), k * siny];
  }

  forward.invert = function (x, y) {
    var r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + y * y),
        z = -beta / 2,
        i = 50,
        delta;
    if (!r) return [0, 0];

    do {
      var z_2 = z / 2,
          cosz_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(z_2),
          sinz_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(z_2),
          tanz_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(z_2),
          lnsecz_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(1 / cosz_2);
      z -= delta = (2 / tanz_2 * lnsecz_2 - b * tanz_2 - r) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - b / (2 * cosz_2 * cosz_2));
    } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

    var sinz = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(z);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x * sinz, r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(z)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y * sinz / r)];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var beta = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(airyRaw),
      p = m(beta);

  p.radius = function (_) {
    return arguments.length ? m(beta = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]) : beta * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
  };

  return p.scale(179.976).clipAngle(147);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/aitoff.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/aitoff.js ***!
  \******************************************************/
/*! exports provided: aitoffRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "aitoffRaw", function() { return aitoffRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function aitoffRaw(x, y) {
  var cosy = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y),
      sincia = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sinci"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(cosy * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(x /= 2)));
  return [2 * cosy * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x) * sincia, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(y) * sincia];
} // Abort if [x, y] is not within an ellipse centered at [0, 0] with
// semi-major axis pi and semi-minor axis pi/2.

aitoffRaw.invert = function (x, y) {
  if (x * x + 4 * y * y > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] + _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return;
  var x1 = x,
      y1 = y,
      i = 25;

  do {
    var sinx = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x1),
        sinx_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x1 / 2),
        cosx_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(x1 / 2),
        siny = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(y1),
        cosy = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y1),
        sin_2y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * y1),
        sin2y = siny * siny,
        cos2y = cosy * cosy,
        sin2x_2 = sinx_2 * sinx_2,
        c = 1 - cos2y * cosx_2 * cosx_2,
        e = c ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(cosy * cosx_2) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(f = 1 / c) : f = 0,
        f,
        fx = 2 * e * cosy * sinx_2 - x,
        fy = e * siny - y,
        dxdx = f * (cos2y * sin2x_2 + e * cosy * cosx_2 * sin2y),
        dxdy = f * (0.5 * sinx * sin_2y - e * 2 * siny * sinx_2),
        dydx = f * 0.25 * (sin_2y * sinx_2 - e * siny * cos2y * sinx),
        dydy = f * (sin2y * cosx_2 + e * sin2x_2 * cosy),
        z = dxdy * dydx - dydy * dxdx;
    if (!z) break;
    var dx = (fy * dxdy - fx * dydy) / z,
        dy = (fx * dydx - fy * dxdx) / z;
    x1 -= dx, y1 -= dy;
  } while ((Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dx) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dy) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) && --i > 0);

  return [x1, y1];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(aitoffRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/armadillo.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/armadillo.js ***!
  \*********************************************************/
/*! exports provided: armadilloRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "armadilloRaw", function() { return armadilloRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function armadilloRaw(phi0) {
  var sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0),
      cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0),
      sPhi0 = phi0 >= 0 ? 1 : -1,
      tanPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(sPhi0 * phi0),
      k = (1 + sinPhi0 - cosPhi0) / 2;

  function forward(lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        cosLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda /= 2);
    return [(1 + cosPhi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), (sPhi0 * phi > -Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda // TODO D3 core should allow null or [NaN, NaN] to be returned.
    ];
  }

  forward.invert = function (x, y) {
    var lambda = 0,
        phi = 0,
        i = 50;

    do {
      var cosLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda),
          sinLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda),
          cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
          sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
          A = 1 + cosPhi,
          fx = A * sinLambda - x,
          fy = k + sinPhi * cosPhi0 - A * sinPhi0 * cosLambda - y,
          dxdLambda = A * cosLambda / 2,
          dxdPhi = -sinLambda * sinPhi,
          dydLambda = sinPhi0 * A * sinLambda / 2,
          dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi,
          denominator = dxdPhi * dydLambda - dydPhi * dxdLambda,
          dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2,
          dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;
      lambda -= dLambda, phi -= dPhi;
    } while ((Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dLambda) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dPhi) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) && --i > 0);

    return sPhi0 * phi > -Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi] : null;
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var phi0 = 20 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"],
      sPhi0 = phi0 >= 0 ? 1 : -1,
      tanPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(sPhi0 * phi0),
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(armadilloRaw),
      p = m(phi0),
      stream_ = p.stream;

  p.parallel = function (_) {
    if (!arguments.length) return phi0 * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
    tanPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])((sPhi0 = (phi0 = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]) >= 0 ? 1 : -1) * phi0);
    return m(phi0);
  };

  p.stream = function (stream) {
    var rotate = p.rotate(),
        rotateStream = stream_(stream),
        sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);

    rotateStream.sphere = function () {
      sphereStream.polygonStart(), sphereStream.lineStart();

      for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90) {
        sphereStream.point(lambda, sPhi0 * 90);
      }

      while (sPhi0 * (lambda -= phi0) >= -180) {
        // TODO precision?
        sphereStream.point(lambda, sPhi0 * -Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda * _math__WEBPACK_IMPORTED_MODULE_1__["radians"] / 2), tanPhi0) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);
      }

      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };

    return rotateStream;
  };

  return p.scale(218.695).center([0, 28.0974]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/august.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/august.js ***!
  \******************************************************/
/*! exports provided: augustRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "augustRaw", function() { return augustRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function augustRaw(lambda, phi) {
  var tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi / 2),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - tanPhi * tanPhi),
      c = 1 + k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda /= 2),
      x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * k / c,
      y = tanPhi / c,
      x2 = x * x,
      y2 = y * y;
  return [4 / 3 * x * (3 + x2 - 3 * y2), 4 / 3 * y * (3 + 3 * x2 - y2)];
}

augustRaw.invert = function (x, y) {
  x *= 3 / 8, y *= 3 / 8;
  if (!x && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) > 1) return null;
  var x2 = x * x,
      y2 = y * y,
      s = 1 + x2 + y2,
      sin3Eta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])((s - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(s * s - 4 * y * y)) / 2),
      eta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sin3Eta) / 3,
      xi = sin3Eta ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["arcosh"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y / sin3Eta)) / 3 : Object(_math__WEBPACK_IMPORTED_MODULE_1__["arsinh"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x)) / 3,
      cosEta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(eta),
      coshXi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cosh"])(xi),
      d = coshXi * coshXi - cosEta * cosEta;
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sinh"])(xi) * cosEta, 0.25 - d), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(coshXi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(eta), 0.25 + d)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(augustRaw).scale(66.1603);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/baker.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/baker.js ***!
  \*****************************************************/
/*! exports provided: bakerRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bakerRaw", function() { return bakerRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var sqrt8 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(8),
    phi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(1 + _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"]);
function bakerRaw(lambda, phi) {
  var phi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi);
  return phi0 < _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] ? [lambda, Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(_math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] + phi / 2))] : [lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0) * (2 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"] - 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * (2 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"] * (phi0 - _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]) - Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi0 / 2)))];
}

bakerRaw.invert = function (x, y) {
  if ((y0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y)) < phi0) return [x, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["exp"])(y)) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]];
  var phi = _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"],
      i = 25,
      delta,
      y0;

  do {
    var cosPhi_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi / 2),
        tanPhi_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi / 2);
    phi -= delta = (sqrt8 * (phi - _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]) - Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(tanPhi_2) - y0) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] && --i > 0);

  return [x / (Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * (sqrt8 - 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi))), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(bakerRaw).scale(112.314);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/berghaus.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/berghaus.js ***!
  \********************************************************/
/*! exports provided: berghausRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "berghausRaw", function() { return berghausRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function berghausRaw(lobes) {
  var k = 2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lobes;

  function forward(lambda, phi) {
    var p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEquidistantRaw"])(lambda, phi);

    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) > _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) {
      // back hemisphere
      var theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(p[1], p[0]),
          r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(p[0] * p[0] + p[1] * p[1]),
          theta0 = k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["round"])((theta - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) / k) + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
          alpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta -= theta0), 2 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta)); // angle relative to lobe end

      theta = theta0 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(alpha)) - alpha;
      p[0] = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta);
      p[1] = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta);
    }

    return p;
  }

  forward.invert = function (x, y) {
    var r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + y * y);

    if (r > _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) {
      var theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y, x),
          theta0 = k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["round"])((theta - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) / k) + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
          s = theta > theta0 ? -1 : 1,
          A = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta0 - theta),
          cotAlpha = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(s * Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])((A - _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] - 2 * A) + r * r)));
      theta = theta0 + 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])((cotAlpha + s * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(cotAlpha * cotAlpha - 3)) / 3);
      x = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta), y = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta);
    }

    return d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEquidistantRaw"].invert(x, y);
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var lobes = 5,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(berghausRaw),
      p = m(lobes),
      projectionStream = p.stream,
      epsilon = 1e-2,
      cr = -Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(epsilon * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]),
      sr = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(epsilon * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);

  p.lobes = function (_) {
    return arguments.length ? m(lobes = +_) : lobes;
  };

  p.stream = function (stream) {
    var rotate = p.rotate(),
        rotateStream = projectionStream(stream),
        sphereStream = (p.rotate([0, 0]), projectionStream(stream));
    p.rotate(rotate);

    rotateStream.sphere = function () {
      sphereStream.polygonStart(), sphereStream.lineStart();

      for (var i = 0, delta = 360 / lobes, delta0 = 2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lobes, phi = 90 - 180 / lobes, phi0 = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]; i < lobes; ++i, phi -= delta, phi0 -= delta0) {
        sphereStream.point(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(sr * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0), cr) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sr * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0)) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);

        if (phi < -90) {
          sphereStream.point(-90, -180 - phi - epsilon);
          sphereStream.point(-90, -180 - phi + epsilon);
        } else {
          sphereStream.point(90, phi + epsilon);
          sphereStream.point(90, phi - epsilon);
        }
      }

      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };

    return rotateStream;
  };

  return p.scale(87.8076).center([0, 17.1875]).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/bertin.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/bertin.js ***!
  \******************************************************/
/*! exports provided: bertin1953Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bertin1953Raw", function() { return bertin1953Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _hammer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hammer */ "./node_modules/d3-geo-projection/src/hammer.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


 // Bertin 1953 as a modified Briesemeister
// https://bl.ocks.org/Fil/5b9ee9636dfb6ffa53443c9006beb642

function bertin1953Raw() {
  var hammer = Object(_hammer__WEBPACK_IMPORTED_MODULE_1__["hammerRaw"])(1.68, 2),
      fu = 1.4,
      k = 12;
  return function (lambda, phi) {
    if (lambda + phi < -fu) {
      var u = (lambda - phi + 1.6) * (lambda + phi + fu) / 8;
      lambda += u;
      phi -= 0.8 * u * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi + _math__WEBPACK_IMPORTED_MODULE_2__["pi"] / 2);
    }

    var r = hammer(lambda, phi);
    var d = (1 - Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda * phi)) / k;

    if (r[1] < 0) {
      r[0] *= 1 + d;
    }

    if (r[1] > 0) {
      r[1] *= 1 + d / 1.5 * r[0] * r[0];
    }

    return r;
  };
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(bertin1953Raw());
  p.rotate([-16.5, -42]);
  delete p.rotate;
  return p.scale(176.57).center([7.93, 0.09]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/boggs.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/boggs.js ***!
  \*****************************************************/
/*! exports provided: boggsRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boggsRaw", function() { return boggsRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



var k = 2.00276,
    w = 1.11072;
function boggsRaw(lambda, phi) {
  var theta = Object(_mollweide__WEBPACK_IMPORTED_MODULE_1__["mollweideBromleyTheta"])(_math__WEBPACK_IMPORTED_MODULE_2__["pi"], phi);
  return [k * lambda / (1 / Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi) + w / Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(theta)), (phi + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(theta)) / k];
}

boggsRaw.invert = function (x, y) {
  var ky = k * y,
      theta = y < 0 ? -_math__WEBPACK_IMPORTED_MODULE_2__["quarterPi"] : _math__WEBPACK_IMPORTED_MODULE_2__["quarterPi"],
      i = 25,
      delta,
      phi;

  do {
    phi = ky - _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(theta);
    theta -= delta = (Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(2 * theta) + 2 * theta - _math__WEBPACK_IMPORTED_MODULE_2__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi)) / (2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(2 * theta) + 2 + _math__WEBPACK_IMPORTED_MODULE_2__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi) * _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(theta));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] && --i > 0);

  phi = ky - _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(theta);
  return [x * (1 / Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi) + w / Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(theta)) / k, phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(boggsRaw).scale(160.857);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/bonne.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/bonne.js ***!
  \*****************************************************/
/*! exports provided: bonneRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bonneRaw", function() { return bonneRaw; });
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _sinusoidal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sinusoidal */ "./node_modules/d3-geo-projection/src/sinusoidal.js");



function bonneRaw(phi0) {
  if (!phi0) return _sinusoidal__WEBPACK_IMPORTED_MODULE_2__["sinusoidalRaw"];
  var cotPhi0 = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi0);

  function forward(lambda, phi) {
    var rho = cotPhi0 + phi0 - phi,
        e = rho ? lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) / rho : rho;
    return [rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(e), cotPhi0 - rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(e)];
  }

  forward.invert = function (x, y) {
    var rho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + (y = cotPhi0 - y) * y),
        phi = cotPhi0 + phi0 - rho;
    return [rho / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x, y), phi];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_0__["default"])(bonneRaw).scale(123.082).center([0, 26.1441]).parallel(45);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/bottomley.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/bottomley.js ***!
  \*********************************************************/
/*! exports provided: bottomleyRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bottomleyRaw", function() { return bottomleyRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function bottomleyRaw(sinPsi) {
  function forward(lambda, phi) {
    var rho = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - phi,
        eta = rho ? lambda * sinPsi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rho) / rho : rho;
    return [rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(eta) / sinPsi, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(eta)];
  }

  forward.invert = function (x, y) {
    var x1 = x * sinPsi,
        y1 = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - y,
        rho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x1 * x1 + y1 * y1),
        eta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x1, y1);
    return [(rho ? rho / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rho) : 1) * eta / sinPsi, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - rho];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var sinPsi = 0.5,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(bottomleyRaw),
      p = m(sinPsi);

  p.fraction = function (_) {
    return arguments.length ? m(sinPsi = +_) : sinPsi;
  };

  return p.scale(158.837);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/bromley.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/bromley.js ***!
  \*******************************************************/
/*! exports provided: bromleyRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bromleyRaw", function() { return bromleyRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");



var bromleyRaw = Object(_mollweide__WEBPACK_IMPORTED_MODULE_2__["mollweideBromleyRaw"])(1, 4 / _math__WEBPACK_IMPORTED_MODULE_1__["pi"], _math__WEBPACK_IMPORTED_MODULE_1__["pi"]);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(bromleyRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/chamberlin.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/chamberlin.js ***!
  \**********************************************************/
/*! exports provided: chamberlinRaw, chamberlinAfrica, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chamberlinRaw", function() { return chamberlinRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chamberlinAfrica", function() { return chamberlinAfrica; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return chamberlin; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");

 // Azimuthal distance.

function distance(dPhi, c1, s1, c2, s2, dLambda) {
  var cosdLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(dLambda),
      r;

  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dPhi) > 1 || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dLambda) > 1) {
    r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(s1 * s2 + c1 * c2 * cosdLambda);
  } else {
    var sindPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(dPhi / 2),
        sindLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(dLambda / 2);
    r = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda));
  }

  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(r) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? [r, Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(c2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(dLambda), c1 * s2 - s1 * c2 * cosdLambda)] : [0, 0];
} // Angle opposite a, and contained between sides of lengths b and c.


function angle(b, c, a) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])((b * b + c * c - a * a) / (2 * b * c));
} // Normalize longitude.


function longitude(lambda) {
  return lambda - 2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["floor"])((lambda + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / (2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]));
}

function chamberlinRaw(p0, p1, p2) {
  var points = [[p0[0], p0[1], Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(p0[1]), Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(p0[1])], [p1[0], p1[1], Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(p1[1]), Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(p1[1])], [p2[0], p2[1], Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(p2[1]), Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(p2[1])]];

  for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {
    b = points[i];
    a.v = distance(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);
    a.point = [0, 0];
  }

  var beta0 = angle(points[0].v[0], points[2].v[0], points[1].v[0]),
      beta1 = angle(points[0].v[0], points[1].v[0], points[2].v[0]),
      beta2 = _math__WEBPACK_IMPORTED_MODULE_1__["pi"] - beta0;
  points[2].point[1] = 0;
  points[0].point[0] = -(points[1].point[0] = points[0].v[0] / 2);
  var mean = [points[2].point[0] = points[0].point[0] + points[2].v[0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(beta0), 2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(beta0))];

  function forward(lambda, phi) {
    var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        v = new Array(3),
        i; // Compute distance and azimuth from control points.

    for (i = 0; i < 3; ++i) {
      var p = points[i];
      v[i] = distance(phi - p[1], p[3], p[2], cosPhi, sinPhi, lambda - p[0]);
      if (!v[i][0]) return p.point;
      v[i][1] = longitude(v[i][1] - p.v[1]);
    } // Arithmetic mean of interception points.


    var point = mean.slice();

    for (i = 0; i < 3; ++i) {
      var j = i == 2 ? 0 : i + 1;
      var a = angle(points[i].v[0], v[i][0], v[j][0]);
      if (v[i][1] < 0) a = -a;

      if (!i) {
        point[0] += v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(a);
        point[1] -= v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(a);
      } else if (i == 1) {
        a = beta1 - a;
        point[0] -= v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(a);
        point[1] -= v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(a);
      } else {
        a = beta2 - a;
        point[0] += v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(a);
        point[1] += v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(a);
      }
    }

    point[0] /= 3, point[1] /= 3;
    return point;
  }

  return forward;
}

function pointRadians(p) {
  return p[0] *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], p[1] *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], p;
}

function chamberlinAfrica() {
  return chamberlin([0, 22], [45, 22], [22.5, -22]).scale(380).center([22.5, 2]);
}
function chamberlin(p0, p1, p2) {
  // TODO order matters!
  var c = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCentroid"])({
    type: "MultiPoint",
    coordinates: [p0, p1, p2]
  }),
      R = [-c[0], -c[1]],
      r = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoRotation"])(R),
      p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(chamberlinRaw(pointRadians(r(p0)), pointRadians(r(p1)), pointRadians(r(p2)))).rotate(R),
      center = p.center;
  delete p.rotate;

  p.center = function (_) {
    return arguments.length ? center(r(_)) : r.invert(center());
  };

  return p.clipAngle(90);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/collignon.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/collignon.js ***!
  \*********************************************************/
/*! exports provided: collignonRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "collignonRaw", function() { return collignonRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function collignonRaw(lambda, phi) {
  var alpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi));
  return [2 / _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * lambda * alpha, _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * (1 - alpha)];
}

collignonRaw.invert = function (x, y) {
  var lambda = (lambda = y / _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] - 1) * lambda;
  return [lambda > 0 ? x * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lambda) / 2 : 0, Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(1 - lambda)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(collignonRaw).scale(95.6464).center([0, 30]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/craig.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/craig.js ***!
  \*****************************************************/
/*! exports provided: craigRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "craigRaw", function() { return craigRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");


function craigRaw(phi0) {
  var tanPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi0);

  function forward(lambda, phi) {
    return [lambda, (lambda ? lambda / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda) : 1) * (Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda) - tanPhi0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi))];
  }

  forward.invert = tanPhi0 ? function (x, y) {
    if (x) y *= Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x) / x;
    var cosLambda = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x);
    return [x, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(cosLambda * cosLambda + tanPhi0 * tanPhi0 - y * y) - cosLambda, tanPhi0 - y)];
  } : function (x, y) {
    return [x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(x ? y * Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(x) / x : y)];
  };
  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_1__["default"])(craigRaw).scale(249.828).clipAngle(90);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/craster.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/craster.js ***!
  \*******************************************************/
/*! exports provided: crasterRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "crasterRaw", function() { return crasterRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var sqrt3 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3);
function crasterRaw(lambda, phi) {
  return [sqrt3 * lambda * (2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(2 * phi / 3) - 1) / _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"], sqrt3 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi / 3)];
}

crasterRaw.invert = function (x, y) {
  var phi = 3 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y / (sqrt3 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"]));
  return [_math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * x / (sqrt3 * (2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(2 * phi / 3) - 1)), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(crasterRaw).scale(156.19);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/cylindricalEqualArea.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/cylindricalEqualArea.js ***!
  \********************************************************************/
/*! exports provided: cylindricalEqualAreaRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cylindricalEqualAreaRaw", function() { return cylindricalEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");


function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi) / cosPhi0];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(y * cosPhi0)];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_1__["default"])(cylindricalEqualAreaRaw).parallel(38.58) // acos(sqrt(width / height / pi)) * radians
  .scale(195.044); // width / (sqrt(width / height / pi) * 2 * pi)
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/cylindricalStereographic.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/cylindricalStereographic.js ***!
  \************************************************************************/
/*! exports provided: cylindricalStereographicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cylindricalStereographicRaw", function() { return cylindricalStereographicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");


function cylindricalStereographicRaw(phi0) {
  var cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, (1 + cosPhi0) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi / 2)];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(y / (1 + cosPhi0)) * 2];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_1__["default"])(cylindricalStereographicRaw).scale(124.75);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert1.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert1.js ***!
  \*******************************************************/
/*! exports provided: eckert1Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert1Raw", function() { return eckert1Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert1Raw(lambda, phi) {
  var alpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(8 / (3 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]));
  return [alpha * lambda * (1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]), alpha * phi];
}

eckert1Raw.invert = function (x, y) {
  var alpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(8 / (3 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"])),
      phi = y / alpha;
  return [x / (alpha * (1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) / _math__WEBPACK_IMPORTED_MODULE_1__["pi"])), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert1Raw).scale(165.664);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert2.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert2.js ***!
  \*******************************************************/
/*! exports provided: eckert2Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert2Raw", function() { return eckert2Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert2Raw(lambda, phi) {
  var alpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(4 - 3 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi)));
  return [2 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(6 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) * lambda * alpha, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 3) * (2 - alpha)];
}

eckert2Raw.invert = function (x, y) {
  var alpha = 2 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 3);
  return [x * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(6 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / (2 * alpha), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((4 - alpha * alpha) / 3)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert2Raw).scale(165.664);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert3.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert3.js ***!
  \*******************************************************/
/*! exports provided: eckert3Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert3Raw", function() { return eckert3Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert3Raw(lambda, phi) {
  var k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]));
  return [2 / k * lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - 4 * phi * phi / (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]))), 4 / k * phi];
}

eckert3Raw.invert = function (x, y) {
  var k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])) / 2;
  return [x * k / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - y * y * (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / (4 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]))), y * k / 2];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert3Raw).scale(180.739);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert4.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert4.js ***!
  \*******************************************************/
/*! exports provided: eckert4Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert4Raw", function() { return eckert4Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert4Raw(lambda, phi) {
  var k = (2 + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);
  phi /= 2;

  for (var i = 0, delta = Infinity; i < 10 && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; i++) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi);
    phi -= delta = (phi + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) * (cosPhi + 2) - k) / (2 * cosPhi * (1 + cosPhi));
  }

  return [2 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])) * lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
}

eckert4Raw.invert = function (x, y) {
  var A = y * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])((4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / 2,
      k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(A),
      c = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(k);
  return [x / (2 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])) * (1 + c)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((k + A * (c + 2)) / (2 + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert4Raw).scale(180.739);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert5.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert5.js ***!
  \*******************************************************/
/*! exports provided: eckert5Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert5Raw", function() { return eckert5Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert5Raw(lambda, phi) {
  return [lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]), 2 * phi / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])];
}

eckert5Raw.invert = function (x, y) {
  var k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]),
      phi = y * k / 2;
  return [k * x / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert5Raw).scale(173.044);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert6.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert6.js ***!
  \*******************************************************/
/*! exports provided: eckert6Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert6Raw", function() { return eckert6Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert6Raw(lambda, phi) {
  var k = (1 + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);

  for (var i = 0, delta = Infinity; i < 10 && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; i++) {
    phi -= delta = (phi + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) - k) / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi));
  }

  k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]);
  return [lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)) / k, 2 * phi / k];
}

eckert6Raw.invert = function (x, y) {
  var j = 1 + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(j / 2);
  return [x * 2 * k / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y *= k)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((y + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(y)) / j)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert6Raw).scale(173.044);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eisenlohr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eisenlohr.js ***!
  \*********************************************************/
/*! exports provided: eisenlohrRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eisenlohrRaw", function() { return eisenlohrRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _august__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./august */ "./node_modules/d3-geo-projection/src/august.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



var eisenlohrK = 3 + 2 * _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"];
function eisenlohrRaw(lambda, phi) {
  var s0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(lambda /= 2),
      c0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi)),
      c1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi /= 2),
      t = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi) / (c1 + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * k),
      c = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(2 / (1 + t * t)),
      v = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])((_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c1 + (c0 + s0) * k) / (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c1 + (c0 - s0) * k));
  return [eisenlohrK * (c * (v - 1 / v) - 2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(v)), eisenlohrK * (c * t * (v + 1 / v) - 2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan"])(t))];
}

eisenlohrRaw.invert = function (x, y) {
  if (!(p = _august__WEBPACK_IMPORTED_MODULE_1__["augustRaw"].invert(x / 1.2, y * 1.065))) return null;
  var lambda = p[0],
      phi = p[1],
      i = 20,
      p;
  x /= eisenlohrK, y /= eisenlohrK;

  do {
    var _0 = lambda / 2,
        _1 = phi / 2,
        s0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(_0),
        c0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(_0),
        s1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(_1),
        c1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(_1),
        cos1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi),
        k = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(cos1),
        t = s1 / (c1 + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * k),
        t2 = t * t,
        c = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(2 / (1 + t2)),
        v0 = _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c1 + (c0 + s0) * k,
        v1 = _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c1 + (c0 - s0) * k,
        v2 = v0 / v1,
        v = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(v2),
        vm1v = v - 1 / v,
        vp1v = v + 1 / v,
        fx = c * vm1v - 2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(v) - x,
        fy = c * t * vp1v - 2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan"])(t) - y,
        deltatDeltaLambda = s1 && _math__WEBPACK_IMPORTED_MODULE_2__["sqrt1_2"] * k * s0 * t2 / s1,
        deltatDeltaPhi = (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * c1 + k) / (2 * (c1 + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * k) * (c1 + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * k) * k),
        deltacDeltat = -0.5 * t * c * c * c,
        deltacDeltaLambda = deltacDeltat * deltatDeltaLambda,
        deltacDeltaPhi = deltacDeltat * deltatDeltaPhi,
        A = (A = 2 * c1 + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * k * (c0 - s0)) * A * v,
        deltavDeltaLambda = (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * c1 * k + cos1) / A,
        deltavDeltaPhi = -(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * s0 * s1) / (k * A),
        deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c * (deltavDeltaLambda + deltavDeltaLambda / v2),
        deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c * (deltavDeltaPhi + deltavDeltaPhi / v2),
        deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t2) + c * vp1v * deltatDeltaLambda + c * t * (deltavDeltaLambda - deltavDeltaLambda / v2),
        deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t2) + c * vp1v * deltatDeltaPhi + c * t * (deltavDeltaPhi - deltavDeltaPhi / v2),
        denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;

    if (!denominator) break;
    var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator,
        deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda;
    phi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["max"])(-_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"], Object(_math__WEBPACK_IMPORTED_MODULE_2__["min"])(_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"], phi - deltaPhi));
  } while ((Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(deltaLambda) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(deltaPhi) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) && --i > 0);

  return Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(phi) - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] ? [0, phi] : i && [lambda, phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eisenlohrRaw).scale(62.5271);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/elliptic.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/elliptic.js ***!
  \********************************************************/
/*! exports provided: ellipticJi, ellipticJ, ellipticFi, ellipticF */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ellipticJi", function() { return ellipticJi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ellipticJ", function() { return ellipticJ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ellipticFi", function() { return ellipticFi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ellipticF", function() { return ellipticF; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
 // Returns [sn, cn, dn](u + iv|m).

function ellipticJi(u, v, m) {
  var a, b, c;

  if (!u) {
    b = ellipticJ(v, 1 - m);
    return [[0, b[0] / b[1]], [1 / b[1], 0], [b[2] / b[1], 0]];
  }

  a = ellipticJ(u, m);
  if (!v) return [[a[0], 0], [a[1], 0], [a[2], 0]];
  b = ellipticJ(v, 1 - m);
  c = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];
  return [[a[0] * b[2] / c, a[1] * a[2] * b[0] * b[1] / c], [a[1] * b[1] / c, -a[0] * a[2] * b[0] * b[2] / c], [a[2] * b[1] * b[2] / c, -m * a[0] * a[1] * b[0] / c]];
} // Returns [sn, cn, dn, ph](u|m).

function ellipticJ(u, m) {
  var ai, b, phi, t, twon;

  if (m < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) {
    t = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(u);
    b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(u);
    ai = m * (u - t * b) / 4;
    return [t - ai * b, b + ai * t, 1 - m * t * t / 2, u - ai];
  }

  if (m >= 1 - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) {
    ai = (1 - m) / 4;
    b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cosh"])(u);
    t = Object(_math__WEBPACK_IMPORTED_MODULE_0__["tanh"])(u);
    phi = 1 / b;
    twon = b * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sinh"])(u);
    return [t + ai * (twon - u) / (b * b), phi - ai * t * phi * (twon - u), phi + ai * t * phi * (twon + u), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["exp"])(u)) - _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + ai * (twon - u) / b];
  }

  var a = [1, 0, 0, 0, 0, 0, 0, 0, 0],
      c = [Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(m), 0, 0, 0, 0, 0, 0, 0, 0],
      i = 0;
  b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(1 - m);
  twon = 1;

  while (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(c[i] / a[i]) > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] && i < 8) {
    ai = a[i++];
    c[i] = (ai - b) / 2;
    a[i] = (ai + b) / 2;
    b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(ai * b);
    twon *= 2;
  }

  phi = twon * a[i] * u;

  do {
    t = c[i] * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(b = phi) / a[i];
    phi = (Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(t) + phi) / 2;
  } while (--i);

  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi), t = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi), t / Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi - b), phi];
} // Calculate F(phi+iPsi|m).
// See Abramowitz and Stegun, 17.4.11.

function ellipticFi(phi, psi, m) {
  var r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(phi),
      i = Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(psi),
      sinhPsi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sinh"])(i);

  if (r) {
    var cscPhi = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(r),
        cotPhi2 = 1 / (Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(r) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(r)),
        b = -(cotPhi2 + m * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m),
        c = (m - 1) * cotPhi2,
        cotLambda2 = (-b + Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(b * b - 4 * c)) / 2;
    return [ellipticF(Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(1 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(cotLambda2)), m) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(phi), ellipticF(Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])((cotLambda2 / cotPhi2 - 1) / m)), 1 - m) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(psi)];
  }

  return [0, ellipticF(Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(sinhPsi), 1 - m) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(psi)];
} // Calculate F(phi|m) where m = k² = sin²α.
// See Abramowitz and Stegun, 17.6.7.

function ellipticF(phi, m) {
  if (!m) return phi;
  if (m === 1) return Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi / 2 + _math__WEBPACK_IMPORTED_MODULE_0__["quarterPi"]));
  var a = 1,
      b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(1 - m),
      c = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(m);

  for (var i = 0; Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(c) > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]; i++) {
    if (phi % _math__WEBPACK_IMPORTED_MODULE_0__["pi"]) {
      var dPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(b * Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi) / a);
      if (dPhi < 0) dPhi += _math__WEBPACK_IMPORTED_MODULE_0__["pi"];
      phi += dPhi + ~~(phi / _math__WEBPACK_IMPORTED_MODULE_0__["pi"]) * _math__WEBPACK_IMPORTED_MODULE_0__["pi"];
    } else phi += phi;

    c = (a + b) / 2;
    b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(a * b);
    c = ((a = c) - b) / 2;
  }

  return phi / (Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(2, i) * a);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/fahey.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/fahey.js ***!
  \*****************************************************/
/*! exports provided: faheyRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "faheyRaw", function() { return faheyRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var faheyK = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(35 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
function faheyRaw(lambda, phi) {
  var t = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi / 2);
  return [lambda * faheyK * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - t * t), (1 + faheyK) * t];
}

faheyRaw.invert = function (x, y) {
  var t = y / (1 + faheyK);
  return [x && x / (faheyK * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - t * t)), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(t)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(faheyRaw).scale(137.152);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/foucaut.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/foucaut.js ***!
  \*******************************************************/
/*! exports provided: foucautRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "foucautRaw", function() { return foucautRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function foucautRaw(lambda, phi) {
  var k = phi / 2,
      cosk = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(k);
  return [2 * lambda / _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * cosk * cosk, _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(k)];
}

foucautRaw.invert = function (x, y) {
  var k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(y / _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"]),
      cosk = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(k),
      phi = 2 * k;
  return [x * _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] / 2 / (Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * cosk * cosk), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(foucautRaw).scale(135.264);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/gilbert.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/gilbert.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



function gilbertForward(point) {
  return [point[0] / 2, Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(point[1] / 2 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"])) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]];
}

function gilbertInvert(point) {
  return [point[0] * 2, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(point[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"])) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]];
}

/* harmony default export */ __webpack_exports__["default"] = (function (projectionType) {
  if (projectionType == null) projectionType = d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoOrthographic"];
  var projection = projectionType(),
      equirectangular = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoEquirectangular"])().scale(_math__WEBPACK_IMPORTED_MODULE_1__["degrees"]).precision(0).clipAngle(null).translate([0, 0]); // antimeridian cutting

  function gilbert(point) {
    return projection(gilbertForward(point));
  }

  if (projection.invert) gilbert.invert = function (point) {
    return gilbertInvert(projection.invert(point));
  };

  gilbert.stream = function (stream) {
    var s1 = projection.stream(stream),
        s0 = equirectangular.stream({
      point: function point(lambda, phi) {
        s1.point(lambda / 2, Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(-phi / 2 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"])) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);
      },
      lineStart: function lineStart() {
        s1.lineStart();
      },
      lineEnd: function lineEnd() {
        s1.lineEnd();
      },
      polygonStart: function polygonStart() {
        s1.polygonStart();
      },
      polygonEnd: function polygonEnd() {
        s1.polygonEnd();
      }
    });
    s0.sphere = s1.sphere;
    return s0;
  };

  function property(name) {
    gilbert[name] = function (_) {
      return arguments.length ? (projection[name](_), gilbert) : projection[name]();
    };
  }

  gilbert.rotate = function (_) {
    return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();
  };

  gilbert.center = function (_) {
    return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());
  };

  property("angle");
  property("clipAngle");
  property("clipExtent");
  property("scale");
  property("translate");
  property("precision");
  return gilbert.scale(249.5);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/gingery.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/gingery.js ***!
  \*******************************************************/
/*! exports provided: gingeryRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gingeryRaw", function() { return gingeryRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function gingeryRaw(rho, n) {
  var k = 2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / n,
      rho2 = rho * rho;

  function forward(lambda, phi) {
    var p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEquidistantRaw"])(lambda, phi),
        x = p[0],
        y = p[1],
        r2 = x * x + y * y;

    if (r2 > rho2) {
      var r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(r2),
          theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y, x),
          theta0 = k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["round"])(theta / k),
          alpha = theta - theta0,
          rhoCosAlpha = rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(alpha),
          k_ = (rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(alpha) - alpha * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rhoCosAlpha)) / (_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - rhoCosAlpha),
          s_ = gingeryLength(alpha, k_),
          e = (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] - rho) / gingeryIntegrate(s_, rhoCosAlpha, _math__WEBPACK_IMPORTED_MODULE_1__["pi"]);
      x = r;
      var i = 50,
          delta;

      do {
        x -= delta = (rho + gingeryIntegrate(s_, rhoCosAlpha, x) * e - r) / (s_(x) * e);
      } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

      y = alpha * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x);
      if (x < _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) y -= k_ * (x - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]);
      var s = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta0),
          c = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta0);
      p[0] = x * c - y * s;
      p[1] = x * s + y * c;
    }

    return p;
  }

  forward.invert = function (x, y) {
    var r2 = x * x + y * y;

    if (r2 > rho2) {
      var r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(r2),
          theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y, x),
          theta0 = k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["round"])(theta / k),
          dTheta = theta - theta0;
      x = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(dTheta);
      y = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(dTheta);
      var x_halfPi = x - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
          sinx = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x),
          alpha = y / sinx,
          delta = x < _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] ? Infinity : 0,
          i = 10;

      while (true) {
        var rhosinAlpha = rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(alpha),
            rhoCosAlpha = rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(alpha),
            sinRhoCosAlpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rhoCosAlpha),
            halfPi_RhoCosAlpha = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - rhoCosAlpha,
            k_ = (rhosinAlpha - alpha * sinRhoCosAlpha) / halfPi_RhoCosAlpha,
            s_ = gingeryLength(alpha, k_);
        if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] || ! --i) break;
        alpha -= delta = (alpha * sinx - k_ * x_halfPi - y) / (sinx - x_halfPi * 2 * (halfPi_RhoCosAlpha * (rhoCosAlpha + alpha * rhosinAlpha * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(rhoCosAlpha) - sinRhoCosAlpha) - rhosinAlpha * (rhosinAlpha - alpha * sinRhoCosAlpha)) / (halfPi_RhoCosAlpha * halfPi_RhoCosAlpha));
      }

      r = rho + gingeryIntegrate(s_, rhoCosAlpha, x) * (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] - rho) / gingeryIntegrate(s_, rhoCosAlpha, _math__WEBPACK_IMPORTED_MODULE_1__["pi"]);
      theta = theta0 + alpha;
      x = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta);
      y = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta);
    }

    return d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEquidistantRaw"].invert(x, y);
  };

  return forward;
}

function gingeryLength(alpha, k) {
  return function (x) {
    var y_ = alpha * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(x);
    if (x < _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) y_ -= k;
    return Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 + y_ * y_);
  };
} // Numerical integration: trapezoidal rule.


function gingeryIntegrate(f, a, b) {
  var n = 50,
      h = (b - a) / n,
      s = f(a) + f(b);

  for (var i = 1, x = a; i < n; ++i) {
    s += 2 * f(x += h);
  }

  return s * 0.5 * h;
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var n = 6,
      rho = 30 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"],
      cRho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(rho),
      sRho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rho),
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(gingeryRaw),
      p = m(rho, n),
      stream_ = p.stream,
      epsilon = 1e-2,
      cr = -Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(epsilon * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]),
      sr = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(epsilon * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);

  p.radius = function (_) {
    if (!arguments.length) return rho * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
    cRho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(rho = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
    sRho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rho);
    return m(rho, n);
  };

  p.lobes = function (_) {
    if (!arguments.length) return n;
    return m(rho, n = +_);
  };

  p.stream = function (stream) {
    var rotate = p.rotate(),
        rotateStream = stream_(stream),
        sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);

    rotateStream.sphere = function () {
      sphereStream.polygonStart(), sphereStream.lineStart();

      for (var i = 0, delta = 2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / n, phi = 0; i < n; ++i, phi -= delta) {
        sphereStream.point(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(sr * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi), cr) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sr * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);
        sphereStream.point(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(sRho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi - delta / 2), cRho) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sRho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi - delta / 2)) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);
      }

      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };

    return rotateStream;
  };

  return p.rotate([90, -40]).scale(91.7095).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburg4.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburg4.js ***!
  \*********************************************************/
/*! exports provided: ginzburg4Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ginzburg4Raw", function() { return ginzburg4Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ginzburgPolyconic */ "./node_modules/d3-geo-projection/src/ginzburgPolyconic.js");


var ginzburg4Raw = Object(_ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__["default"])(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(ginzburg4Raw).scale(149.995);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburg5.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburg5.js ***!
  \*********************************************************/
/*! exports provided: ginzburg5Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ginzburg5Raw", function() { return ginzburg5Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ginzburgPolyconic */ "./node_modules/d3-geo-projection/src/ginzburgPolyconic.js");


var ginzburg5Raw = Object(_ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__["default"])(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(ginzburg5Raw).scale(153.93);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburg6.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburg6.js ***!
  \*********************************************************/
/*! exports provided: ginzburg6Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ginzburg6Raw", function() { return ginzburg6Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ginzburgPolyconic */ "./node_modules/d3-geo-projection/src/ginzburgPolyconic.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



var ginzburg6Raw = Object(_ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__["default"])(5 / 6 * _math__WEBPACK_IMPORTED_MODULE_2__["pi"], -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(ginzburg6Raw).scale(130.945);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburg8.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburg8.js ***!
  \*********************************************************/
/*! exports provided: ginzburg8Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ginzburg8Raw", function() { return ginzburg8Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function ginzburg8Raw(lambda, phi) {
  var lambda2 = lambda * lambda,
      phi2 = phi * phi;
  return [lambda * (1 - 0.162388 * phi2) * (0.87 - 0.000952426 * lambda2 * lambda2), phi * (1 + phi2 / 12)];
}

ginzburg8Raw.invert = function (x, y) {
  var lambda = x,
      phi = y,
      i = 50,
      delta;

  do {
    var phi2 = phi * phi;
    phi -= delta = (phi * (1 + phi2 / 12) - y) / (1 + phi2 / 4);
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  i = 50;
  x /= 1 - 0.162388 * phi2;

  do {
    var lambda4 = (lambda4 = lambda * lambda) * lambda4;
    lambda -= delta = (lambda * (0.87 - 0.000952426 * lambda4) - x) / (0.87 - 0.00476213 * lambda4);
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  return [lambda, phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(ginzburg8Raw).scale(131.747);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburg9.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburg9.js ***!
  \*********************************************************/
/*! exports provided: ginzburg9Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ginzburg9Raw", function() { return ginzburg9Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ginzburgPolyconic */ "./node_modules/d3-geo-projection/src/ginzburgPolyconic.js");


var ginzburg9Raw = Object(_ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__["default"])(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(ginzburg9Raw).scale(131.087);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburgPolyconic.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburgPolyconic.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");

/* harmony default export */ __webpack_exports__["default"] = (function (a, b, c, d, e, f, g, h) {
  if (arguments.length < 8) h = 0;

  function forward(lambda, phi) {
    if (!phi) return [a * lambda / _math__WEBPACK_IMPORTED_MODULE_0__["pi"], 0];
    var phi2 = phi * phi,
        xB = a + phi2 * (b + phi2 * (c + phi2 * d)),
        yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)),
        m = (xB * xB + yB * yB) / (2 * yB),
        alpha = lambda * Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(xB / m) / _math__WEBPACK_IMPORTED_MODULE_0__["pi"];
    return [m * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(alpha), phi * (1 + phi2 * h) + m * (1 - Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(alpha))];
  }

  forward.invert = function (x, y) {
    var lambda = _math__WEBPACK_IMPORTED_MODULE_0__["pi"] * x / a,
        phi = y,
        deltaLambda,
        deltaPhi,
        i = 50;

    do {
      var phi2 = phi * phi,
          xB = a + phi2 * (b + phi2 * (c + phi2 * d)),
          yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)),
          p = xB * xB + yB * yB,
          q = 2 * yB,
          m = p / q,
          m2 = m * m,
          dAlphadLambda = Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(xB / m) / _math__WEBPACK_IMPORTED_MODULE_0__["pi"],
          alpha = lambda * dAlphadLambda,
          xB2 = xB * xB,
          dxBdPhi = (2 * b + phi2 * (4 * c + phi2 * 6 * d)) * phi,
          dyBdPhi = e + phi2 * (3 * f + phi2 * 5 * g),
          dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)),
          dqdPhi = 2 * (dyBdPhi - 1),
          dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q),
          cosAlpha = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(alpha),
          sinAlpha = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(alpha),
          mcosAlpha = m * cosAlpha,
          msinAlpha = m * sinAlpha,
          dAlphadPhi = lambda / _math__WEBPACK_IMPORTED_MODULE_0__["pi"] * (1 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(1 - xB2 / m2)) * (dxBdPhi * m - xB * dmdPhi) / m2,
          fx = msinAlpha - x,
          fy = phi * (1 + phi2 * h) + m - mcosAlpha - y,
          deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi,
          deltaxDeltaLambda = mcosAlpha * dAlphadLambda,
          deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi),
          deltayDeltaLambda = msinAlpha * dAlphadLambda,
          denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
      if (!denominator) break;
      lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
      phi -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    } while ((Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(deltaLambda) > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(deltaPhi) > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) && --i > 0);

    return [lambda, phi];
  };

  return forward;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/gringorten.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/gringorten.js ***!
  \**********************************************************/
/*! exports provided: gringortenRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gringortenRaw", function() { return gringortenRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _square__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./square */ "./node_modules/d3-geo-projection/src/square.js");



function gringortenRaw(lambda, phi) {
  var sLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(lambda),
      sPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi),
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
      y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
      z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(sPhi * phi);
  lambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y, z));
  phi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x);
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) lambda %= _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"];
  var point = gringortenHexadecant(lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4 ? _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - lambda : lambda, phi);
  if (lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4) z = point[0], point[0] = -point[1], point[1] = -z;
  return point[0] *= sLambda, point[1] *= -sPhi, point;
}

gringortenRaw.invert = function (x, y) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x) > 1) x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * 2 - x;
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) > 1) y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * 2 - y;
  var sx = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x),
      sy = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y),
      x0 = -sx * x,
      y0 = -sy * y,
      t = y0 / x0 < 1,
      p = gringortenHexadecantInvert(t ? y0 : x0, t ? x0 : y0),
      lambda = p[0],
      phi = p[1],
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi);
  if (t) lambda = -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - lambda;
  return [sx * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi, -Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)) + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]), sy * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi)];
};

function gringortenHexadecant(lambda, phi) {
  if (phi === _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) return [0, 0];
  var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      r = sinPhi * sinPhi,
      r2 = r * r,
      j = 1 + r2,
      k = 1 + 3 * r2,
      q = 1 - r2,
      z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(j)),
      v = q + r * j * z,
      p2 = (1 - sinPhi) / v,
      p = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(p2),
      a2 = p2 * j,
      a = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2),
      h = p * q,
      x,
      i;
  if (lambda === 0) return [0, -(h + r * a)];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      secPhi = 1 / cosPhi,
      drdPhi = 2 * sinPhi * cosPhi,
      dvdPhi = (-3 * r + z * k) * drdPhi,
      dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v),
      dpdPhi = 0.5 * dp2dPhi / p,
      dhdPhi = q * dpdPhi - 2 * r * p * drdPhi,
      dra2dPhi = r * j * dp2dPhi + p2 * k * drdPhi,
      mu = -secPhi * drdPhi,
      nu = -secPhi * dra2dPhi,
      zeta = -2 * secPhi * dhdPhi,
      lambda1 = 4 * lambda / _math__WEBPACK_IMPORTED_MODULE_1__["pi"],
      delta; // Slower but accurate bisection method.

  if (lambda > 0.222 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] || phi < _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4 && lambda > 0.175 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) {
    x = (h + r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2 * (1 + r2) - h * h)) / (1 + r2);
    if (lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4) return [x, x];
    var x1 = x,
        x0 = 0.5 * x;
    x = 0.5 * (x0 + x1), i = 50;

    do {
      var g = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2 - x * x),
          f = x * (zeta + mu * g) + nu * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x / a) - lambda1;
      if (!f) break;
      if (f < 0) x0 = x;else x1 = x;
      x = 0.5 * (x0 + x1);
    } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x1 - x0) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);
  } // Newton-Raphson.
  else {
      x = _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"], i = 25;

      do {
        var x2 = x * x,
            g2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2 - x2),
            zetaMug = zeta + mu * g2,
            f2 = x * zetaMug + nu * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x / a) - lambda1,
            df = zetaMug + (nu - mu * x2) / g2;
        x -= delta = g2 ? f2 / df : 0;
      } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);
    }

  return [x, -h - r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2 - x * x)];
}

function gringortenHexadecantInvert(x, y) {
  var x0 = 0,
      x1 = 1,
      r = 0.5,
      i = 50;

  while (true) {
    var r2 = r * r,
        sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(r),
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 + r2)),
        v = 1 - r2 + r * (1 + r2) * z,
        p2 = (1 - sinPhi) / v,
        p = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(p2),
        a2 = p2 * (1 + r2),
        h = p * (1 - r2),
        g2 = a2 - x * x,
        g = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(g2),
        y0 = y + h + r * g;
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x1 - x0) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] || --i === 0 || y0 === 0) break;
    if (y0 > 0) x0 = r;else x1 = r;
    r = 0.5 * (x0 + x1);
  }

  if (!i) return null;
  var phi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinPhi),
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      secPhi = 1 / cosPhi,
      drdPhi = 2 * sinPhi * cosPhi,
      dvdPhi = (-3 * r + z * (1 + 3 * r2)) * drdPhi,
      dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v),
      dpdPhi = 0.5 * dp2dPhi / p,
      dhdPhi = (1 - r2) * dpdPhi - 2 * r * p * drdPhi,
      zeta = -2 * secPhi * dhdPhi,
      mu = -secPhi * drdPhi,
      nu = -secPhi * (r * (1 + r2) * dp2dPhi + p2 * (1 + 3 * r2) * drdPhi);
  return [_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4 * (x * (zeta + mu * g) + nu * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2))), phi];
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(Object(_square__WEBPACK_IMPORTED_MODULE_2__["default"])(gringortenRaw)).scale(239.75);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/guyou.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/guyou.js ***!
  \*****************************************************/
/*! exports provided: guyouRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "guyouRaw", function() { return guyouRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _elliptic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elliptic */ "./node_modules/d3-geo-projection/src/elliptic.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _square__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./square */ "./node_modules/d3-geo-projection/src/square.js");




function guyouRaw(lambda, phi) {
  var k_ = (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] - 1) / (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] + 1),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(1 - k_ * k_),
      K = Object(_elliptic__WEBPACK_IMPORTED_MODULE_1__["ellipticF"])(_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"], k * k),
      f = -1,
      psi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["tan"])(_math__WEBPACK_IMPORTED_MODULE_2__["pi"] / 4 + Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(phi) / 2)),
      r = Object(_math__WEBPACK_IMPORTED_MODULE_2__["exp"])(f * psi) / Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(k_),
      at = guyouComplexAtan(r * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(f * lambda), r * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(f * lambda)),
      t = Object(_elliptic__WEBPACK_IMPORTED_MODULE_1__["ellipticFi"])(at[0], at[1], k * k);
  return [-t[1], (phi >= 0 ? 1 : -1) * (0.5 * K - t[0])];
}

function guyouComplexAtan(x, y) {
  var x2 = x * x,
      y_1 = y + 1,
      t = 1 - x2 - y * y;
  return [0.5 * ((x >= 0 ? _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] : -_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"]) - Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t, 2 * x)), -0.25 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(t * t + 4 * x2) + 0.5 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(y_1 * y_1 + x2)];
}

function guyouComplexDivide(a, b) {
  var denominator = b[0] * b[0] + b[1] * b[1];
  return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
}

guyouRaw.invert = function (x, y) {
  var k_ = (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] - 1) / (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] + 1),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(1 - k_ * k_),
      K = Object(_elliptic__WEBPACK_IMPORTED_MODULE_1__["ellipticF"])(_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"], k * k),
      f = -1,
      j = Object(_elliptic__WEBPACK_IMPORTED_MODULE_1__["ellipticJi"])(0.5 * K - y, -x, k * k),
      tn = guyouComplexDivide(j[0], j[1]),
      lambda = Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(tn[1], tn[0]) / f;
  return [lambda, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["exp"])(0.5 / f * Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(Object(_square__WEBPACK_IMPORTED_MODULE_3__["default"])(guyouRaw)).scale(151.496);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/hammer.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/hammer.js ***!
  \******************************************************/
/*! exports provided: hammerRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hammerRaw", function() { return hammerRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function hammerRaw(A, B) {
  if (arguments.length < 2) B = A;
  if (B === 1) return d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEqualAreaRaw"];
  if (B === Infinity) return hammerQuarticAuthalicRaw;

  function forward(lambda, phi) {
    var coordinates = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEqualAreaRaw"])(lambda / B, phi);
    coordinates[0] *= A;
    return coordinates;
  }

  forward.invert = function (x, y) {
    var coordinates = d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEqualAreaRaw"].invert(x / A, y);
    coordinates[0] *= B;
    return coordinates;
  };

  return forward;
}

function hammerQuarticAuthalicRaw(lambda, phi) {
  return [lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi /= 2), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
}

hammerQuarticAuthalicRaw.invert = function (x, y) {
  var phi = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y / 2);
  return [x * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi / 2) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var B = 2,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(hammerRaw),
      p = m(B);

  p.coefficient = function (_) {
    if (!arguments.length) return B;
    return m(B = +_);
  };

  return p.scale(169.529);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/hammerRetroazimuthal.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/hammerRetroazimuthal.js ***!
  \********************************************************************/
/*! exports provided: hammerRetroazimuthalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hammerRetroazimuthalRaw", function() { return hammerRetroazimuthalRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function hammerRetroazimuthalRaw(phi0) {
  var sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0),
      cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0),
      rotate = hammerRetroazimuthalRotation(phi0);
  rotate.invert = hammerRetroazimuthalRotation(-phi0);

  function forward(lambda, phi) {
    var p = rotate(lambda, phi);
    lambda = p[0], phi = p[1];
    var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        cosLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda),
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLambda),
        sinz = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(z),
        K = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(sinz) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? z / sinz : 1;
    return [K * cosPhi0 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) > _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] ? K : -K) * ( // rotate for back hemisphere
    sinPhi0 * cosPhi - cosPhi0 * sinPhi * cosLambda)];
  }

  forward.invert = function (x, y) {
    var rho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + y * y),
        sinz = -Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rho),
        cosz = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(rho),
        a = rho * cosz,
        b = -y * sinz,
        c = rho * sinPhi0,
        d = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a * a + b * b - c * c),
        phi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(a * c + b * d, b * c - a * d),
        lambda = (rho > _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] ? -1 : 1) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x * sinz, rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * cosz + y * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) * sinz);
    return rotate.invert(lambda, phi);
  };

  return forward;
} // Latitudinal rotation by phi0.
// Temporary hack until D3 supports arbitrary small-circle clipping origins.

function hammerRetroazimuthalRotation(phi0) {
  var sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0),
      cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0);
  return function (lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
        y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y, x * cosPhi0 - z * sinPhi0), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(z * cosPhi0 + x * sinPhi0)];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var phi0 = 0,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(hammerRetroazimuthalRaw),
      p = m(phi0),
      rotate_ = p.rotate,
      stream_ = p.stream,
      circle = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCircle"])();

  p.parallel = function (_) {
    if (!arguments.length) return phi0 * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
    var r = p.rotate();
    return m(phi0 = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]).rotate(r);
  }; // Temporary hack; see hammerRetroazimuthalRotation.


  p.rotate = function (_) {
    if (!arguments.length) return _ = rotate_.call(p), _[1] += phi0 * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], _;
    rotate_.call(p, [_[0], _[1] - phi0 * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]]);
    circle.center([-_[0], -_[1]]);
    return p;
  };

  p.stream = function (stream) {
    stream = stream_(stream);

    stream.sphere = function () {
      stream.polygonStart();
      var epsilon = 1e-2,
          ring = circle.radius(90 - epsilon)().coordinates[0],
          n = ring.length - 1,
          i = -1,
          p;
      stream.lineStart();

      while (++i < n) {
        stream.point((p = ring[i])[0], p[1]);
      }

      stream.lineEnd();
      ring = circle.radius(90 + epsilon)().coordinates[0];
      n = ring.length - 1;
      stream.lineStart();

      while (--i >= 0) {
        stream.point((p = ring[i])[0], p[1]);
      }

      stream.lineEnd();
      stream.polygonEnd();
    };

    return stream;
  };

  return p.scale(79.4187).parallel(45).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/healpix.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/healpix.js ***!
  \*******************************************************/
/*! exports provided: healpixRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "healpixRaw", function() { return healpixRaw; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _collignon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collignon */ "./node_modules/d3-geo-projection/src/collignon.js");
/* harmony import */ var _cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cylindricalEqualArea */ "./node_modules/d3-geo-projection/src/cylindricalEqualArea.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");





var healpixParallel = 41 + 48 / 36 + 37 / 3600,
    // for K=3; TODO automate
healpixLambert = Object(_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_3__["cylindricalEqualAreaRaw"])(0);
function healpixRaw(H) {
  var phi0 = healpixParallel * _math__WEBPACK_IMPORTED_MODULE_4__["radians"],
      dx = Object(_collignon__WEBPACK_IMPORTED_MODULE_2__["collignonRaw"])(_math__WEBPACK_IMPORTED_MODULE_4__["pi"], phi0)[0] - Object(_collignon__WEBPACK_IMPORTED_MODULE_2__["collignonRaw"])(-_math__WEBPACK_IMPORTED_MODULE_4__["pi"], phi0)[0],
      y0 = healpixLambert(0, phi0)[1],
      y1 = Object(_collignon__WEBPACK_IMPORTED_MODULE_2__["collignonRaw"])(0, phi0)[1],
      dy1 = _math__WEBPACK_IMPORTED_MODULE_4__["sqrtPi"] - y1,
      k = _math__WEBPACK_IMPORTED_MODULE_4__["tau"] / H,
      w = 4 / _math__WEBPACK_IMPORTED_MODULE_4__["tau"],
      h = y0 + dy1 * dy1 * 4 / _math__WEBPACK_IMPORTED_MODULE_4__["tau"];

  function forward(lambda, phi) {
    var point,
        phi2 = Object(_math__WEBPACK_IMPORTED_MODULE_4__["abs"])(phi);

    if (phi2 > phi0) {
      var i = Object(_math__WEBPACK_IMPORTED_MODULE_4__["min"])(H - 1, Object(_math__WEBPACK_IMPORTED_MODULE_4__["max"])(0, Object(_math__WEBPACK_IMPORTED_MODULE_4__["floor"])((lambda + _math__WEBPACK_IMPORTED_MODULE_4__["pi"]) / k)));
      lambda += _math__WEBPACK_IMPORTED_MODULE_4__["pi"] * (H - 1) / H - i * k;
      point = Object(_collignon__WEBPACK_IMPORTED_MODULE_2__["collignonRaw"])(lambda, phi2);
      point[0] = point[0] * _math__WEBPACK_IMPORTED_MODULE_4__["tau"] / dx - _math__WEBPACK_IMPORTED_MODULE_4__["tau"] * (H - 1) / (2 * H) + i * _math__WEBPACK_IMPORTED_MODULE_4__["tau"] / H;
      point[1] = y0 + (point[1] - y1) * 4 * dy1 / _math__WEBPACK_IMPORTED_MODULE_4__["tau"];
      if (phi < 0) point[1] = -point[1];
    } else {
      point = healpixLambert(lambda, phi);
    }

    point[0] *= w, point[1] /= h;
    return point;
  }

  forward.invert = function (x, y) {
    x /= w, y *= h;
    var y2 = Object(_math__WEBPACK_IMPORTED_MODULE_4__["abs"])(y);

    if (y2 > y0) {
      var i = Object(_math__WEBPACK_IMPORTED_MODULE_4__["min"])(H - 1, Object(_math__WEBPACK_IMPORTED_MODULE_4__["max"])(0, Object(_math__WEBPACK_IMPORTED_MODULE_4__["floor"])((x + _math__WEBPACK_IMPORTED_MODULE_4__["pi"]) / k)));
      x = (x + _math__WEBPACK_IMPORTED_MODULE_4__["pi"] * (H - 1) / H - i * k) * dx / _math__WEBPACK_IMPORTED_MODULE_4__["tau"];
      var point = _collignon__WEBPACK_IMPORTED_MODULE_2__["collignonRaw"].invert(x, 0.25 * (y2 - y0) * _math__WEBPACK_IMPORTED_MODULE_4__["tau"] / dy1 + y1);
      point[0] -= _math__WEBPACK_IMPORTED_MODULE_4__["pi"] * (H - 1) / H - i * k;
      if (y < 0) point[1] = -point[1];
      return point;
    }

    return healpixLambert.invert(x, y);
  };

  return forward;
}

function sphere(step) {
  return {
    type: "Polygon",
    coordinates: [Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(-180, 180 + step / 2, step).map(function (x, i) {
      return [x, i & 1 ? 90 - 1e-6 : healpixParallel];
    }).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(180, -180 - step / 2, -step).map(function (x, i) {
      return [x, i & 1 ? -90 + 1e-6 : -healpixParallel];
    }))]
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var H = 4,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_1__["geoProjectionMutator"])(healpixRaw),
      p = m(H),
      stream_ = p.stream;

  p.lobes = function (_) {
    return arguments.length ? m(H = +_) : H;
  };

  p.stream = function (stream) {
    var rotate = p.rotate(),
        rotateStream = stream_(stream),
        sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);

    rotateStream.sphere = function () {
      Object(d3_geo__WEBPACK_IMPORTED_MODULE_1__["geoStream"])(sphere(180 / H), sphereStream);
    };

    return rotateStream;
  };

  return p.scale(239.75);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/hill.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/hill.js ***!
  \****************************************************/
/*! exports provided: hillRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hillRaw", function() { return hillRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function hillRaw(K) {
  var L = 1 + K,
      sinBt = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(1 / L),
      Bt = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinBt),
      A = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / (B = _math__WEBPACK_IMPORTED_MODULE_1__["pi"] + 4 * Bt * L)),
      B,
      rho0 = 0.5 * A * (L + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(K * (2 + K))),
      K2 = K * K,
      L2 = L * L;

  function forward(lambda, phi) {
    var t = 1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        rho,
        omega;

    if (t && t < 2) {
      var theta = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - phi,
          i = 25,
          delta;

      do {
        var sinTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta),
            cosTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta),
            Bt_Bt1 = Bt + Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(sinTheta, L - cosTheta),
            C = 1 + L2 - 2 * L * cosTheta;
        theta -= delta = (theta - K2 * Bt - L * sinTheta + C * Bt_Bt1 - 0.5 * t * B) / (2 * L * sinTheta * Bt_Bt1);
      } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] && --i > 0);

      rho = A * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(C);
      omega = lambda * Bt_Bt1 / _math__WEBPACK_IMPORTED_MODULE_1__["pi"];
    } else {
      rho = A * (K + t);
      omega = lambda * Bt / _math__WEBPACK_IMPORTED_MODULE_1__["pi"];
    }

    return [rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(omega), rho0 - rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(omega)];
  }

  forward.invert = function (x, y) {
    var rho2 = x * x + (y -= rho0) * y,
        cosTheta = (1 + L2 - rho2 / (A * A)) / (2 * L),
        theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(cosTheta),
        sinTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta),
        Bt_Bt1 = Bt + Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(sinTheta, L - cosTheta);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(rho2)) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / Bt_Bt1, Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(1 - 2 * (theta - K2 * Bt - L * sinTheta + (1 + L2 - 2 * L * cosTheta) * Bt_Bt1) / B)];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var K = 1,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(hillRaw),
      p = m(K);

  p.ratio = function (_) {
    return arguments.length ? m(K = +_) : K;
  };

  return p.scale(167.774).center([0, 18.67]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/homolosine.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/homolosine.js ***!
  \**********************************************************/
/*! exports provided: homolosineRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "homolosineRaw", function() { return homolosineRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var _sinusoidal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sinusoidal */ "./node_modules/d3-geo-projection/src/sinusoidal.js");
/* harmony import */ var _sinuMollweide__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sinuMollweide */ "./node_modules/d3-geo-projection/src/sinuMollweide.js");





function homolosineRaw(lambda, phi) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) > _sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweidePhi"] ? (lambda = Object(_mollweide__WEBPACK_IMPORTED_MODULE_2__["mollweideRaw"])(lambda, phi), lambda[1] -= phi > 0 ? _sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweideY"] : -_sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweideY"], lambda) : Object(_sinusoidal__WEBPACK_IMPORTED_MODULE_3__["sinusoidalRaw"])(lambda, phi);
}

homolosineRaw.invert = function (x, y) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) > _sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweidePhi"] ? _mollweide__WEBPACK_IMPORTED_MODULE_2__["mollweideRaw"].invert(x, y + (y > 0 ? _sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweideY"] : -_sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweideY"])) : _sinusoidal__WEBPACK_IMPORTED_MODULE_3__["sinusoidalRaw"].invert(x, y);
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(homolosineRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/hyperelliptical.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/hyperelliptical.js ***!
  \***************************************************************/
/*! exports provided: hyperellipticalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hyperellipticalRaw", function() { return hyperellipticalRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _integrate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./integrate */ "./node_modules/d3-geo-projection/src/integrate.js");



function hyperellipticalRaw(alpha, k, gamma) {
  function elliptic(f) {
    return alpha + (1 - alpha) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["pow"])(1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["pow"])(f, k), 1 / k);
  }

  function z(f) {
    return Object(_integrate__WEBPACK_IMPORTED_MODULE_2__["integrate"])(elliptic, 0, f, 1e-4);
  }

  var G = 1 / z(1),
      n = 1000,
      m = (1 + 1e-8) * G,
      approx = [];

  for (var i = 0; i <= n; i++) {
    approx.push(z(i / n) * m);
  }

  function Y(sinphi) {
    var rmin = 0,
        rmax = n,
        r = n >> 1;

    do {
      if (approx[r] > sinphi) rmax = r;else rmin = r;
      r = rmin + rmax >> 1;
    } while (r > rmin);

    var u = approx[r + 1] - approx[r];
    if (u) u = (sinphi - approx[r + 1]) / u;
    return (r + 1 + u) / n;
  }

  var ratio = 2 * Y(1) / _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * G / gamma;

  var forward = function forward(lambda, phi) {
    var y = Y(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi))),
        x = elliptic(y) * lambda;
    y /= ratio;
    return [x, phi >= 0 ? y : -y];
  };

  forward.invert = function (x, y) {
    var phi;
    y *= ratio;
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < 1) phi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(z(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y)) * G);
    return [x / elliptic(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y)), phi];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var alpha = 0,
      k = 2.5,
      gamma = 1.183136,
      // affine = sqrt(2 * gamma / pi) = 0.8679
  m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(hyperellipticalRaw),
      p = m(alpha, k, gamma);

  p.alpha = function (_) {
    return arguments.length ? m(alpha = +_, k, gamma) : alpha;
  };

  p.k = function (_) {
    return arguments.length ? m(alpha, k = +_, gamma) : k;
  };

  p.gamma = function (_) {
    return arguments.length ? m(alpha, k, gamma = +_) : gamma;
  };

  return p.scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/integrate.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/integrate.js ***!
  \*********************************************************/
/*! exports provided: integrate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "integrate", function() { return integrate; });
// https://github.com/scijs/integrate-adaptive-simpson
// This algorithm adapted from pseudocode in:
// http://www.math.utk.edu/~ccollins/refs/Handouts/rich.pdf
function adsimp(f, a, b, fa, fm, fb, V0, tol, maxdepth, depth, state) {
  if (state.nanEncountered) {
    return NaN;
  }

  var h, f1, f2, sl, sr, s2, m, V1, V2, err;
  h = b - a;
  f1 = f(a + h * 0.25);
  f2 = f(b - h * 0.25); // Simple check for NaN:

  if (isNaN(f1)) {
    state.nanEncountered = true;
    return;
  } // Simple check for NaN:


  if (isNaN(f2)) {
    state.nanEncountered = true;
    return;
  }

  sl = h * (fa + 4 * f1 + fm) / 12;
  sr = h * (fm + 4 * f2 + fb) / 12;
  s2 = sl + sr;
  err = (s2 - V0) / 15;

  if (depth > maxdepth) {
    state.maxDepthCount++;
    return s2 + err;
  } else if (Math.abs(err) < tol) {
    return s2 + err;
  } else {
    m = a + h * 0.5;
    V1 = adsimp(f, a, m, fa, f1, fm, sl, tol * 0.5, maxdepth, depth + 1, state);

    if (isNaN(V1)) {
      state.nanEncountered = true;
      return NaN;
    }

    V2 = adsimp(f, m, b, fm, f2, fb, sr, tol * 0.5, maxdepth, depth + 1, state);

    if (isNaN(V2)) {
      state.nanEncountered = true;
      return NaN;
    }

    return V1 + V2;
  }
}

function integrate(f, a, b, tol, maxdepth) {
  var state = {
    maxDepthCount: 0,
    nanEncountered: false
  };

  if (tol === undefined) {
    tol = 1e-8;
  }

  if (maxdepth === undefined) {
    maxdepth = 20;
  }

  var fa = f(a);
  var fm = f(0.5 * (a + b));
  var fb = f(b);
  var V0 = (fa + 4 * fm + fb) * (b - a) / 6;
  var result = adsimp(f, a, b, fa, fm, fb, V0, tol, maxdepth, 1, state);
  /*
    if (state.maxDepthCount > 0 && console && console.warn) {
      console.warn('integrate-adaptive-simpson: Warning: maximum recursion depth (' + maxdepth + ') reached ' + state.maxDepthCount + ' times');
    }
  
    if (state.nanEncountered && console && console.warn) {
      console.warn('integrate-adaptive-simpson: Warning: NaN encountered. Halting early.');
    }
  */

  return result;
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/boggs.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/boggs.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _boggs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../boggs */ "./node_modules/d3-geo-projection/src/boggs.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 0], [-100, 90], [-40, 0]], [[-40, 0], [30, 90], [180, 0]]], [// southern hemisphere
[[-180, 0], [-160, -90], [-100, 0]], [[-100, 0], [-60, -90], [-20, 0]], [[-20, 0], [20, -90], [80, 0]], [[80, 0], [140, -90], [180, 0]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_boggs__WEBPACK_IMPORTED_MODULE_0__["boggsRaw"], lobes).scale(160.857);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/homolosine.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/homolosine.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _homolosine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../homolosine */ "./node_modules/d3-geo-projection/src/homolosine.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 0], [-100, 90], [-40, 0]], [[-40, 0], [30, 90], [180, 0]]], [// southern hemisphere
[[-180, 0], [-160, -90], [-100, 0]], [[-100, 0], [-60, -90], [-20, 0]], [[-20, 0], [20, -90], [80, 0]], [[80, 0], [140, -90], [180, 0]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_homolosine__WEBPACK_IMPORTED_MODULE_0__["homolosineRaw"], lobes).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/index.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");




function pointEqual(a, b) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(a[0] - b[0]) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] && Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(a[1] - b[1]) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
}

function interpolateLine(coordinates, m) {
  var i = -1,
      n = coordinates.length,
      p0 = coordinates[0],
      p1,
      dx,
      dy,
      resampled = [];

  while (++i < n) {
    p1 = coordinates[i];
    dx = (p1[0] - p0[0]) / m;
    dy = (p1[1] - p0[1]) / m;

    for (var j = 0; j < m; ++j) {
      resampled.push([p0[0] + j * dx, p0[1] + j * dy]);
    }

    p0 = p1;
  }

  resampled.push(p1);
  return resampled;
}

function interpolateSphere(lobes) {
  var coordinates = [],
      lobe,
      lambda0,
      phi0,
      phi1,
      lambda2,
      phi2,
      i,
      n = lobes[0].length; // Northern Hemisphere

  for (i = 0; i < n; ++i) {
    lobe = lobes[0][i];
    lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];
    lambda2 = lobe[2][0], phi2 = lobe[2][1];
    coordinates.push(interpolateLine([[lambda0 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi0 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda0 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi1 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda2 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi1 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda2 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi2 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]]], 30));
  } // Southern Hemisphere


  for (i = lobes[1].length - 1; i >= 0; --i) {
    lobe = lobes[1][i];
    lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];
    lambda2 = lobe[2][0], phi2 = lobe[2][1];
    coordinates.push(interpolateLine([[lambda2 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi2 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda2 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi1 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda0 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi1 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda0 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi0 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]]], 30));
  }

  return {
    type: "Polygon",
    coordinates: [Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["merge"])(coordinates)]
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (project, lobes) {
  var sphere, bounds;

  function forward(lambda, phi) {
    var sign = phi < 0 ? -1 : +1,
        lobe = lobes[+(phi < 0)];

    for (var i = 0, n = lobe.length - 1; i < n && lambda > lobe[i][2][0]; ++i) {
      ;
    }

    var p = project(lambda - lobe[i][1][0], phi);
    p[0] += project(lobe[i][1][0], sign * phi > sign * lobe[i][0][1] ? lobe[i][0][1] : phi)[0];
    return p;
  } // Assumes mutually exclusive bounding boxes for lobes.


  if (project.invert) forward.invert = function (x, y) {
    var bound = bounds[+(y < 0)],
        lobe = lobes[+(y < 0)];

    for (var i = 0, n = bound.length; i < n; ++i) {
      var b = bound[i];

      if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {
        var p = project.invert(x - project(lobe[i][1][0], 0)[0], y);
        p[0] += lobe[i][1][0];
        return pointEqual(forward(p[0], p[1]), [x, y]) ? p : null;
      }
    }
  };
  var p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_1__["geoProjection"])(forward),
      stream_ = p.stream;

  p.stream = function (stream) {
    var rotate = p.rotate(),
        rotateStream = stream_(stream),
        sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);

    rotateStream.sphere = function () {
      Object(d3_geo__WEBPACK_IMPORTED_MODULE_1__["geoStream"])(sphere, sphereStream);
    };

    return rotateStream;
  };

  p.lobes = function (_) {
    if (!arguments.length) return lobes.map(function (lobe) {
      return lobe.map(function (l) {
        return [[l[0][0] * _math__WEBPACK_IMPORTED_MODULE_2__["degrees"], l[0][1] * _math__WEBPACK_IMPORTED_MODULE_2__["degrees"]], [l[1][0] * _math__WEBPACK_IMPORTED_MODULE_2__["degrees"], l[1][1] * _math__WEBPACK_IMPORTED_MODULE_2__["degrees"]], [l[2][0] * _math__WEBPACK_IMPORTED_MODULE_2__["degrees"], l[2][1] * _math__WEBPACK_IMPORTED_MODULE_2__["degrees"]]];
      });
    });
    sphere = interpolateSphere(_);
    lobes = _.map(function (lobe) {
      return lobe.map(function (l) {
        return [[l[0][0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], l[0][1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"]], [l[1][0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], l[1][1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"]], [l[2][0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], l[2][1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"]]];
      });
    });
    bounds = lobes.map(function (lobe) {
      return lobe.map(function (l) {
        var x0 = project(l[0][0], l[0][1])[0],
            x1 = project(l[2][0], l[2][1])[0],
            y0 = project(l[1][0], l[0][1])[1],
            y1 = project(l[1][0], l[1][1])[1],
            t;
        if (y0 > y1) t = y0, y0 = y1, y1 = t;
        return [[x0, y0], [x1, y1]];
      });
    });
    return p;
  };

  if (lobes != null) p.lobes(lobes);
  return p;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/mollweide.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/mollweide.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 0], [-100, 90], [-40, 0]], [[-40, 0], [30, 90], [180, 0]]], [// southern hemisphere
[[-180, 0], [-160, -90], [-100, 0]], [[-100, 0], [-60, -90], [-20, 0]], [[-20, 0], [20, -90], [80, 0]], [[80, 0], [140, -90], [180, 0]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_mollweide__WEBPACK_IMPORTED_MODULE_0__["mollweideRaw"], lobes).scale(169.529);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 0], [-90, 90], [0, 0]], [[0, 0], [90, 90], [180, 0]]], [// southern hemisphere
[[-180, 0], [-90, -90], [0, 0]], [[0, 0], [90, -90], [180, 0]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_mollweide__WEBPACK_IMPORTED_MODULE_0__["mollweideRaw"], lobes).scale(169.529).rotate([20, 0]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sinuMollweide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sinuMollweide */ "./node_modules/d3-geo-projection/src/sinuMollweide.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 35], [-30, 90], [0, 35]], [[0, 35], [30, 90], [180, 35]]], [// southern hemisphere
[[-180, -10], [-102, -90], [-65, -10]], [[-65, -10], [5, -90], [77, -10]], [[77, -10], [103, -90], [180, -10]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_sinuMollweide__WEBPACK_IMPORTED_MODULE_0__["sinuMollweideRaw"], lobes).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/sinusoidal.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/sinusoidal.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sinusoidal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sinusoidal */ "./node_modules/d3-geo-projection/src/sinusoidal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 0], [-110, 90], [-40, 0]], [[-40, 0], [0, 90], [40, 0]], [[40, 0], [110, 90], [180, 0]]], [// southern hemisphere
[[-180, 0], [-110, -90], [-40, 0]], [[-40, 0], [0, -90], [40, 0]], [[40, 0], [110, -90], [180, 0]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_sinusoidal__WEBPACK_IMPORTED_MODULE_0__["sinusoidalRaw"], lobes).scale(152.63).rotate([-20, 0]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/kavrayskiy7.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/kavrayskiy7.js ***!
  \***********************************************************/
/*! exports provided: kavrayskiy7Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kavrayskiy7Raw", function() { return kavrayskiy7Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function kavrayskiy7Raw(lambda, phi) {
  return [3 / _math__WEBPACK_IMPORTED_MODULE_1__["tau"] * lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 3 - phi * phi), phi];
}

kavrayskiy7Raw.invert = function (x, y) {
  return [_math__WEBPACK_IMPORTED_MODULE_1__["tau"] / 3 * x / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 3 - y * y), y];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(kavrayskiy7Raw).scale(158.837);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/lagrange.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/lagrange.js ***!
  \********************************************************/
/*! exports provided: lagrangeRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lagrangeRaw", function() { return lagrangeRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function lagrangeRaw(n) {
  function forward(lambda, phi) {
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [0, phi < 0 ? -2 : 2];
    var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        v = Object(_math__WEBPACK_IMPORTED_MODULE_1__["pow"])((1 + sinPhi) / (1 - sinPhi), n / 2),
        c = 0.5 * (v + 1 / v) + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda *= n);
    return [2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) / c, (v - 1 / v) / c];
  }

  forward.invert = function (x, y) {
    var y0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y);
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y0 - 2) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return x ? null : [0, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]];
    if (y0 > 2) return null;
    x /= 2, y /= 2;
    var x2 = x * x,
        y2 = y * y,
        t = 2 * y / (1 + x2 + y2); // tanh(nPhi)

    t = Object(_math__WEBPACK_IMPORTED_MODULE_1__["pow"])((1 + t) / (1 - t), 1 / n);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(2 * x, 1 - x2 - y2) / n, Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((t - 1) / (t + 1))];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var n = 0.5,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(lagrangeRaw),
      p = m(n);

  p.spacing = function (_) {
    return arguments.length ? m(n = +_) : n;
  };

  return p.scale(124.75);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/larrivee.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/larrivee.js ***!
  \********************************************************/
/*! exports provided: larriveeRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "larriveeRaw", function() { return larriveeRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var pi_sqrt2 = _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"];
function larriveeRaw(lambda, phi) {
  return [lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi))) / 2, phi / (Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi / 2) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda / 6))];
}

larriveeRaw.invert = function (x, y) {
  var x0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x),
      y0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y),
      lambda = _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"],
      phi = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"];
  if (y0 < pi_sqrt2) phi *= y0 / pi_sqrt2;else lambda += 6 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(pi_sqrt2 / y0);

  for (var i = 0; i < 25; i++) {
    var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        sqrtcosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)),
        sinPhi_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi / 2),
        cosPhi_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi / 2),
        sinLambda_6 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda / 6),
        cosLambda_6 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda / 6),
        f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x0,
        f1 = phi / (cosPhi_2 * cosLambda_6) - y0,
        df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0,
        df0dLambda = 0.5 * (1 + sqrtcosPhi),
        df1dPhi = (1 + 0.5 * phi * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6),
        df1dLambda = phi / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6),
        denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda,
        dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom,
        dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
    phi -= dPhi;
    lambda -= dLambda;
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dPhi) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dLambda) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) break;
  }

  return [x < 0 ? -lambda : lambda, y < 0 ? -phi : phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(larriveeRaw).scale(97.2672);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/laskowski.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/laskowski.js ***!
  \*********************************************************/
/*! exports provided: laskowskiRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "laskowskiRaw", function() { return laskowskiRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function laskowskiRaw(lambda, phi) {
  var lambda2 = lambda * lambda,
      phi2 = phi * phi;
  return [lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)), phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 0.000199025) + phi2 * (0.0998909 + phi2 * -0.0491032))];
}

laskowskiRaw.invert = function (x, y) {
  var lambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"],
      phi = y / 2,
      i = 50;

  do {
    var lambda2 = lambda * lambda,
        phi2 = phi * phi,
        lambdaPhi = lambda * phi,
        fx = lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)) - x,
        fy = phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 0.000199025) + phi2 * (0.0998909 + phi2 * -0.0491032)) - y,
        deltaxDeltaLambda = 0.975534 - phi2 * (0.119161 + 3 * lambda2 * 0.0143059 + phi2 * 0.0547009),
        deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi2 + 2 * 0.0143059 * lambda2),
        deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 0.000199025 * lambda2 + 2 * -0.02855 * phi2),
        deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 0.000199025 * lambda2) + phi2 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi2),
        denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda,
        deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator,
        deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda, phi -= deltaPhi;
  } while ((Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(deltaLambda) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(deltaPhi) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) && --i > 0);

  return i && [lambda, phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(laskowskiRaw).scale(139.98);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/littrow.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/littrow.js ***!
  \*******************************************************/
/*! exports provided: littrowRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "littrowRaw", function() { return littrowRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function littrowRaw(lambda, phi) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi), Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda)];
}

littrowRaw.invert = function (x, y) {
  var x2 = x * x,
      y2 = y * y,
      y2_1 = y2 + 1,
      x2_y2_1 = x2 + y2_1,
      cosPhi = x ? _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])((x2_y2_1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x2_y2_1 * x2_y2_1 - 4 * x2)) / x2) : 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(y2_1);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x * cosPhi), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(cosPhi)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(littrowRaw).scale(144.049).clipAngle(90 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/loximuthal.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/loximuthal.js ***!
  \**********************************************************/
/*! exports provided: loximuthalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loximuthalRaw", function() { return loximuthalRaw; });
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function loximuthalRaw(phi0) {
  var cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0),
      tanPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(_math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] + phi0 / 2);

  function forward(lambda, phi) {
    var y = phi - phi0,
        x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? lambda * cosPhi0 : Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x = _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] + phi / 2) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? 0 : lambda * y / Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(x) / tanPhi0);
    return [x, y];
  }

  forward.invert = function (x, y) {
    var lambda,
        phi = y + phi0;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? x / cosPhi0 : Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda = _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] + phi / 2) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? 0 : x * Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(lambda) / tanPhi0) / y, phi];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_0__["default"])(loximuthalRaw).parallel(40).scale(158.837);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/math.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/math.js ***!
  \****************************************************/
/*! exports provided: abs, atan, atan2, ceil, cos, exp, floor, log, max, min, pow, round, sign, sin, tan, epsilon, epsilon2, pi, halfPi, quarterPi, sqrt1_2, sqrt2, sqrtPi, tau, degrees, radians, sinci, asin, acos, sqrt, tanh, sinh, cosh, arsinh, arcosh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon2", function() { return epsilon2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pi", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPi", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quarterPi", function() { return quarterPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt1_2", function() { return sqrt1_2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt2", function() { return sqrt2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrtPi", function() { return sqrtPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tau", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinci", function() { return sinci; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return tanh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return sinh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return cosh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arsinh", function() { return arsinh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arcosh", function() { return arcosh; });
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var ceil = Math.ceil;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function (x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sin = Math.sin;
var tan = Math.tan;
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}
function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}
function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}
function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}
function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}
function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}
function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/miller.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/miller.js ***!
  \******************************************************/
/*! exports provided: millerRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "millerRaw", function() { return millerRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function millerRaw(lambda, phi) {
  return [lambda, 1.25 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(_math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] + 0.4 * phi))];
}

millerRaw.invert = function (x, y) {
  return [x, 2.5 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["exp"])(0.8 * y)) - 0.625 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(millerRaw).scale(108.318);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/modifiedStereographic.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/modifiedStereographic.js ***!
  \*********************************************************************/
/*! exports provided: modifiedStereographicRaw, modifiedStereographicAlaska, modifiedStereographicGs48, modifiedStereographicGs50, modifiedStereographicMiller, modifiedStereographicLee, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicRaw", function() { return modifiedStereographicRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicAlaska", function() { return modifiedStereographicAlaska; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicGs48", function() { return modifiedStereographicGs48; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicGs50", function() { return modifiedStereographicGs50; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicMiller", function() { return modifiedStereographicMiller; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicLee", function() { return modifiedStereographicLee; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return modifiedStereographic; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function modifiedStereographicRaw(C) {
  var m = C.length - 1;

  function forward(lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        k = 2 / (1 + cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda)),
        zr = k * cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda),
        zi = k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        i = m,
        w = C[i],
        ar = w[0],
        ai = w[1],
        t;

    while (--i >= 0) {
      w = C[i];
      ar = w[0] + zr * (t = ar) - zi * ai;
      ai = w[1] + zr * ai + zi * t;
    }

    ar = zr * (t = ar) - zi * ai;
    ai = zr * ai + zi * t;
    return [ar, ai];
  }

  forward.invert = function (x, y) {
    var i = 20,
        zr = x,
        zi = y;

    do {
      var j = m,
          w = C[j],
          ar = w[0],
          ai = w[1],
          br = 0,
          bi = 0,
          t;

      while (--j >= 0) {
        w = C[j];
        br = ar + zr * (t = br) - zi * bi;
        bi = ai + zr * bi + zi * t;
        ar = w[0] + zr * (t = ar) - zi * ai;
        ai = w[1] + zr * ai + zi * t;
      }

      br = ar + zr * (t = br) - zi * bi;
      bi = ai + zr * bi + zi * t;
      ar = zr * (t = ar) - zi * ai - x;
      ai = zr * ai + zi * t - y;
      var denominator = br * br + bi * bi,
          deltar,
          deltai;
      zr -= deltar = (ar * br + ai * bi) / denominator;
      zi -= deltai = (ai * br - ar * bi) / denominator;
    } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(deltar) + Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(deltai) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] * _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

    if (i) {
      var rho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(zr * zr + zi * zi),
          c = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(rho * 0.5),
          sinc = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(c);
      return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(zr * sinc, rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(c)), rho ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(zi * sinc / rho) : 0];
    }
  };

  return forward;
}
var alaska = [[0.9972523, 0], [0.0052513, -0.0041175], [0.0074606, 0.0048125], [-0.0153783, -0.1968253], [0.0636871, -0.1408027], [0.3660976, -0.2937382]],
    gs48 = [[0.98879, 0], [0, 0], [-0.050909, 0], [0, 0], [0.075528, 0]],
    gs50 = [[0.9842990, 0], [0.0211642, 0.0037608], [-0.1036018, -0.0575102], [-0.0329095, -0.0320119], [0.0499471, 0.1223335], [0.0260460, 0.0899805], [0.0007388, -0.1435792], [0.0075848, -0.1334108], [-0.0216473, 0.0776645], [-0.0225161, 0.0853673]],
    miller = [[0.9245, 0], [0, 0], [0.01943, 0]],
    lee = [[0.721316, 0], [0, 0], [-0.00881625, -0.00617325]];
function modifiedStereographicAlaska() {
  return modifiedStereographic(alaska, [152, -64]).scale(1500).center([-160.908, 62.4864]).clipAngle(25);
}
function modifiedStereographicGs48() {
  return modifiedStereographic(gs48, [95, -38]).scale(1000).clipAngle(55).center([-96.5563, 38.8675]);
}
function modifiedStereographicGs50() {
  return modifiedStereographic(gs50, [120, -45]).scale(359.513).clipAngle(55).center([-117.474, 53.0628]);
}
function modifiedStereographicMiller() {
  return modifiedStereographic(miller, [-20, -18]).scale(209.091).center([20, 16.7214]).clipAngle(82);
}
function modifiedStereographicLee() {
  return modifiedStereographic(lee, [165, 10]).scale(250).clipAngle(130).center([-165, -10]);
}
function modifiedStereographic(coefficients, rotate) {
  var p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(modifiedStereographicRaw(coefficients)).rotate(rotate).clipAngle(90),
      r = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoRotation"])(rotate),
      center = p.center;
  delete p.rotate;

  p.center = function (_) {
    return arguments.length ? center(r(_)) : r.invert(center());
  };

  return p;
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/mollweide.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/mollweide.js ***!
  \*********************************************************/
/*! exports provided: mollweideBromleyTheta, mollweideBromleyRaw, mollweideRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mollweideBromleyTheta", function() { return mollweideBromleyTheta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mollweideBromleyRaw", function() { return mollweideBromleyRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mollweideRaw", function() { return mollweideRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function mollweideBromleyTheta(cp, phi) {
  var cpsinPhi = cp * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      i = 30,
      delta;

  do {
    phi -= delta = (phi + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) - cpsinPhi) / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  return phi / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi) {
    return [cx * lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi = mollweideBromleyTheta(cp, phi)), cy * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
  }

  forward.invert = function (x, y) {
    return y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y / cy), [x / (cx * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((2 * y + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * y)) / cp)];
  };

  return forward;
}
var mollweideRaw = mollweideBromleyRaw(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"] / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"], _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"], _math__WEBPACK_IMPORTED_MODULE_1__["pi"]);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(mollweideRaw).scale(169.529);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js ***!
  \********************************************************************/
/*! exports provided: mtFlatPolarParabolicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mtFlatPolarParabolicRaw", function() { return mtFlatPolarParabolicRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var sqrt6 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(6),
    sqrt7 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(7);
function mtFlatPolarParabolicRaw(lambda, phi) {
  var theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(7 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) / (3 * sqrt6));
  return [sqrt6 * lambda * (2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(2 * theta / 3) - 1) / sqrt7, 9 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta / 3) / sqrt7];
}

mtFlatPolarParabolicRaw.invert = function (x, y) {
  var theta = 3 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y * sqrt7 / 9);
  return [x * sqrt7 / (sqrt6 * (2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(2 * theta / 3) - 1)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta) * 3 * sqrt6 / 7)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(mtFlatPolarParabolicRaw).scale(164.859);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js ***!
  \******************************************************************/
/*! exports provided: mtFlatPolarQuarticRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mtFlatPolarQuarticRaw", function() { return mtFlatPolarQuarticRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function mtFlatPolarQuarticRaw(lambda, phi) {
  var k = (1 + _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"]) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      theta = phi;

  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta / 2) + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta) - k) / (0.5 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta / 2) + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta));
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) break;
  }

  return [lambda * (1 + 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta / 2)) / (3 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"]), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta / 2) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"])];
}

mtFlatPolarQuarticRaw.invert = function (x, y) {
  var sinTheta_2 = y * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"]) / (2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3)),
      theta = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinTheta_2);
  return [3 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"] * x / (1 + 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta / 2)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((sinTheta_2 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta)) / (1 + _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"]))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(mtFlatPolarQuarticRaw).scale(188.209);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js ***!
  \*********************************************************************/
/*! exports provided: mtFlatPolarSinusoidalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mtFlatPolarSinusoidalRaw", function() { return mtFlatPolarSinusoidalRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function mtFlatPolarSinusoidalRaw(lambda, phi) {
  var A = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(6 / (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])),
      k = (1 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      theta = phi / 2;

  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (theta / 2 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta) - k) / (0.5 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta));
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) break;
  }

  return [A * (0.5 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta)) * lambda / 1.5, A * theta];
}

mtFlatPolarSinusoidalRaw.invert = function (x, y) {
  var A = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(6 / (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])),
      theta = y / A;
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(theta) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) theta = theta < 0 ? -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] : _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"];
  return [1.5 * x / (A * (0.5 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta))), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((theta / 2 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta)) / (1 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(mtFlatPolarSinusoidalRaw).scale(166.518);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/naturalEarth2.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/naturalEarth2.js ***!
  \*************************************************************/
/*! exports provided: naturalEarth2Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "naturalEarth2Raw", function() { return naturalEarth2Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function naturalEarth2Raw(lambda, phi) {
  var phi2 = phi * phi,
      phi4 = phi2 * phi2,
      phi6 = phi2 * phi4;
  return [lambda * (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 0.00331 * phi6)), phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 0.00396 * phi4))];
}

naturalEarth2Raw.invert = function (x, y) {
  var phi = y,
      i = 25,
      delta,
      phi2,
      phi4,
      phi6;

  do {
    phi2 = phi * phi;
    phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 0.00396 * phi4)) - y) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi2 + 13 * -0.00396 * phi4));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] && --i > 0);

  phi2 = phi * phi;
  phi4 = phi2 * phi2;
  phi6 = phi2 * phi4;
  return [x / (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 0.00331 * phi6)), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(naturalEarth2Raw).scale(175.295);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/nellHammer.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/nellHammer.js ***!
  \**********************************************************/
/*! exports provided: nellHammerRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nellHammerRaw", function() { return nellHammerRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function nellHammerRaw(lambda, phi) {
  return [lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)) / 2, 2 * (phi - Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi / 2))];
}

nellHammerRaw.invert = function (x, y) {
  var p = y / 2;

  for (var i = 0, delta = Infinity; i < 10 && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; ++i) {
    var c = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y / 2);
    y -= delta = (y - Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(y / 2) - p) / (1 - 0.5 / (c * c));
  }

  return [2 * x / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y)), y];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(nellHammerRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/noop.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/noop.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/parallel1.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/parallel1.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = (function (projectAt) {
  var phi0 = 0,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(projectAt),
      p = m(phi0);

  p.parallel = function (_) {
    return arguments.length ? m(phi0 = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]) : phi0 * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
  };

  return p;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/patterson.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/patterson.js ***!
  \*********************************************************/
/*! exports provided: pattersonRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pattersonRaw", function() { return pattersonRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");

 // Based on Java implementation by Bojan Savric.
// https://github.com/OSUCartography/JMapProjLib/blob/master/src/com/jhlabs/map/proj/PattersonProjection.java

var pattersonK1 = 1.0148,
    pattersonK2 = 0.23185,
    pattersonK3 = -0.14499,
    pattersonK4 = 0.02406,
    pattersonC1 = pattersonK1,
    pattersonC2 = 5 * pattersonK2,
    pattersonC3 = 7 * pattersonK3,
    pattersonC4 = 9 * pattersonK4,
    pattersonYmax = 1.790857183;
function pattersonRaw(lambda, phi) {
  var phi2 = phi * phi;
  return [lambda, phi * (pattersonK1 + phi2 * phi2 * (pattersonK2 + phi2 * (pattersonK3 + pattersonK4 * phi2)))];
}

pattersonRaw.invert = function (x, y) {
  if (y > pattersonYmax) y = pattersonYmax;else if (y < -pattersonYmax) y = -pattersonYmax;
  var yc = y,
      delta;

  do {
    // Newton-Raphson
    var y2 = yc * yc;
    yc -= delta = (yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]);

  return [x, yc];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(pattersonRaw).scale(139.319);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyconic.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyconic.js ***!
  \*********************************************************/
/*! exports provided: polyconicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyconicRaw", function() { return polyconicRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function polyconicRaw(lambda, phi) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [lambda, 0];
  var tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi),
      k = lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(k) / tanPhi, phi + (1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(k)) / tanPhi];
}

polyconicRaw.invert = function (x, y) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [x, 0];
  var k = x * x + y * y,
      phi = y * 0.5,
      i = 10,
      delta;

  do {
    var tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi),
        secPhi = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        j = k - 2 * y * phi + phi * phi;
    phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi);
  return [(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi + 1 / tanPhi) ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x * tanPhi) : Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x * tanPhi)) + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"])) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(polyconicRaw).scale(103.74);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/butterfly.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/butterfly.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/polyhedral/index.js");
/* harmony import */ var _octahedron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./octahedron */ "./node_modules/d3-geo-projection/src/polyhedral/octahedron.js");




/* harmony default export */ __webpack_exports__["default"] = (function (faceProjection) {
  faceProjection = faceProjection || function (face) {
    var c = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCentroid"])({
      type: "MultiPoint",
      coordinates: face
    });
    return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoGnomonic"])().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);
  };

  var faces = _octahedron__WEBPACK_IMPORTED_MODULE_3__["default"].map(function (face) {
    return {
      face: face,
      project: faceProjection(face)
    };
  });
  [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {
    var node = faces[d];
    node && (node.children || (node.children = [])).push(faces[i]);
  });
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(faces[0], function (lambda, phi) {
    return faces[lambda < -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];
  }).angle(-30).scale(101.858).center([0, 45]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/collignon.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/collignon.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _collignon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collignon */ "./node_modules/d3-geo-projection/src/collignon.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/polyhedral/index.js");
/* harmony import */ var _octahedron__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./octahedron */ "./node_modules/d3-geo-projection/src/polyhedral/octahedron.js");





var kx = 2 / Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(3);

function collignonK(a, b) {
  var p = Object(_collignon__WEBPACK_IMPORTED_MODULE_1__["collignonRaw"])(a, b);
  return [p[0] * kx, p[1]];
}

collignonK.invert = function (x, y) {
  return _collignon__WEBPACK_IMPORTED_MODULE_1__["collignonRaw"].invert(x / kx, y);
};

/* harmony default export */ __webpack_exports__["default"] = (function (faceProjection) {
  faceProjection = faceProjection || function (face) {
    var c = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCentroid"])({
      type: "MultiPoint",
      coordinates: face
    });
    return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(collignonK).translate([0, 0]).scale(1).rotate(c[1] > 0 ? [-c[0], 0] : [180 - c[0], 180]);
  };

  var faces = _octahedron__WEBPACK_IMPORTED_MODULE_4__["default"].map(function (face) {
    return {
      face: face,
      project: faceProjection(face)
    };
  });
  [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {
    var node = faces[d];
    node && (node.children || (node.children = [])).push(faces[i]);
  });
  return Object(_index__WEBPACK_IMPORTED_MODULE_3__["default"])(faces[0], function (lambda, phi) {
    return faces[lambda < -_math__WEBPACK_IMPORTED_MODULE_2__["pi"] / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < _math__WEBPACK_IMPORTED_MODULE_2__["pi"] / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];
  }).angle(-30).scale(121.906).center([0, 48.5904]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/index.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matrix */ "./node_modules/d3-geo-projection/src/polyhedral/matrix.js");


 // Creates a polyhedral projection.
//  * root: a spanning tree of polygon faces.  Nodes are automatically
//    augmented with a transform matrix.
//  * face: a function that returns the appropriate node for a given {lambda, phi}
//    point (radians).
//  * r: rotation angle for root face [deprecated by .angle()].

/* harmony default export */ __webpack_exports__["default"] = (function (root, face, r) {
  recurse(root, {
    transform: null
  });

  function recurse(node, parent) {
    node.edges = faceEdges(node.face); // Find shared edge.

    if (parent.face) {
      var shared = node.shared = sharedEdge(node.face, parent.face),
          m = Object(_matrix__WEBPACK_IMPORTED_MODULE_2__["default"])(shared.map(parent.project), shared.map(node.project));
      node.transform = parent.transform ? Object(_matrix__WEBPACK_IMPORTED_MODULE_2__["multiply"])(parent.transform, m) : m; // Replace shared edge in parent edges array.

      var edges = parent.edges;

      for (var i = 0, n = edges.length; i < n; ++i) {
        if (pointEqual(shared[0], edges[i][1]) && pointEqual(shared[1], edges[i][0])) edges[i] = node;
        if (pointEqual(shared[0], edges[i][0]) && pointEqual(shared[1], edges[i][1])) edges[i] = node;
      }

      edges = node.edges;

      for (i = 0, n = edges.length; i < n; ++i) {
        if (pointEqual(shared[0], edges[i][0]) && pointEqual(shared[1], edges[i][1])) edges[i] = parent;
        if (pointEqual(shared[0], edges[i][1]) && pointEqual(shared[1], edges[i][0])) edges[i] = parent;
      }
    } else {
      node.transform = parent.transform;
    }

    if (node.children) {
      node.children.forEach(function (child) {
        recurse(child, node);
      });
    }

    return node;
  }

  function forward(lambda, phi) {
    var node = face(lambda, phi),
        point = node.project([lambda * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], phi * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]]),
        t;

    if (t = node.transform) {
      return [t[0] * point[0] + t[1] * point[1] + t[2], -(t[3] * point[0] + t[4] * point[1] + t[5])];
    }

    point[1] = -point[1];
    return point;
  } // Naive inverse!  A faster solution would use bounding boxes, or even a
  // polygonal quadtree.


  if (hasInverse(root)) forward.invert = function (x, y) {
    var coordinates = faceInvert(root, [x, -y]);
    return coordinates && (coordinates[0] *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates);
  };

  function faceInvert(node, coordinates) {
    var invert = node.project.invert,
        t = node.transform,
        point = coordinates;

    if (t) {
      t = Object(_matrix__WEBPACK_IMPORTED_MODULE_2__["inverse"])(t);
      point = [t[0] * point[0] + t[1] * point[1] + t[2], t[3] * point[0] + t[4] * point[1] + t[5]];
    }

    if (invert && node === faceDegrees(p = invert(point))) return p;
    var p,
        children = node.children;

    for (var i = 0, n = children && children.length; i < n; ++i) {
      if (p = faceInvert(children[i], coordinates)) return p;
    }
  }

  function faceDegrees(coordinates) {
    return face(coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
  }

  var proj = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(forward),
      stream_ = proj.stream;

  proj.stream = function (stream) {
    var rotate = proj.rotate(),
        rotateStream = stream_(stream),
        sphereStream = (proj.rotate([0, 0]), stream_(stream));
    proj.rotate(rotate);

    rotateStream.sphere = function () {
      sphereStream.polygonStart();
      sphereStream.lineStart();
      outline(sphereStream, root);
      sphereStream.lineEnd();
      sphereStream.polygonEnd();
    };

    return rotateStream;
  };

  return proj.angle(r == null ? -30 : r * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);
});

function outline(stream, node, parent) {
  var point,
      edges = node.edges,
      n = edges.length,
      edge,
      multiPoint = {
    type: "MultiPoint",
    coordinates: node.face
  },
      notPoles = node.face.filter(function (d) {
    return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(d[1]) !== 90;
  }),
      b = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoBounds"])({
    type: "MultiPoint",
    coordinates: notPoles
  }),
      inside = false,
      j = -1,
      dx = b[1][0] - b[0][0]; // TODO

  var c = dx === 180 || dx === 360 ? [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2] : Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCentroid"])(multiPoint); // First find the shared edge…

  if (parent) while (++j < n) {
    if (edges[j] === parent) break;
  }
  ++j;

  for (var i = 0; i < n; ++i) {
    edge = edges[(i + j) % n];

    if (Array.isArray(edge)) {
      if (!inside) {
        stream.point((point = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoInterpolate"])(edge[0], c)(_math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]))[0], point[1]);
        inside = true;
      }

      stream.point((point = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoInterpolate"])(edge[1], c)(_math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]))[0], point[1]);
    } else {
      inside = false;
      if (edge !== parent) outline(stream, edge, node);
    }
  }
} // Tests equality of two spherical points.


function pointEqual(a, b) {
  return a && b && a[0] === b[0] && a[1] === b[1];
} // Finds a shared edge given two clockwise polygons.


function sharedEdge(a, b) {
  var x,
      y,
      n = a.length,
      found = null;

  for (var i = 0; i < n; ++i) {
    x = a[i];

    for (var j = b.length; --j >= 0;) {
      y = b[j];

      if (x[0] === y[0] && x[1] === y[1]) {
        if (found) return [found, x];
        found = x;
      }
    }
  }
} // Converts an array of n face vertices to an array of n + 1 edges.


function faceEdges(face) {
  var n = face.length,
      edges = [];

  for (var a = face[n - 1], i = 0; i < n; ++i) {
    edges.push([a, a = face[i]]);
  }

  return edges;
}

function hasInverse(node) {
  return node.project.invert || node.children && node.children.some(hasInverse);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/matrix.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/matrix.js ***!
  \*****************************************************************/
/*! exports provided: default, inverse, multiply */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");
 // Note: 6-element arrays are used to denote the 3x3 affine transform matrix:
// [a, b, c,
//  d, e, f,
//  0, 0, 1] - this redundant row is left out.
// Transform matrix for [a0, a1] -> [b0, b1].

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var u = subtract(a[1], a[0]),
      v = subtract(b[1], b[0]),
      phi = angle(u, v),
      s = length(u) / length(v);
  return multiply([1, 0, a[0][0], 0, 1, a[0][1]], multiply([s, 0, 0, 0, s, 0], multiply([Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi), 0, -Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi), Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi), 0], [1, 0, -b[0][0], 0, 1, -b[0][1]])));
}); // Inverts a transform matrix.

function inverse(m) {
  var k = 1 / (m[0] * m[4] - m[1] * m[3]);
  return [k * m[4], -k * m[1], k * (m[1] * m[5] - m[2] * m[4]), -k * m[3], k * m[0], k * (m[2] * m[3] - m[0] * m[5])];
} // Multiplies two 3x2 matrices.

function multiply(a, b) {
  return [a[0] * b[0] + a[1] * b[3], a[0] * b[1] + a[1] * b[4], a[0] * b[2] + a[1] * b[5] + a[2], a[3] * b[0] + a[4] * b[3], a[3] * b[1] + a[4] * b[4], a[3] * b[2] + a[4] * b[5] + a[5]];
} // Subtracts 2D vectors.

function subtract(a, b) {
  return [a[0] - b[0], a[1] - b[1]];
} // Magnitude of a 2D vector.


function length(v) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(v[0] * v[0] + v[1] * v[1]);
} // Angle between two 2D vectors.


function angle(a, b) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(a[0] * b[1] - a[1] * b[0], a[0] * b[0] + a[1] * b[1]);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/octahedron.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/octahedron.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// TODO generate on-the-fly to avoid external modification.
var octahedron = [[0, 90], [-90, 0], [0, 0], [90, 0], [180, 0], [0, -90]];
/* harmony default export */ __webpack_exports__["default"] = ([[0, 2, 1], [0, 3, 2], [5, 1, 2], [5, 2, 3], [0, 1, 4], [0, 4, 3], [5, 4, 1], [5, 3, 4]].map(function (face) {
  return face.map(function (i) {
    return octahedron[i];
  });
}));

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/waterman.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/waterman.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/polyhedral/index.js");
/* harmony import */ var _octahedron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./octahedron */ "./node_modules/d3-geo-projection/src/polyhedral/octahedron.js");




/* harmony default export */ __webpack_exports__["default"] = (function (faceProjection) {
  faceProjection = faceProjection || function (face) {
    var c = face.length === 6 ? Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCentroid"])({
      type: "MultiPoint",
      coordinates: face
    }) : face[0];
    return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoGnomonic"])().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);
  };

  var w5 = _octahedron__WEBPACK_IMPORTED_MODULE_3__["default"].map(function (face) {
    var xyz = face.map(cartesian),
        n = xyz.length,
        a = xyz[n - 1],
        b,
        hexagon = [];

    for (var i = 0; i < n; ++i) {
      b = xyz[i];
      hexagon.push(spherical([a[0] * 0.9486832980505138 + b[0] * 0.31622776601683794, a[1] * 0.9486832980505138 + b[1] * 0.31622776601683794, a[2] * 0.9486832980505138 + b[2] * 0.31622776601683794]), spherical([b[0] * 0.9486832980505138 + a[0] * 0.31622776601683794, b[1] * 0.9486832980505138 + a[1] * 0.31622776601683794, b[2] * 0.9486832980505138 + a[2] * 0.31622776601683794]));
      a = b;
    }

    return hexagon;
  });
  var cornerNormals = [];
  var parents = [-1, 0, 0, 1, 0, 1, 4, 5];
  w5.forEach(function (hexagon, j) {
    var face = _octahedron__WEBPACK_IMPORTED_MODULE_3__["default"][j],
        n = face.length,
        normals = cornerNormals[j] = [];

    for (var i = 0; i < n; ++i) {
      w5.push([face[i], hexagon[(i * 2 + 2) % (2 * n)], hexagon[(i * 2 + 1) % (2 * n)]]);
      parents.push(j);
      normals.push(cross(cartesian(hexagon[(i * 2 + 2) % (2 * n)]), cartesian(hexagon[(i * 2 + 1) % (2 * n)])));
    }
  });
  var faces = w5.map(function (face) {
    return {
      project: faceProjection(face),
      face: face
    };
  });
  parents.forEach(function (d, i) {
    var parent = faces[d];
    parent && (parent.children || (parent.children = [])).push(faces[i]);
  });

  function face(lambda, phi) {
    var cosphi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        p = [cosphi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda), cosphi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
    var hexagon = lambda < -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5;
    var n = cornerNormals[hexagon];
    return faces[dot(n[0], p) < 0 ? 8 + 3 * hexagon : dot(n[1], p) < 0 ? 8 + 3 * hexagon + 1 : dot(n[2], p) < 0 ? 8 + 3 * hexagon + 2 : hexagon];
  }

  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(faces[0], face).angle(-30).scale(110.625).center([0, 45]);
});

function dot(a, b) {
  for (var i = 0, n = a.length, s = 0; i < n; ++i) {
    s += a[i] * b[i];
  }

  return s;
}

function cross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
} // Converts 3D Cartesian to spherical coordinates (degrees).


function spherical(cartesian) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(cartesian[1], cartesian[0]) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["max"])(-1, Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(1, cartesian[2]))) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]];
} // Converts spherical coordinates (degrees) to 3D Cartesian.


function cartesian(coordinates) {
  var lambda = coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"],
      phi = coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"],
      cosphi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi);
  return [cosphi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda), cosphi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/project/clockwise.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/project/clockwise.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (ring) {
  if ((n = ring.length) < 4) return false;
  var i = 0,
      n,
      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];

  while (++i < n) {
    area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  }

  return area <= 0;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/project/contains.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/project/contains.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (ring, point) {
  var x = point[0],
      y = point[1],
      contains = false;

  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i],
        xi = pi[0],
        yi = pi[1],
        pj = ring[j],
        xj = pj[0],
        yj = pj[1];
    if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains;
  }

  return contains;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/project/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/project/index.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo-projection/src/noop.js");
/* harmony import */ var _clockwise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./clockwise */ "./node_modules/d3-geo-projection/src/project/clockwise.js");
/* harmony import */ var _contains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contains */ "./node_modules/d3-geo-projection/src/project/contains.js");




/* harmony default export */ __webpack_exports__["default"] = (function (object, projection) {
  var stream = projection.stream,
      project;
  if (!stream) throw new Error("invalid projection");

  switch (object && object.type) {
    case "Feature":
      project = projectFeature;
      break;

    case "FeatureCollection":
      project = projectFeatureCollection;
      break;

    default:
      project = projectGeometry;
      break;
  }

  return project(object, stream);
});

function projectFeatureCollection(o, stream) {
  return {
    type: "FeatureCollection",
    features: o.features.map(function (f) {
      return projectFeature(f, stream);
    })
  };
}

function projectFeature(o, stream) {
  return {
    type: "Feature",
    id: o.id,
    properties: o.properties,
    geometry: projectGeometry(o.geometry, stream)
  };
}

function projectGeometryCollection(o, stream) {
  return {
    type: "GeometryCollection",
    geometries: o.geometries.map(function (o) {
      return projectGeometry(o, stream);
    })
  };
}

function projectGeometry(o, stream) {
  if (!o) return null;
  if (o.type === "GeometryCollection") return projectGeometryCollection(o, stream);
  var sink;

  switch (o.type) {
    case "Point":
      sink = sinkPoint;
      break;

    case "MultiPoint":
      sink = sinkPoint;
      break;

    case "LineString":
      sink = sinkLine;
      break;

    case "MultiLineString":
      sink = sinkLine;
      break;

    case "Polygon":
      sink = sinkPolygon;
      break;

    case "MultiPolygon":
      sink = sinkPolygon;
      break;

    case "Sphere":
      sink = sinkPolygon;
      break;

    default:
      return null;
  }

  Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoStream"])(o, stream(sink));
  return sink.result();
}

var points = [],
    lines = [];
var sinkPoint = {
  point: function point(x, y) {
    points.push([x, y]);
  },
  result: function result() {
    var result = !points.length ? null : points.length < 2 ? {
      type: "Point",
      coordinates: points[0]
    } : {
      type: "MultiPoint",
      coordinates: points
    };
    points = [];
    return result;
  }
};
var sinkLine = {
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  point: function point(x, y) {
    points.push([x, y]);
  },
  lineEnd: function lineEnd() {
    if (points.length) lines.push(points), points = [];
  },
  result: function result() {
    var result = !lines.length ? null : lines.length < 2 ? {
      type: "LineString",
      coordinates: lines[0]
    } : {
      type: "MultiLineString",
      coordinates: lines
    };
    lines = [];
    return result;
  }
};
var sinkPolygon = {
  polygonStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  point: function point(x, y) {
    points.push([x, y]);
  },
  lineEnd: function lineEnd() {
    var n = points.length;

    if (n) {
      do {
        points.push(points[0].slice());
      } while (++n < 4);

      lines.push(points), points = [];
    }
  },
  polygonEnd: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  result: function result() {
    if (!lines.length) return null;
    var polygons = [],
        holes = []; // https://github.com/d3/d3/issues/1558

    lines.forEach(function (ring) {
      if (Object(_clockwise__WEBPACK_IMPORTED_MODULE_2__["default"])(ring)) polygons.push([ring]);else holes.push(ring);
    });
    holes.forEach(function (hole) {
      var point = hole[0];
      polygons.some(function (polygon) {
        if (Object(_contains__WEBPACK_IMPORTED_MODULE_3__["default"])(polygon[0], point)) {
          polygon.push(hole);
          return true;
        }
      }) || polygons.push([hole]);
    });
    lines = [];
    return !polygons.length ? null : polygons.length > 1 ? {
      type: "MultiPolygon",
      coordinates: polygons
    } : {
      type: "Polygon",
      coordinates: polygons[0]
    };
  }
};

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/quantize.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/quantize.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (input, digits) {
  if (!(0 <= (digits = +digits) && digits <= 20)) throw new Error("invalid digits");

  function quantizePoint(input) {
    var n = input.length,
        i = 2,
        output = new Array(n);
    output[0] = +input[0].toFixed(digits);
    output[1] = +input[1].toFixed(digits);

    while (i < n) {
      output[i] = input[i], ++i;
    }

    return output;
  }

  function quantizePoints(input) {
    return input.map(quantizePoint);
  }

  function quantizePolygon(input) {
    return input.map(quantizePoints);
  }

  function quantizeGeometry(input) {
    if (input == null) return input;
    var output;

    switch (input.type) {
      case "GeometryCollection":
        output = {
          type: "GeometryCollection",
          geometries: input.geometries.map(quantizeGeometry)
        };
        break;

      case "Point":
        output = {
          type: "Point",
          coordinates: quantizePoint(input.coordinates)
        };
        break;

      case "MultiPoint":
      case "LineString":
        output = {
          type: input.type,
          coordinates: quantizePoints(input.coordinates)
        };
        break;

      case "MultiLineString":
      case "Polygon":
        output = {
          type: input.type,
          coordinates: quantizePolygon(input.coordinates)
        };
        break;

      case "MultiPolygon":
        output = {
          type: "MultiPolygon",
          coordinates: input.coordinates.map(quantizePolygon)
        };
        break;

      default:
        return input;
    }

    if (input.bbox != null) output.bbox = input.bbox;
    return output;
  }

  function quantizeFeature(input) {
    var output = {
      type: "Feature",
      properties: input.properties,
      geometry: quantizeGeometry(input.geometry)
    };
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    return output;
  }

  if (input != null) switch (input.type) {
    case "Feature":
      return quantizeFeature(input);

    case "FeatureCollection":
      {
        var output = {
          type: "FeatureCollection",
          features: input.features.map(quantizeFeature)
        };
        if (input.bbox != null) output.bbox = input.bbox;
        return output;
      }

    default:
      return quantizeGeometry(input);
  }
  return input;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/quincuncial/gringorten.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/quincuncial/gringorten.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _gringorten__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gringorten */ "./node_modules/d3-geo-projection/src/gringorten.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/quincuncial/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_gringorten__WEBPACK_IMPORTED_MODULE_0__["gringortenRaw"]).scale(176.423);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/quincuncial/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/quincuncial/index.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = (function (project) {
  var dx = project(_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"], 0)[0] - project(-_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"], 0)[0];

  function projectQuincuncial(lambda, phi) {
    var t = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) < _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
        p = project(t ? lambda : lambda > 0 ? lambda - _math__WEBPACK_IMPORTED_MODULE_1__["pi"] : lambda + _math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi),
        x = (p[0] - p[1]) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"],
        y = (p[0] + p[1]) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"];
    if (t) return [x, y];
    var d = dx * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"],
        s = x > 0 ^ y > 0 ? -1 : 1;
    return [s * x - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * d, s * y - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * d];
  }

  if (project.invert) projectQuincuncial.invert = function (x0, y0) {
    var x = (x0 + y0) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"],
        y = (y0 - x0) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"],
        t = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x) < 0.5 * dx && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < 0.5 * dx;

    if (!t) {
      var d = dx * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"],
          s = x > 0 ^ y > 0 ? -1 : 1,
          x1 = -s * x0 + (y > 0 ? 1 : -1) * d,
          y1 = -s * y0 + (x > 0 ? 1 : -1) * d;
      x = (-x1 - y1) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"];
      y = (x1 - y1) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"];
    }

    var p = project.invert(x, y);
    if (!t) p[0] += x > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["pi"];
    return p;
  };
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(projectQuincuncial).rotate([-90, -90, 45]).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/quincuncial/peirce.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/quincuncial/peirce.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _guyou__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../guyou */ "./node_modules/d3-geo-projection/src/guyou.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/quincuncial/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_guyou__WEBPACK_IMPORTED_MODULE_0__["guyouRaw"]).scale(111.48);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/rectangularPolyconic.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/rectangularPolyconic.js ***!
  \********************************************************************/
/*! exports provided: rectangularPolyconicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rectangularPolyconicRaw", function() { return rectangularPolyconicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");


function rectangularPolyconicRaw(phi0) {
  var sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi0);

  function forward(lambda, phi) {
    var A = sinPhi0 ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(lambda * sinPhi0 / 2) / sinPhi0 : lambda / 2;
    if (!phi) return [2 * A, -phi0];
    var E = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(A * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi)),
        cotPhi = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(E) * cotPhi, phi + (1 - Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(E)) * cotPhi - phi0];
  } // TODO return null for points outside outline.


  forward.invert = function (x, y) {
    if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(y += phi0) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) return [sinPhi0 ? 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(sinPhi0 * x / 2) / sinPhi0 : x, 0];
    var k = x * x + y * y,
        phi = 0,
        i = 10,
        delta;

    do {
      var tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi),
          secPhi = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi),
          j = k - 2 * y * phi + phi * phi;
      phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);
    } while (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] && --i > 0);

    var E = x * (tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi)),
        A = Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(y) < Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(phi + 1 / tanPhi) ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(E) * 0.5 : Object(_math__WEBPACK_IMPORTED_MODULE_0__["acos"])(E) * 0.5 + _math__WEBPACK_IMPORTED_MODULE_0__["pi"] / 4) / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi);
    return [sinPhi0 ? 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(sinPhi0 * A) / sinPhi0 : 2 * A, phi];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_1__["default"])(rectangularPolyconicRaw).scale(131.215);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/robinson.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/robinson.js ***!
  \********************************************************/
/*! exports provided: robinsonRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "robinsonRaw", function() { return robinsonRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var K = [[0.9986, -0.062], [1.0000, 0.0000], [0.9986, 0.0620], [0.9954, 0.1240], [0.9900, 0.1860], [0.9822, 0.2480], [0.9730, 0.3100], [0.9600, 0.3720], [0.9427, 0.4340], [0.9216, 0.4958], [0.8962, 0.5571], [0.8679, 0.6176], [0.8350, 0.6769], [0.7986, 0.7346], [0.7597, 0.7903], [0.7186, 0.8435], [0.6732, 0.8936], [0.6213, 0.9394], [0.5722, 0.9761], [0.5322, 1.0000]];
K.forEach(function (d) {
  d[1] *= 1.0144;
});
function robinsonRaw(lambda, phi) {
  var i = Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(18, Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) * 36 / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]),
      i0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floor"])(i),
      di = i - i0,
      ax = (k = K[i0])[0],
      ay = k[1],
      bx = (k = K[++i0])[0],
      by = k[1],
      cx = (k = K[Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(19, ++i0)])[0],
      cy = k[1],
      k;
  return [lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), (phi > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)];
}

robinsonRaw.invert = function (x, y) {
  var yy = y / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      phi = yy * 90,
      i = Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(18, Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi / 5)),
      i0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["max"])(0, Object(_math__WEBPACK_IMPORTED_MODULE_1__["floor"])(i));

  do {
    var ay = K[i0][1],
        by = K[i0 + 1][1],
        cy = K[Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(19, i0 + 2)][1],
        u = cy - ay,
        v = cy - 2 * by + ay,
        t = 2 * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(yy) - by) / u,
        c = v / u,
        di = t * (1 - c * t * (1 - 2 * c * t));

    if (di >= 0 || i0 === 1) {
      phi = (y >= 0 ? 5 : -5) * (di + i);
      var j = 50,
          delta;

      do {
        i = Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(18, Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) / 5);
        i0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floor"])(i);
        di = i - i0;
        ay = K[i0][1];
        by = K[i0 + 1][1];
        cy = K[Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(19, i0 + 2)][1];
        phi -= (delta = (y >= 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
      } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] && --j > 0);

      break;
    }
  } while (--i0 >= 0);

  var ax = K[i0][0],
      bx = K[i0 + 1][0],
      cx = K[Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(19, i0 + 2)][0];
  return [x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), phi * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(robinsonRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/satellite.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/satellite.js ***!
  \*********************************************************/
/*! exports provided: satelliteRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "satelliteRaw", function() { return satelliteRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



function satelliteVerticalRaw(P) {
  function forward(lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        k = (P - 1) / (P - cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda));
    return [k * cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
  }

  forward.invert = function (x, y) {
    var rho2 = x * x + y * y,
        rho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(rho2),
        sinc = (P - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - rho2 * (P + 1) / (P - 1))) / ((P - 1) / rho + rho / (P - 1));
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x * sinc, rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - sinc * sinc)), rho ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y * sinc / rho) : 0];
  };

  return forward;
}

function satelliteRaw(P, omega) {
  var vertical = satelliteVerticalRaw(P);
  if (!omega) return vertical;
  var cosOmega = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(omega),
      sinOmega = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(omega);

  function forward(lambda, phi) {
    var coordinates = vertical(lambda, phi),
        y = coordinates[1],
        A = y * sinOmega / (P - 1) + cosOmega;
    return [coordinates[0] * cosOmega / A, y / A];
  }

  forward.invert = function (x, y) {
    var k = (P - 1) / (P - 1 - y * sinOmega);
    return vertical.invert(k * x, k * y * cosOmega);
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var distance = 2,
      omega = 0,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(satelliteRaw),
      p = m(distance, omega); // As a multiple of radius.

  p.distance = function (_) {
    if (!arguments.length) return distance;
    return m(distance = +_, omega);
  };

  p.tilt = function (_) {
    if (!arguments.length) return omega * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
    return m(distance, omega = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
  };

  return p.scale(432.147).clipAngle(Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(1 / distance) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"] - 1e-6);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/sinuMollweide.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/sinuMollweide.js ***!
  \*************************************************************/
/*! exports provided: sinuMollweidePhi, sinuMollweideY, sinuMollweideRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinuMollweidePhi", function() { return sinuMollweidePhi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinuMollweideY", function() { return sinuMollweideY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinuMollweideRaw", function() { return sinuMollweideRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var _sinusoidal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sinusoidal */ "./node_modules/d3-geo-projection/src/sinusoidal.js");



var sinuMollweidePhi = 0.7109889596207567;
var sinuMollweideY = 0.0528035274542;
function sinuMollweideRaw(lambda, phi) {
  return phi > -sinuMollweidePhi ? (lambda = Object(_mollweide__WEBPACK_IMPORTED_MODULE_1__["mollweideRaw"])(lambda, phi), lambda[1] += sinuMollweideY, lambda) : Object(_sinusoidal__WEBPACK_IMPORTED_MODULE_2__["sinusoidalRaw"])(lambda, phi);
}

sinuMollweideRaw.invert = function (x, y) {
  return y > -sinuMollweidePhi ? _mollweide__WEBPACK_IMPORTED_MODULE_1__["mollweideRaw"].invert(x, y - sinuMollweideY) : _sinusoidal__WEBPACK_IMPORTED_MODULE_2__["sinusoidalRaw"].invert(x, y);
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(sinuMollweideRaw).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/sinusoidal.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/sinusoidal.js ***!
  \**********************************************************/
/*! exports provided: sinusoidalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinusoidalRaw", function() { return sinusoidalRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function sinusoidalRaw(lambda, phi) {
  return [lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi), phi];
}

sinusoidalRaw.invert = function (x, y) {
  return [x / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y), y];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(sinusoidalRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/square.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/square.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");

/* harmony default export */ __webpack_exports__["default"] = (function (project) {
  var dx = project(_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"], 0)[0] - project(-_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"], 0)[0];

  function projectSquare(lambda, phi) {
    var s = lambda > 0 ? -0.5 : 0.5,
        point = project(lambda + s * _math__WEBPACK_IMPORTED_MODULE_0__["pi"], phi);
    point[0] -= s * dx;
    return point;
  }

  if (project.invert) projectSquare.invert = function (x, y) {
    var s = x > 0 ? -0.5 : 0.5,
        location = project.invert(x + s * dx, y),
        lambda = location[0] - s * _math__WEBPACK_IMPORTED_MODULE_0__["pi"];
    if (lambda < -_math__WEBPACK_IMPORTED_MODULE_0__["pi"]) lambda += 2 * _math__WEBPACK_IMPORTED_MODULE_0__["pi"];else if (lambda > _math__WEBPACK_IMPORTED_MODULE_0__["pi"]) lambda -= 2 * _math__WEBPACK_IMPORTED_MODULE_0__["pi"];
    location[0] = lambda;
    return location;
  };
  return projectSquare;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/stitch.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/stitch.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var epsilon = 1e-4,
    epsilonInverse = 1e4,
    x0 = -180,
    x0e = x0 + epsilon,
    x1 = 180,
    x1e = x1 - epsilon,
    y0 = -90,
    y0e = y0 + epsilon,
    y1 = 90,
    y1e = y1 - epsilon;

function nonempty(coordinates) {
  return coordinates.length > 0;
}

function quantize(x) {
  return Math.floor(x * epsilonInverse) / epsilonInverse;
}

function normalizePoint(y) {
  return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)]; // pole or antimeridian?
}

function clampPoint(p) {
  var x = p[0],
      y = p[1],
      clamped = false;
  if (x <= x0e) x = x0, clamped = true;else if (x >= x1e) x = x1, clamped = true;
  if (y <= y0e) y = y0, clamped = true;else if (y >= y1e) y = y1, clamped = true;
  return clamped ? [x, y] : p;
}

function clampPoints(points) {
  return points.map(clampPoint);
} // For each ring, detect where it crosses the antimeridian or pole.


function extractFragments(rings, polygon, fragments) {
  for (var j = 0, m = rings.length; j < m; ++j) {
    var ring = rings[j].slice(); // By default, assume that this ring doesn’t need any stitching.

    fragments.push({
      index: -1,
      polygon: polygon,
      ring: ring
    });

    for (var i = 0, n = ring.length; i < n; ++i) {
      var point = ring[i],
          x = point[0],
          y = point[1]; // If this is an antimeridian or polar point…

      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {
        ring[i] = clampPoint(point); // Advance through any antimeridian or polar points…

        for (var k = i + 1; k < n; ++k) {
          var pointk = ring[k],
              xk = pointk[0],
              yk = pointk[1];
          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;
        } // If this was just a single antimeridian or polar point,
        // we don’t need to cut this ring into a fragment;
        // we can just leave it as-is.


        if (k === i + 1) continue; // Otherwise, if this is not the first point in the ring,
        // cut the current fragment so that it ends at the current point.
        // The current point is also normalized for later joining.

        if (i) {
          var fragmentBefore = {
            index: -1,
            polygon: polygon,
            ring: ring.slice(0, i + 1)
          };
          fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);
          fragments[fragments.length - 1] = fragmentBefore;
        } // If the ring started with an antimeridian fragment,
        // we can ignore that fragment entirely.
        else fragments.pop(); // If the remainder of the ring is an antimeridian fragment,
        // move on to the next ring.


        if (k >= n) break; // Otherwise, add the remaining ring fragment and continue.

        fragments.push({
          index: -1,
          polygon: polygon,
          ring: ring = ring.slice(k - 1)
        });
        ring[0] = normalizePoint(ring[0][1]);
        i = -1;
        n = ring.length;
      }
    }
  }
} // Now stitch the fragments back together into rings.


function stitchFragments(fragments) {
  var i,
      n = fragments.length; // To connect the fragments start-to-end, create a simple index by end.

  var fragmentByStart = {},
      fragmentByEnd = {},
      fragment,
      start,
      startFragment,
      end,
      endFragment; // For each fragment…

  for (i = 0; i < n; ++i) {
    fragment = fragments[i];
    start = fragment.ring[0];
    end = fragment.ring[fragment.ring.length - 1]; // If this fragment is closed, add it as a standalone ring.

    if (start[0] === end[0] && start[1] === end[1]) {
      fragment.polygon.push(fragment.ring);
      fragments[i] = null;
      continue;
    }

    fragment.index = i;
    fragmentByStart[start] = fragmentByEnd[end] = fragment;
  } // For each open fragment…


  for (i = 0; i < n; ++i) {
    fragment = fragments[i];

    if (fragment) {
      start = fragment.ring[0];
      end = fragment.ring[fragment.ring.length - 1];
      startFragment = fragmentByEnd[start];
      endFragment = fragmentByStart[end];
      delete fragmentByStart[start];
      delete fragmentByEnd[end]; // If this fragment is closed, add it as a standalone ring.

      if (start[0] === end[0] && start[1] === end[1]) {
        fragment.polygon.push(fragment.ring);
        continue;
      }

      if (startFragment) {
        delete fragmentByEnd[start];
        delete fragmentByStart[startFragment.ring[0]];
        startFragment.ring.pop(); // drop the shared coordinate

        fragments[startFragment.index] = null;
        fragment = {
          index: -1,
          polygon: startFragment.polygon,
          ring: startFragment.ring.concat(fragment.ring)
        };

        if (startFragment === endFragment) {
          // Connect both ends to this single fragment to create a ring.
          fragment.polygon.push(fragment.ring);
        } else {
          fragment.index = n++;
          fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);
        }
      } else if (endFragment) {
        delete fragmentByStart[end];
        delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];
        fragment.ring.pop(); // drop the shared coordinate

        fragment = {
          index: n++,
          polygon: endFragment.polygon,
          ring: fragment.ring.concat(endFragment.ring)
        };
        fragments[endFragment.index] = null;
        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);
      } else {
        fragment.ring.push(fragment.ring[0]); // close ring

        fragment.polygon.push(fragment.ring);
      }
    }
  }
}

function stitchFeature(input) {
  var output = {
    type: "Feature",
    geometry: stitchGeometry(input.geometry)
  };
  if (input.id != null) output.id = input.id;
  if (input.bbox != null) output.bbox = input.bbox;
  if (input.properties != null) output.properties = input.properties;
  return output;
}

function stitchGeometry(input) {
  if (input == null) return input;
  var output, fragments, i, n;

  switch (input.type) {
    case "GeometryCollection":
      output = {
        type: "GeometryCollection",
        geometries: input.geometries.map(stitchGeometry)
      };
      break;

    case "Point":
      output = {
        type: "Point",
        coordinates: clampPoint(input.coordinates)
      };
      break;

    case "MultiPoint":
    case "LineString":
      output = {
        type: input.type,
        coordinates: clampPoints(input.coordinates)
      };
      break;

    case "MultiLineString":
      output = {
        type: "MultiLineString",
        coordinates: input.coordinates.map(clampPoints)
      };
      break;

    case "Polygon":
      {
        var polygon = [];
        extractFragments(input.coordinates, polygon, fragments = []);
        stitchFragments(fragments);
        output = {
          type: "Polygon",
          coordinates: polygon
        };
        break;
      }

    case "MultiPolygon":
      {
        fragments = [], i = -1, n = input.coordinates.length;
        var polygons = new Array(n);

        while (++i < n) {
          extractFragments(input.coordinates[i], polygons[i] = [], fragments);
        }

        stitchFragments(fragments);
        output = {
          type: "MultiPolygon",
          coordinates: polygons.filter(nonempty)
        };
        break;
      }

    default:
      return input;
  }

  if (input.bbox != null) output.bbox = input.bbox;
  return output;
}

/* harmony default export */ __webpack_exports__["default"] = (function (input) {
  if (input == null) return input;

  switch (input.type) {
    case "Feature":
      return stitchFeature(input);

    case "FeatureCollection":
      {
        var output = {
          type: "FeatureCollection",
          features: input.features.map(stitchFeature)
        };
        if (input.bbox != null) output.bbox = input.bbox;
        return output;
      }

    default:
      return stitchGeometry(input);
  }
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/times.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/times.js ***!
  \*****************************************************/
/*! exports provided: timesRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timesRaw", function() { return timesRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function timesRaw(lambda, phi) {
  var t = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi / 2),
      s = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(_math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] * t);
  return [lambda * (0.74482 - 0.34588 * s * s), 1.70711 * t];
}

timesRaw.invert = function (x, y) {
  var t = y / 1.70711,
      s = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(_math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] * t);
  return [x / (0.74482 - 0.34588 * s * s), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(t)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(timesRaw).scale(146.153);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/twoPoint.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/twoPoint.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");

 // Compute the origin as the midpoint of the two reference points.
// Rotate one of the reference points by the origin.
// Apply the spherical law of sines to compute gamma rotation.

/* harmony default export */ __webpack_exports__["default"] = (function (raw, p0, p1) {
  var i = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoInterpolate"])(p0, p1),
      o = i(0.5),
      a = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoRotation"])([-o[0], -o[1]])(p0),
      b = i.distance / 2,
      y = -Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(a[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(b)),
      R = [-o[0], -o[1], -(a[0] > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] - y : y) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]],
      p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(raw(b)).rotate(R),
      r = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoRotation"])(R),
      center = p.center;
  delete p.rotate;

  p.center = function (_) {
    return arguments.length ? center(r(_)) : r.invert(center());
  };

  return p.clipAngle(90);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/twoPointAzimuthal.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/twoPointAzimuthal.js ***!
  \*****************************************************************/
/*! exports provided: twoPointAzimuthalRaw, twoPointAzimuthalUsa, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twoPointAzimuthalRaw", function() { return twoPointAzimuthalRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twoPointAzimuthalUsa", function() { return twoPointAzimuthalUsa; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return twoPointAzimuthal; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _twoPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./twoPoint */ "./node_modules/d3-geo-projection/src/twoPoint.js");



function twoPointAzimuthalRaw(d) {
  var cosd = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(d);

  function forward(lambda, phi) {
    var coordinates = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoGnomonicRaw"])(lambda, phi);
    coordinates[0] *= cosd;
    return coordinates;
  }

  forward.invert = function (x, y) {
    return d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoGnomonicRaw"].invert(x / cosd, y);
  };

  return forward;
}
function twoPointAzimuthalUsa() {
  return twoPointAzimuthal([-158, 21.5], [-77, 39]).clipAngle(60).scale(400);
}
function twoPointAzimuthal(p0, p1) {
  return Object(_twoPoint__WEBPACK_IMPORTED_MODULE_2__["default"])(twoPointAzimuthalRaw, p0, p1);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/twoPointEquidistant.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/twoPointEquidistant.js ***!
  \*******************************************************************/
/*! exports provided: twoPointEquidistantRaw, twoPointEquidistantUsa, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twoPointEquidistantRaw", function() { return twoPointEquidistantRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twoPointEquidistantUsa", function() { return twoPointEquidistantUsa; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return twoPointEquidistant; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _twoPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./twoPoint */ "./node_modules/d3-geo-projection/src/twoPoint.js");


 // TODO clip to ellipse

function twoPointEquidistantRaw(z0) {
  if (!(z0 *= 2)) return d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEquidistantRaw"];
  var lambdaa = -z0 / 2,
      lambdab = -lambdaa,
      z02 = z0 * z0,
      tanLambda0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(lambdab),
      S = 0.5 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambdab);

  function forward(lambda, phi) {
    var za = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda - lambdaa)),
        zb = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda - lambdab)),
        ys = phi < 0 ? -1 : 1;
    za *= za, zb *= zb;
    return [(za - zb) / (2 * z0), ys * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)];
  }

  forward.invert = function (x, y) {
    var y2 = y * y,
        cosza = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(y2 + (t = x + lambdaa) * t)),
        coszb = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(y2 + (t = x + lambdab) * t)),
        t,
        d;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(d = cosza - coszb, t = (cosza + coszb) * tanLambda0), (y < 0 ? -1 : 1) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(t * t + d * d) * S)];
  };

  return forward;
}
function twoPointEquidistantUsa() {
  return twoPointEquidistant([-158, 21.5], [-77, 39]).clipAngle(130).scale(122.571);
}
function twoPointEquidistant(p0, p1) {
  return Object(_twoPoint__WEBPACK_IMPORTED_MODULE_2__["default"])(twoPointEquidistantRaw, p0, p1);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/vanDerGrinten.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/vanDerGrinten.js ***!
  \*************************************************************/
/*! exports provided: vanDerGrintenRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vanDerGrintenRaw", function() { return vanDerGrintenRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function vanDerGrintenRaw(lambda, phi) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [lambda, 0];
  var sinTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]),
      theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinTheta);
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [0, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(theta / 2)];
  var cosTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta),
      A = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lambda - lambda / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / 2,
      A2 = A * A,
      G = cosTheta / (sinTheta + cosTheta - 1),
      P = G * (2 / sinTheta - 1),
      P2 = P * P,
      P2_A2 = P2 + A2,
      G_P2 = G - P2,
      Q = A2 + G;
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(lambda) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (A * G_P2 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(A2 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (P * Q - A * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])((A2 + 1) * P2_A2 - Q * Q)) / P2_A2];
}

vanDerGrintenRaw.invert = function (x, y) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [x, 0];
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [0, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(y / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]))];
  var x2 = (x /= _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) * x,
      y2 = (y /= _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) * y,
      x2_y2 = x2 + y2,
      z = x2_y2 * x2_y2,
      c1 = -Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) * (1 + x2_y2),
      c2 = c1 - 2 * y2 + x2,
      c3 = -2 * c1 + 1 + 2 * y2 + z,
      d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27,
      a1 = (c1 - c2 * c2 / (3 * c3)) / c3,
      m1 = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(-a1 / 3),
      theta1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(3 * d / (a1 * m1)) / 3;
  return [_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (x2_y2 - 1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 + 2 * (x2 - y2) + z)) / (2 * x), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (-m1 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta1 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 3) - c2 / (3 * c3))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(vanDerGrintenRaw).scale(79.4183);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/vanDerGrinten2.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/vanDerGrinten2.js ***!
  \**************************************************************/
/*! exports provided: vanDerGrinten2Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vanDerGrinten2Raw", function() { return vanDerGrinten2Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function vanDerGrinten2Raw(lambda, phi) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [lambda, 0];
  var sinTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]),
      theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinTheta);
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [0, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(theta / 2)];
  var cosTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta),
      A = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lambda - lambda / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / 2,
      A2 = A * A,
      x1 = cosTheta * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 + A2) - A * cosTheta) / (1 + A2 * sinTheta * sinTheta);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(lambda) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * x1, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - x1 * (2 * A + x1))];
}

vanDerGrinten2Raw.invert = function (x, y) {
  if (!x) return [0, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(y / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]))];
  var x1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]),
      A = (1 - x1 * x1 - (y /= _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) * y) / (2 * x1),
      A2 = A * A,
      B = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(A2 + 1);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (B - A), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])((1 - 2 * A * x1) * (A + B) - x1), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(B + A + x1)))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(vanDerGrinten2Raw).scale(79.4183);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/vanDerGrinten3.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/vanDerGrinten3.js ***!
  \**************************************************************/
/*! exports provided: vanDerGrinten3Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vanDerGrinten3Raw", function() { return vanDerGrinten3Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function vanDerGrinten3Raw(lambda, phi) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [lambda, 0];
  var sinTheta = phi / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinTheta);
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [0, _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(theta / 2)];
  var A = (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lambda - lambda / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / 2,
      y1 = sinTheta / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta));
  return [_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(lambda) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(A * A + 1 - y1 * y1) - A), _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * y1];
}

vanDerGrinten3Raw.invert = function (x, y) {
  if (!y) return [x, 0];
  var y1 = y / _math__WEBPACK_IMPORTED_MODULE_1__["pi"],
      A = (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (1 - y1 * y1) - x * x) / (2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * x);
  return [x ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(A * A + 1) - A) : 0, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(y1))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(vanDerGrinten3Raw).scale(79.4183);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/vanDerGrinten4.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/vanDerGrinten4.js ***!
  \**************************************************************/
/*! exports provided: vanDerGrinten4Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vanDerGrinten4Raw", function() { return vanDerGrinten4Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function vanDerGrinten4Raw(lambda, phi) {
  if (!phi) return [lambda, 0];
  var phi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi);
  if (!lambda || phi0 === _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) return [0, phi];
  var B = phi0 / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      B2 = B * B,
      C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)),
      C2 = C * C,
      BC = B * C,
      B_C2 = B2 + C2 + 2 * BC,
      B_3C = B + 3 * C,
      lambda0 = lambda / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      lambda1 = lambda0 + 1 / lambda0,
      D = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(lambda1 * lambda1 - 4),
      D2 = D * D,
      F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2),
      x1 = (D * (B_C2 + C2 - 1) + 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(F)) / (4 * B_C2 + D2);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(lambda) * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * x1, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 + D * Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x1) - x1 * x1)];
}

vanDerGrinten4Raw.invert = function (x, y) {
  var delta;
  if (!x || !y) return [x, y];
  y /= _math__WEBPACK_IMPORTED_MODULE_1__["pi"];
  var x1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * x / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      D = (x1 * x1 - 1 + 4 * y * y) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x1),
      D2 = D * D,
      B = 2 * y,
      i = 50;

  do {
    var B2 = B * B,
        C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)),
        C_ = (3 * B - B2 * B - 10) / (2 * B2 * B),
        C2 = C * C,
        BC = B * C,
        B_C = B + C,
        B_C2 = B_C * B_C,
        B_3C = B + 3 * C,
        F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)),
        F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B2 + 3 * B2 * B2) * (1 + C_) + C2 * (-6 + 14 * B2 - D2 + (-8 + 8 * B2 - 2 * D2) * C_) + BC * (-8 + 12 * B2 + (-10 + 10 * B2 - D2) * C_)),
        sqrtF = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(F),
        f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x1 * (4 * B_C2 + D2),
        f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
    B -= delta = f / f_;
  } while (delta > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(D * D + 4) + D) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * B];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(vanDerGrinten4Raw).scale(127.16);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/wagner4.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/wagner4.js ***!
  \*******************************************************/
/*! exports provided: wagner4Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wagner4Raw", function() { return wagner4Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");



var A = 4 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] + 3 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3),
    B = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3) / A);
var wagner4Raw = Object(_mollweide__WEBPACK_IMPORTED_MODULE_2__["mollweideBromleyRaw"])(B * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3) / _math__WEBPACK_IMPORTED_MODULE_1__["pi"], B, A / 6);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(wagner4Raw).scale(176.84);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/wagner6.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/wagner6.js ***!
  \*******************************************************/
/*! exports provided: wagner6Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wagner6Raw", function() { return wagner6Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function wagner6Raw(lambda, phi) {
  return [lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - 3 * phi * phi / (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"])), phi];
}

wagner6Raw.invert = function (x, y) {
  return [x / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - 3 * y * y / (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"])), y];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(wagner6Raw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/wagner7.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/wagner7.js ***!
  \*******************************************************/
/*! exports provided: wagner7Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wagner7Raw", function() { return wagner7Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function wagner7Raw(lambda, phi) {
  var s = 0.90631 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      c0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - s * s),
      c1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 / (1 + c0 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda /= 3)));
  return [2.66723 * c0 * c1 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), 1.24104 * s * c1];
}

wagner7Raw.invert = function (x, y) {
  var t1 = x / 2.66723,
      t2 = y / 1.24104,
      p = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(t1 * t1 + t2 * t2),
      c = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(p / 2);
  return [3 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x * Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(c), 2.66723 * p), p && Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(c) / (1.24104 * 0.90631 * p))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(wagner7Raw).scale(172.632);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/wiechel.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/wiechel.js ***!
  \*******************************************************/
/*! exports provided: wiechelRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wiechelRaw", function() { return wiechelRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function wiechelRaw(lambda, phi) {
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
      sin1_Phi = 1 - sinPhi,
      cosLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi, -Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi))),
      sinLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda);
  cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - sinPhi * sinPhi);
  return [sinLambda * cosPhi - cosLambda * sin1_Phi, -cosLambda * cosPhi - sinLambda * sin1_Phi];
}

wiechelRaw.invert = function (x, y) {
  var w = (x * x + y * y) / -2,
      k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(-w * (2 + w)),
      b = y * w + x * k,
      a = x * w - y * k,
      D = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a * a + b * b);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(k * b, D * (1 + w)), D ? -Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(k * a / D) : 0];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(wiechelRaw).rotate([0, -90, 45]).scale(124.75).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/winkel3.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/winkel3.js ***!
  \*******************************************************/
/*! exports provided: winkel3Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "winkel3Raw", function() { return winkel3Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/index.js");
/* harmony import */ var _aitoff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aitoff */ "./node_modules/d3-geo-projection/src/aitoff.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



function winkel3Raw(lambda, phi) {
  var coordinates = Object(_aitoff__WEBPACK_IMPORTED_MODULE_1__["aitoffRaw"])(lambda, phi);
  return [(coordinates[0] + lambda / _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"]) / 2, (coordinates[1] + phi) / 2];
}

winkel3Raw.invert = function (x, y) {
  var lambda = x,
      phi = y,
      i = 25;

  do {
    var cosphi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi),
        sinphi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi),
        sin_2phi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(2 * phi),
        sin2phi = sinphi * sinphi,
        cos2phi = cosphi * cosphi,
        sinlambda = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(lambda),
        coslambda_2 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda / 2),
        sinlambda_2 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(lambda / 2),
        sin2lambda_2 = sinlambda_2 * sinlambda_2,
        C = 1 - cos2phi * coslambda_2 * coslambda_2,
        E = C ? Object(_math__WEBPACK_IMPORTED_MODULE_2__["acos"])(cosphi * coslambda_2) * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(F = 1 / C) : F = 0,
        F,
        fx = 0.5 * (2 * E * cosphi * sinlambda_2 + lambda / _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"]) - x,
        fy = 0.5 * (E * sinphi + phi) - y,
        dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E * cosphi * coslambda_2 * sin2phi) + 0.5 / _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"],
        dxdphi = F * (sinlambda * sin_2phi / 4 - E * sinphi * sinlambda_2),
        dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E * sinphi * cos2phi * sinlambda),
        dydphi = 0.5 * F * (sin2phi * coslambda_2 + E * sin2lambda_2 * cosphi) + 0.5,
        denominator = dxdphi * dydlambda - dydphi * dxdlambda,
        dlambda = (fy * dxdphi - fx * dydphi) / denominator,
        dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
    lambda -= dlambda, phi -= dphi;
  } while ((Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(dlambda) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(dphi) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) && --i > 0);

  return [lambda, phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(winkel3Raw).scale(158.837);
});

/***/ }),

/***/ "./node_modules/d3-geo/index.js":
/*!**************************************!*\
  !*** ./node_modules/d3-geo/index.js ***!
  \**************************************/
/*! exports provided: geoArea, geoBounds, geoCentroid, geoCircle, geoClipAntimeridian, geoClipCircle, geoClipExtent, geoClipRectangle, geoContains, geoDistance, geoGraticule, geoGraticule10, geoInterpolate, geoLength, geoPath, geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEqualAreaRaw, geoAzimuthalEquidistant, geoAzimuthalEquidistantRaw, geoConicConformal, geoConicConformalRaw, geoConicEqualArea, geoConicEqualAreaRaw, geoConicEquidistant, geoConicEquidistantRaw, geoEquirectangular, geoEquirectangularRaw, geoGnomonic, geoGnomonicRaw, geoIdentity, geoProjection, geoProjectionMutator, geoMercator, geoMercatorRaw, geoNaturalEarth1, geoNaturalEarth1Raw, geoOrthographic, geoOrthographicRaw, geoStereographic, geoStereographicRaw, geoTransverseMercator, geoTransverseMercatorRaw, geoRotation, geoStream, geoTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/area */ "./node_modules/d3-geo/src/area.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArea", function() { return _src_area__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/bounds */ "./node_modules/d3-geo/src/bounds.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBounds", function() { return _src_bounds__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_centroid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/centroid */ "./node_modules/d3-geo/src/centroid.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCentroid", function() { return _src_centroid__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/circle */ "./node_modules/d3-geo/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCircle", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_clip_antimeridian__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/clip/antimeridian */ "./node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipAntimeridian", function() { return _src_clip_antimeridian__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_clip_circle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/clip/circle */ "./node_modules/d3-geo/src/clip/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipCircle", function() { return _src_clip_circle__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_clip_extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/clip/extent */ "./node_modules/d3-geo/src/clip/extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipExtent", function() { return _src_clip_extent__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_clip_rectangle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/clip/rectangle */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipRectangle", function() { return _src_clip_rectangle__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_contains__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/contains */ "./node_modules/d3-geo/src/contains.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoContains", function() { return _src_contains__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_distance__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/distance */ "./node_modules/d3-geo/src/distance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoDistance", function() { return _src_distance__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _src_graticule__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/graticule */ "./node_modules/d3-geo/src/graticule.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule", function() { return _src_graticule__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule10", function() { return _src_graticule__WEBPACK_IMPORTED_MODULE_10__["graticule10"]; });

/* harmony import */ var _src_interpolate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/interpolate */ "./node_modules/d3-geo/src/interpolate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterpolate", function() { return _src_interpolate__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _src_length__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/length */ "./node_modules/d3-geo/src/length.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLength", function() { return _src_length__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _src_path_index__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/path/index */ "./node_modules/d3-geo/src/path/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPath", function() { return _src_path_index__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _src_projection_albers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/projection/albers */ "./node_modules/d3-geo/src/projection/albers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbers", function() { return _src_projection_albers__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _src_projection_albersUsa__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/projection/albersUsa */ "./node_modules/d3-geo/src/projection/albersUsa.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbersUsa", function() { return _src_projection_albersUsa__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/projection/azimuthalEqualArea */ "./node_modules/d3-geo/src/projection/azimuthalEqualArea.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualArea", function() { return _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualAreaRaw", function() { return _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_16__["azimuthalEqualAreaRaw"]; });

/* harmony import */ var _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/projection/azimuthalEquidistant */ "./node_modules/d3-geo/src/projection/azimuthalEquidistant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistant", function() { return _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistantRaw", function() { return _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_17__["azimuthalEquidistantRaw"]; });

/* harmony import */ var _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/projection/conicConformal */ "./node_modules/d3-geo/src/projection/conicConformal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformal", function() { return _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformalRaw", function() { return _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_18__["conicConformalRaw"]; });

/* harmony import */ var _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/projection/conicEqualArea */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualArea", function() { return _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualAreaRaw", function() { return _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_19__["conicEqualAreaRaw"]; });

/* harmony import */ var _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/projection/conicEquidistant */ "./node_modules/d3-geo/src/projection/conicEquidistant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistant", function() { return _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistantRaw", function() { return _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_20__["conicEquidistantRaw"]; });

/* harmony import */ var _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/projection/equirectangular */ "./node_modules/d3-geo/src/projection/equirectangular.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangular", function() { return _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangularRaw", function() { return _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_21__["equirectangularRaw"]; });

/* harmony import */ var _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/projection/gnomonic */ "./node_modules/d3-geo/src/projection/gnomonic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonic", function() { return _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonicRaw", function() { return _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_22__["gnomonicRaw"]; });

/* harmony import */ var _src_projection_identity__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/projection/identity */ "./node_modules/d3-geo/src/projection/identity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoIdentity", function() { return _src_projection_identity__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _src_projection_index__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/projection/index */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjection", function() { return _src_projection_index__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjectionMutator", function() { return _src_projection_index__WEBPACK_IMPORTED_MODULE_24__["projectionMutator"]; });

/* harmony import */ var _src_projection_mercator__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/projection/mercator */ "./node_modules/d3-geo/src/projection/mercator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercator", function() { return _src_projection_mercator__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercatorRaw", function() { return _src_projection_mercator__WEBPACK_IMPORTED_MODULE_25__["mercatorRaw"]; });

/* harmony import */ var _src_projection_naturalEarth1__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/projection/naturalEarth1 */ "./node_modules/d3-geo/src/projection/naturalEarth1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1", function() { return _src_projection_naturalEarth1__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1Raw", function() { return _src_projection_naturalEarth1__WEBPACK_IMPORTED_MODULE_26__["naturalEarth1Raw"]; });

/* harmony import */ var _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/projection/orthographic */ "./node_modules/d3-geo/src/projection/orthographic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographic", function() { return _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographicRaw", function() { return _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_27__["orthographicRaw"]; });

/* harmony import */ var _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/projection/stereographic */ "./node_modules/d3-geo/src/projection/stereographic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographic", function() { return _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographicRaw", function() { return _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_28__["stereographicRaw"]; });

/* harmony import */ var _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/projection/transverseMercator */ "./node_modules/d3-geo/src/projection/transverseMercator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercator", function() { return _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercatorRaw", function() { return _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_29__["transverseMercatorRaw"]; });

/* harmony import */ var _src_rotation__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./src/rotation */ "./node_modules/d3-geo/src/rotation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRotation", function() { return _src_rotation__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _src_stream__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./src/stream */ "./node_modules/d3-geo/src/stream.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStream", function() { return _src_stream__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _src_transform__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./src/transform */ "./node_modules/d3-geo/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransform", function() { return _src_transform__WEBPACK_IMPORTED_MODULE_32__["default"]; });







 // DEPRECATED! Use d3.geoIdentity().clipExtent(…).




























/***/ }),

/***/ "./node_modules/d3-geo/src/adder.js":
/*!******************************************!*\
  !*** ./node_modules/d3-geo/src/adder.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return new Adder();
});

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function reset() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function add(y) {
    _add(temp, y, this.t);

    _add(this, temp.s, this.s);

    if (this.s) this.t += temp.t;else this.s = temp.t;
  },
  valueOf: function valueOf() {
    return this.s;
  }
};
var temp = new Adder();

function _add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = a - av + (b - bv);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/area.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/area.js ***!
  \*****************************************/
/*! exports provided: areaRingSum, areaStream, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areaRingSum", function() { return areaRingSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areaStream", function() { return areaStream; });
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");




var areaRingSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])();
var areaSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;
var areaStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: function polygonStart() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function polygonEnd() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["tau"] + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
  },
  sphere: function sphere() {
    areaSum.add(_math__WEBPACK_IMPORTED_MODULE_1__["tau"]);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  lambda0 = lambda, cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi = phi / 2 + _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]), sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);
}

function areaPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  phi = phi / 2 + _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]; // half the angular distance from south pole
  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).

  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(adLambda),
      v = k * sdLambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(adLambda);
  areaRingSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(v, u)); // Advance the previous points.

  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

/* harmony default export */ __webpack_exports__["default"] = (function (object) {
  areaSum.reset();
  Object(_stream__WEBPACK_IMPORTED_MODULE_3__["default"])(object, areaStream);
  return areaSum * 2;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/bounds.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/bounds.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area */ "./node_modules/d3-geo/src/area.js");
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");





var lambda0,
    phi0,
    lambda1,
    phi1,
    // bounds
lambda2,
    // previous lambda-coordinate
lambda00,
    phi00,
    // first point
p0,
    // previous 3D point
deltaSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    ranges,
    range;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function polygonStart() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].polygonStart();
  },
  polygonEnd: function polygonEnd() {
    _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (_area__WEBPACK_IMPORTED_MODULE_1__["areaRingSum"] < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > _math__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) phi1 = 90;else if (deltaSum < -_math__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesian"])([lambda * _math__WEBPACK_IMPORTED_MODULE_3__["radians"], phi * _math__WEBPACK_IMPORTED_MODULE_3__["radians"]]);

  if (p0) {
    var normal = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesianCross"])(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesianCross"])(equatorial, normal);
    Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesianNormalizeInPlace"])(inflection);
    inflection = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["spherical"])(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * _math__WEBPACK_IMPORTED_MODULE_3__["degrees"] * sign,
        phii,
        antimeridian = Object(_math__WEBPACK_IMPORTED_MODULE_3__["abs"])(delta) > 180;

    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * _math__WEBPACK_IMPORTED_MODULE_3__["degrees"];
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * _math__WEBPACK_IMPORTED_MODULE_3__["degrees"];
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  }

  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_3__["abs"])(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }

  _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);
  _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].lineEnd();
  if (Object(_math__WEBPACK_IMPORTED_MODULE_3__["abs"])(deltaSum) > _math__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
} // Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.


function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ __webpack_exports__["default"] = (function (feature) {
  var i, n, a, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  Object(_stream__WEBPACK_IMPORTED_MODULE_4__["default"])(feature, boundsStream); // First, sort ranges by their minimum longitudes.

  if (n = ranges.length) {
    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.

    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];

      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    } // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.


    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;
  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];
});

/***/ }),

/***/ "./node_modules/d3-geo/src/cartesian.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/cartesian.js ***!
  \**********************************************/
/*! exports provided: spherical, cartesian, cartesianDot, cartesianCross, cartesianAddInPlace, cartesianScale, cartesianNormalizeInPlace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spherical", function() { return spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesian", function() { return cartesian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianDot", function() { return cartesianDot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianCross", function() { return cartesianCross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianAddInPlace", function() { return cartesianAddInPlace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianScale", function() { return cartesianScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianNormalizeInPlace", function() { return cartesianNormalizeInPlace; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");

function spherical(cartesian) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(cartesian[1], cartesian[0]), Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(cartesian[2])];
}
function cartesian(spherical) {
  var lambda = spherical[0],
      phi = spherical[1],
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  return [cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda), cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi)];
}
function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
} // TODO return a

function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
} // TODO return d

function cartesianNormalizeInPlace(d) {
  var l = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/centroid.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/centroid.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");



var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, // first point
x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function polygonStart() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function polygonEnd() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
}; // Arithmetic mean of Cartesian vectors.

function centroidPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  centroidPointCartesian(cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda), cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  x0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda);
  y0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda);
  z0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi),
      x = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda),
      y = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda),
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi),
      w = Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
} // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).


function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  centroidStream.point = centroidRingPoint;
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  x0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda);
  y0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda);
  z0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi),
      x = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda),
      y = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda),
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(cx * cx + cy * cy + cz * cz),
      w = Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(m),
      // line weight = angle
  v = m && -w / m; // area weight multiplier

  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ __webpack_exports__["default"] = (function (object) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
  Object(_stream__WEBPACK_IMPORTED_MODULE_2__["default"])(object, centroidStream);
  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z; // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.

  if (m < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon2"]) {
    x = X1, y = Y1, z = Z1; // If the feature has zero length, fall back to arithmetic mean of point vectors.

    if (W1 < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z; // If the feature still has an undefined ccentroid, then return.

    if (m < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon2"]) return [NaN, NaN];
  }

  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(y, x) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(z / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(m)) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
});

/***/ }),

/***/ "./node_modules/d3-geo/src/circle.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/circle.js ***!
  \*******************************************/
/*! exports provided: circleStream, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleStream", function() { return circleStream; });
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation */ "./node_modules/d3-geo/src/rotation.js");



 // Generates a circle centered at [0°, 0°], with a given radius and precision.

function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(radius),
      sinRadius = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(radius),
      step = direction * delta;

  if (t0 == null) {
    t0 = radius + direction * _math__WEBPACK_IMPORTED_MODULE_2__["tau"];
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math__WEBPACK_IMPORTED_MODULE_2__["tau"];
  }

  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["spherical"])([cosRadius, -sinRadius * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(t), -sinRadius * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(t)]);
    stream.point(point[0], point[1]);
  }
} // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].

function circleRadius(cosRadius, point) {
  point = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(point), point[0] -= cosRadius;
  Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianNormalizeInPlace"])(point);
  var radius = Object(_math__WEBPACK_IMPORTED_MODULE_2__["acos"])(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math__WEBPACK_IMPORTED_MODULE_2__["tau"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) % _math__WEBPACK_IMPORTED_MODULE_2__["tau"];
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var center = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([0, 0]),
      radius = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(90),
      precision = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(6),
      ring,
      rotate,
      stream = {
    point: point
  };

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math__WEBPACK_IMPORTED_MODULE_2__["degrees"], x[1] *= _math__WEBPACK_IMPORTED_MODULE_2__["degrees"];
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math__WEBPACK_IMPORTED_MODULE_2__["radians"],
        p = precision.apply(this, arguments) * _math__WEBPACK_IMPORTED_MODULE_2__["radians"];
    ring = [];
    rotate = Object(_rotation__WEBPACK_IMPORTED_MODULE_3__["rotateRadians"])(-c[0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], -c[1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], 0).invert;
    circleStream(stream, r, p, 1);
    c = {
      type: "Polygon",
      coordinates: [ring]
    };
    ring = rotate = null;
    return c;
  }

  circle.center = function (_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), circle) : radius;
  };

  circle.precision = function (_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), circle) : precision;
  };

  return circle;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/antimeridian.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/antimeridian.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_index__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  return true;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]])); // Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.

function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      _clean; // no intersections


  return {
    lineStart: function lineStart() {
      stream.lineStart();
      _clean = 1;
    },
    point: function point(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["pi"],
          delta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda1 - lambda0);

      if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta - _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
        // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        _clean = 0;
      } else if (sign0 !== sign1 && delta >= _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) {
        // line crosses antimeridian
        if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda0 - sign0) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) lambda0 -= sign0 * _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; // handle degeneracies

        if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda1 - sign1) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) lambda1 -= sign1 * _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        _clean = 0;
      }

      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function lineEnd() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function clean() {
      return 2 - _clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda0 - lambda1);
  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(sinLambda0Lambda1) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])((Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0) * (cosPhi1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi1)) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda1) - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi1) * (cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0)) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;

  if (from == null) {
    phi = direction * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"];
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
    stream.point(0, phi);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__["pi"], 0);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__["pi"], -phi);
    stream.point(0, -phi);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], -phi);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], 0);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
  } else if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(from[0] - to[0]) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
    var lambda = from[0] < to[0] ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["pi"];
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/buffer.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/buffer.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var lines = [],
      line;
  return {
    point: function point(x, y) {
      line.push([x, y]);
    },
    lineStart: function lineStart() {
      lines.push(line = []);
    },
    lineEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function rejoin() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function result() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
});

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/circle.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/circle.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle */ "./node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pointEqual */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/clip/index.js");





/* harmony default export */ __webpack_exports__["default"] = (function (radius) {
  var cr = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(radius),
      delta = 6 * _math__WEBPACK_IMPORTED_MODULE_2__["radians"],
      smallRadius = cr > 0,
      notHemisphere = Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(cr) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    Object(_circle__WEBPACK_IMPORTED_MODULE_1__["circleStream"])(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda) * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi) > cr;
  } // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.


  function clipLine(stream) {
    var point0, // previous point
    c0, // code for previous point
    v0, // visibility of previous point
    v00, // visibility of first point
    _clean; // no intersections


    return {
      lineStart: function lineStart() {
        v00 = v0 = false;
        _clean = 1;
      },
      point: function point(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math__WEBPACK_IMPORTED_MODULE_2__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_2__["pi"]), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart(); // Handle degeneracies.
        // TODO ignore if not clipping polygons.

        if (v !== v0) {
          point2 = intersect(point0, point1);

          if (!point2 || Object(_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point0, point2) || Object(_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point1, point2)) {
            point1[0] += _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
            point1[1] += _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
            v = visible(point1[0], point1[1]);
          }
        }

        if (v !== v0) {
          _clean = 0;

          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }

          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t; // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.

          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            _clean = 0;

            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }

        if (v && (!point0 || !Object(_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }

        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function lineEnd() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function clean() {
        return _clean | (v00 && v0) << 1;
      }
    };
  } // Intersects the great circle between a and b with the clip circle.


  function intersect(a, b, two) {
    var pa = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(a),
        pb = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(b); // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).

    var n1 = [1, 0, 0],
        // normal
    n2 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianCross"])(pa, pb),
        n2n2 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(n2, n2),
        n1n2 = n2[0],
        // cartesianDot(n1, n2),
    determinant = n2n2 - n1n2 * n1n2; // Two polar points.

    if (!determinant) return !two && a;
    var c1 = cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianCross"])(n1, n2),
        A = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(n1, c1),
        B = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(n2, c2);
    Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(A, B); // Solve |p(t)|^2 = 1.

    var u = n1xn2,
        w = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(A, u),
        uu = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(u, u),
        t2 = w * w - uu * (Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(A, A) - 1);
    if (t2 < 0) return;
    var t = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(t2),
        q = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(u, (-w - t) / uu);
    Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(q, A);
    q = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["spherical"])(q);
    if (!two) return q; // Two intersection points.

    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta = lambda1 - lambda0,
        polar = Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(delta - _math__WEBPACK_IMPORTED_MODULE_2__["pi"]) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"],
        meridian = polar || delta < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.

    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(q[0] - lambda0) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math__WEBPACK_IMPORTED_MODULE_2__["pi"] ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(u, (-w + t) / uu);
      Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(q1, A);
      return [q, Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["spherical"])(q1)];
    }
  } // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.


  function code(lambda, phi) {
    var r = smallRadius ? radius : _math__WEBPACK_IMPORTED_MODULE_2__["pi"] - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right

    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above

    return code;
  }

  return Object(_index__WEBPACK_IMPORTED_MODULE_4__["default"])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math__WEBPACK_IMPORTED_MODULE_2__["pi"], radius - _math__WEBPACK_IMPORTED_MODULE_2__["pi"]]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/extent.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rectangle */ "./node_modules/d3-geo/src/clip/rectangle.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;
  return clip = {
    stream: function stream(_stream) {
      return cache && cacheStream === _stream ? cache : cache = Object(_rectangle__WEBPACK_IMPORTED_MODULE_0__["default"])(x0, y0, x1, y1)(cacheStream = _stream);
    },
    extent: function extent(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
});

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _rejoin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rejoin */ "./node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../polygonContains */ "./node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");





/* harmony default export */ __webpack_exports__["default"] = (function (pointVisible, clipLine, interpolate, start) {
  return function (sink) {
    var line = clipLine(sink),
        ringBuffer = Object(_buffer__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;
    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function polygonStart() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function polygonEnd() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = Object(d3_array__WEBPACK_IMPORTED_MODULE_4__["merge"])(segments);
        var startInside = Object(_polygonContains__WEBPACK_IMPORTED_MODULE_3__["default"])(polygon, start);

        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          Object(_rejoin__WEBPACK_IMPORTED_MODULE_1__["default"])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }

        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function sphere() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i,
          n = ringSegments.length,
          m,
          segment,
          point;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return; // No intersections.

      if (clean & 1) {
        segment = ringSegments[0];

        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();

          for (i = 0; i < m; ++i) {
            sink.point((point = segment[i])[0], point[1]);
          }

          sink.lineEnd();
        }

        return;
      } // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?


      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
});

function validSegment(segment) {
  return segment.length > 1;
} // Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.


function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] : _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - a[1]) - ((b = b.x)[0] < 0 ? b[1] - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] : _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - b[1]);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/line.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/line.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;
  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;

  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;

  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;

  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;

  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rectangle.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rectangle.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return clipRectangle; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin */ "./node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");





var clipMax = 1e9,
    clipMin = -clipMax; // TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {
  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0,
        a1 = 0;

    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do {
        stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      } while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[0] - x0) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 0 : 3 : Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[0] - x1) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 2 : 1 : Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[1] - y0) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
  }

  return function (stream) {
    var activeStream = stream,
        bufferStream = Object(_buffer__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__,
        y__,
        v__,
        // first point
    x_,
        y_,
        v_,
        // previous point
    first,
        clean;
    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];

          if (a1 <= y1) {
            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
          } else {
            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
          }
        }
      }

      return winding;
    } // Buffer geometry within a polygon and then clip it en masse.


    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = Object(d3_array__WEBPACK_IMPORTED_MODULE_4__["merge"])(segments)).length;

      if (cleanInside || visible) {
        stream.polygonStart();

        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }

        if (visible) {
          Object(_rejoin__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }

        stream.polygonEnd();
      }

      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    } // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.


    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }

      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);

      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;

        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];

          if (Object(_line__WEBPACK_IMPORTED_MODULE_2__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }

            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }

      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rejoin.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rejoin.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual */ "./node_modules/d3-geo/src/pointEqual.js");


function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection

  this.e = entry; // is an entry?

  this.v = false; // visited

  this.n = this.p = null; // next & previous
} // A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.


/* harmony default export */ __webpack_exports__["default"] = (function (segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;
  segments.forEach(function (segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n,
        p0 = segment[0],
        p1 = segment[n],
        x; // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.

    if (Object(_pointEqual__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      stream.lineStart();

      for (i = 0; i < n; ++i) {
        stream.point((p0 = segment[i])[0], p0[1]);
      }

      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;

    while (current.v) {
      if ((current = current.n) === start) return;
    }

    points = current.z;
    stream.lineStart();

    do {
      current.v = current.o.v = true;

      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) {
            stream.point((point = points[i])[0], point[1]);
          }
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }

        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;

          for (i = points.length - 1; i >= 0; --i) {
            stream.point((point = points[i])[0], point[1]);
          }
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }

        current = current.p;
      }

      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);

    stream.lineEnd();
  }
});

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;

  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }

  a.n = b = array[0];
  b.p = a;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/compose.js":
/*!********************************************!*\
  !*** ./node_modules/d3-geo/src/compose.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function (x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };
  return compose;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/constant.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/constant.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-geo/src/contains.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/contains.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _polygonContains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polygonContains */ "./node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var _distance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distance */ "./node_modules/d3-geo/src/distance.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



var containsObjectType = {
  Feature: function Feature(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function FeatureCollection(object, point) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) {
      if (containsGeometry(features[i].geometry, point)) return true;
    }

    return false;
  }
};
var containsGeometryType = {
  Sphere: function Sphere() {
    return true;
  },
  Point: function Point(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function MultiPoint(object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      if (containsPoint(coordinates[i], point)) return true;
    }

    return false;
  },
  LineString: function LineString(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function MultiLineString(object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      if (containsLine(coordinates[i], point)) return true;
    }

    return false;
  },
  Polygon: function Polygon(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function MultiPolygon(object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      if (containsPolygon(coordinates[i], point)) return true;
    }

    return false;
  },
  GeometryCollection: function GeometryCollection(object, point) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) {
      if (containsGeometry(geometries[i], point)) return true;
    }

    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
}

function containsPoint(coordinates, point) {
  return Object(_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = Object(_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates[0], coordinates[1]),
      ao = Object(_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates[0], point),
      ob = Object(_distance__WEBPACK_IMPORTED_MODULE_1__["default"])(point, coordinates[1]);
  return ao + ob <= ab + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
}

function containsPolygon(coordinates, point) {
  return !!Object(_polygonContains__WEBPACK_IMPORTED_MODULE_0__["default"])(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], point[1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"]];
}

/* harmony default export */ __webpack_exports__["default"] = (function (object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/distance.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/distance.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./length */ "./node_modules/d3-geo/src/length.js");

var coordinates = [null, null],
    object = {
  type: "LineString",
  coordinates: coordinates
};
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return Object(_length__WEBPACK_IMPORTED_MODULE_0__["default"])(object);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/graticule.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/graticule.js ***!
  \**********************************************/
/*! exports provided: default, graticule10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return graticule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "graticule10", function() { return graticule10; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(y0, y1 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"], dy).concat(y1);
  return function (x) {
    return y.map(function (y) {
      return [x, y];
    });
  };
}

function graticuleY(x0, x1, dx) {
  var x = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(x0, x1 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"], dx).concat(x1);
  return function (y) {
    return x.map(function (x) {
      return [x, y];
    });
  };
}

function graticule() {
  var x1,
      x0,
      X1,
      X0,
      y1,
      y0,
      Y1,
      Y0,
      dx = 10,
      dy = dx,
      DX = 90,
      DY = 360,
      x,
      y,
      X,
      Y,
      precision = 2.5;

  function graticule() {
    return {
      type: "MultiLineString",
      coordinates: lines()
    };
  }

  function lines() {
    return Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(X0 / DX) * DX, X1, DX).map(X).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(Y0 / DY) * DY, Y1, DY).map(Y)).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(x0 / dx) * dx, x1, dx).filter(function (x) {
      return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x % DX) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
    }).map(x)).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(y0 / dy) * dy, y1, dy).filter(function (y) {
      return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y % DY) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
    }).map(y));
  }

  graticule.lines = function () {
    return lines().map(function (coordinates) {
      return {
        type: "LineString",
        coordinates: coordinates
      };
    });
  };

  graticule.outline = function () {
    return {
      type: "Polygon",
      coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
    };
  };

  graticule.extent = function (_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function (_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function (_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function (_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function (_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function (_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function (_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule.extentMajor([[-180, -90 + _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]], [180, 90 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]]]).extentMinor([[-180, -80 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]], [180, 80 + _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]]]);
}
function graticule10() {
  return graticule()();
}

/***/ }),

/***/ "./node_modules/d3-geo/src/identity.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/identity.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/interpolate.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/interpolate.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var x0 = a[0] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      y0 = a[1] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      x1 = b[0] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      y1 = b[1] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      cy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      sy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0),
      cy1 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1),
      sy1 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y1),
      kx0 = cy0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x0),
      ky0 = cy0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x0),
      kx1 = cy1 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x1),
      ky1 = cy1 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x1),
      d = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["haversin"])(y1 - y0) + cy0 * cy1 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["haversin"])(x1 - x0))),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(d);
  var interpolate = d ? function (t) {
    var B = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(t *= d) / k,
        A = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(y, x) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(z, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + y * y)) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  } : function () {
    return [x0 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], y0 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  };
  interpolate.distance = d;
  return interpolate;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/length.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/length.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");




var lengthSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lambda0,
    sinPhi0,
    cosPhi0;
var lengthStream = {
  sphere: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: lengthLineStart,
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"]
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
}

function lengthPointFirst(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  lambda0 = lambda, sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi), cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      delta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda - lambda0),
      cosDelta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(delta),
      sinDelta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + y * y), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}

/* harmony default export */ __webpack_exports__["default"] = (function (object) {
  lengthSum.reset();
  Object(_stream__WEBPACK_IMPORTED_MODULE_3__["default"])(object, lengthStream);
  return +lengthSum;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/math.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/math.js ***!
  \*****************************************/
/*! exports provided: epsilon, epsilon2, pi, halfPi, quarterPi, tau, degrees, radians, abs, atan, atan2, cos, ceil, exp, floor, log, pow, sin, sign, sqrt, tan, acos, asin, haversin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon2", function() { return epsilon2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pi", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPi", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quarterPi", function() { return quarterPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tau", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "haversin", function() { return haversin; });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function (x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}
function haversin(x) {
  return (x = sin(x / 2)) * x;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/noop.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/noop.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return noop; });
function noop() {}

/***/ }),

/***/ "./node_modules/d3-geo/src/path/area.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/path/area.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");



var areaSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    areaRingSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    x00,
    y00,
    x0,
    y0;
var areaStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: function polygonStart() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function polygonEnd() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
    areaSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(areaRingSum));
    areaRingSum.reset();
  },
  result: function result() {
    var area = areaSum / 2;
    areaSum.reset();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ __webpack_exports__["default"] = (areaStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/bounds.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/bounds.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");

var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function result() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ __webpack_exports__["default"] = (boundsStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/centroid.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-geo/src/path/centroid.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
 // TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function polygonStart() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function polygonEnd() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function result() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ __webpack_exports__["default"] = (centroidStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/context.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/context.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathContext; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");


function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function pointRadius(_) {
    return this._radius = _, this;
  },
  polygonStart: function polygonStart() {
    this._line = 0;
  },
  polygonEnd: function polygonEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function point(x, y) {
    switch (this._point) {
      case 0:
        {
          this._context.moveTo(x, y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._context.lineTo(x, y);

          break;
        }

      default:
        {
          this._context.moveTo(x + this._radius, y);

          this._context.arc(x, y, this._radius, 0, _math__WEBPACK_IMPORTED_MODULE_0__["tau"]);

          break;
        }
    }
  },
  result: _noop__WEBPACK_IMPORTED_MODULE_1__["default"]
};

/***/ }),

/***/ "./node_modules/d3-geo/src/path/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/path/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stream */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./area */ "./node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds */ "./node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid */ "./node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context */ "./node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _measure__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./measure */ "./node_modules/d3-geo/src/path/measure.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./string */ "./node_modules/d3-geo/src/path/string.js");








/* harmony default export */ __webpack_exports__["default"] = (function (projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(contextStream));
    }

    return contextStream.result();
  }

  path.area = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_area__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return _area__WEBPACK_IMPORTED_MODULE_2__["default"].result();
  };

  path.measure = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_measure__WEBPACK_IMPORTED_MODULE_6__["default"]));
    return _measure__WEBPACK_IMPORTED_MODULE_6__["default"].result();
  };

  path.bounds = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_bounds__WEBPACK_IMPORTED_MODULE_3__["default"]));
    return _bounds__WEBPACK_IMPORTED_MODULE_3__["default"].result();
  };

  path.centroid = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_centroid__WEBPACK_IMPORTED_MODULE_4__["default"]));
    return _centroid__WEBPACK_IMPORTED_MODULE_4__["default"].result();
  };

  path.projection = function (_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity__WEBPACK_IMPORTED_MODULE_0__["default"]) : (projection = _).stream, path) : projection;
  };

  path.context = function (_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string__WEBPACK_IMPORTED_MODULE_7__["default"]()) : new _context__WEBPACK_IMPORTED_MODULE_5__["default"](context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function (_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/path/measure.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/measure.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");



var lengthSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;
var lengthStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: function lineStart() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function lineEnd() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
  },
  polygonStart: function polygonStart() {
    lengthRing = true;
  },
  polygonEnd: function polygonEnd() {
    lengthRing = null;
  },
  result: function result() {
    var length = +lengthSum;
    lengthSum.reset();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ __webpack_exports__["default"] = (lengthStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/string.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/string.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathString; });
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function pointRadius(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function polygonStart() {
    this._line = 0;
  },
  polygonEnd: function polygonEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function point(x, y) {
    switch (this._point) {
      case 0:
        {
          this._string.push("M", x, ",", y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._string.push("L", x, ",", y);

          break;
        }

      default:
        {
          if (this._circle == null) this._circle = circle(this._radius);

          this._string.push("M", x, ",", y, this._circle);

          break;
        }
    }
  },
  result: function result() {
    if (this._string.length) {
      var result = this._string.join("");

      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

/***/ }),

/***/ "./node_modules/d3-geo/src/pointEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/pointEqual.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(a[0] - b[0]) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] && Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(a[1] - b[1]) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"];
});

/***/ }),

/***/ "./node_modules/d3-geo/src/polygonContains.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo/src/polygonContains.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



var sum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])();
/* harmony default export */ __webpack_exports__["default"] = (function (polygon, point) {
  var lambda = point[0],
      phi = point[1],
      sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi),
      normal = [Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(lambda), -Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda), 0],
      angle = 0,
      winding = 0;
  sum.reset();
  if (sinPhi === 1) phi = _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];else if (sinPhi === -1) phi = -_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + _math__WEBPACK_IMPORTED_MODULE_2__["quarterPi"],
        sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi0),
        cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + _math__WEBPACK_IMPORTED_MODULE_2__["quarterPi"],
          sinPhi1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi1),
          cosPhi1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math__WEBPACK_IMPORTED_MODULE_2__["pi"],
          k = sinPhi0 * sinPhi1;
      sum.add(Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(k * sign * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(absDelta), cosPhi0 * cosPhi1 + k * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(absDelta)));
      angle += antimeridian ? delta + sign * _math__WEBPACK_IMPORTED_MODULE_2__["tau"] : delta; // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?

      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianCross"])(Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesian"])(point0), Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesian"])(point1));
        Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianNormalizeInPlace"])(arc);
        var intersection = Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianCross"])(normal, arc);
        Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianNormalizeInPlace"])(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * Object(_math__WEBPACK_IMPORTED_MODULE_2__["asin"])(intersection[2]);

        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  } // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.


  return (angle < -_math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] || angle < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] && sum < -_math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) ^ winding & 1;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/albers.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/albers.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _conicEqualArea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./conicEqualArea */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conicEqualArea__WEBPACK_IMPORTED_MODULE_0__["default"])().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/albersUsa.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/albersUsa.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _albers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./albers */ "./node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var _conicEqualArea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conicEqualArea */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo/src/projection/fit.js");



 // The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.

function multiplex(streams) {
  var n = streams.length;
  return {
    point: function point(x, y) {
      var i = -1;

      while (++i < n) {
        streams[i].point(x, y);
      }
    },
    sphere: function sphere() {
      var i = -1;

      while (++i < n) {
        streams[i].sphere();
      }
    },
    lineStart: function lineStart() {
      var i = -1;

      while (++i < n) {
        streams[i].lineStart();
      }
    },
    lineEnd: function lineEnd() {
      var i = -1;

      while (++i < n) {
        streams[i].lineEnd();
      }
    },
    polygonStart: function polygonStart() {
      var i = -1;

      while (++i < n) {
        streams[i].polygonStart();
      }
    },
    polygonEnd: function polygonEnd() {
      var i = -1;

      while (++i < n) {
        streams[i].polygonEnd();
      }
    }
  };
} // A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers


/* harmony default export */ __webpack_exports__["default"] = (function () {
  var cache,
      cacheStream,
      lower48 = Object(_albers__WEBPACK_IMPORTED_MODULE_1__["default"])(),
      lower48Point,
      alaska = Object(_conicEqualArea__WEBPACK_IMPORTED_MODULE_2__["default"])().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
      alaskaPoint,
      // EPSG:3338
  hawaii = Object(_conicEqualArea__WEBPACK_IMPORTED_MODULE_2__["default"])().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
      hawaiiPoint,
      // ESRI:102007
  _point,
      pointStream = {
    point: function point(x, y) {
      _point = [x, y];
    }
  };

  function albersUsa(coordinates) {
    var x = coordinates[0],
        y = coordinates[1];
    return _point = null, (lower48Point.point(x, y), _point) || (alaskaPoint.point(x, y), _point) || (hawaiiPoint.point(x, y), _point);
  }

  albersUsa.invert = function (coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
  };

  albersUsa.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function (_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function (_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function (_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(),
        x = +_[0],
        y = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
    alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.120 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]], [x - 0.214 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.234 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.166 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]], [x - 0.115 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.234 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]]]).stream(pointStream);
    return reset();
  };

  albersUsa.fitExtent = function (extent, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitExtent"])(albersUsa, extent, object);
  };

  albersUsa.fitSize = function (size, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitSize"])(albersUsa, size, object);
  };

  albersUsa.fitWidth = function (width, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitWidth"])(albersUsa, width, object);
  };

  albersUsa.fitHeight = function (height, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitHeight"])(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthal.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthal.js ***!
  \*********************************************************/
/*! exports provided: azimuthalRaw, azimuthalInvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalRaw", function() { return azimuthalRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalInvert", function() { return azimuthalInvert; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");

function azimuthalRaw(scale) {
  return function (x, y) {
    var cx = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x),
        cy = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y),
        k = scale(cx * cy);
    return [k * cy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x), k * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)];
  };
}
function azimuthalInvert(angle) {
  return function (x, y) {
    var z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + y * y),
        c = angle(z),
        sc = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(c),
        cc = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(c);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x * sc, z * cc), Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(z && y * sc / z)];
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthalEqualArea.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthalEqualArea.js ***!
  \******************************************************************/
/*! exports provided: azimuthalEqualAreaRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalEqualAreaRaw", function() { return azimuthalEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



var azimuthalEqualAreaRaw = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalRaw"])(function (cxcy) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function (z) {
  return 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(z / 2);
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthalEquidistant.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthalEquidistant.js ***!
  \********************************************************************/
/*! exports provided: azimuthalEquidistantRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalEquidistantRaw", function() { return azimuthalEquidistantRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



var azimuthalEquidistantRaw = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalRaw"])(function (c) {
  return (c = Object(_math__WEBPACK_IMPORTED_MODULE_0__["acos"])(c)) && c / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(c);
});
azimuthalEquidistantRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function (z) {
  return z;
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conic.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conic.js ***!
  \*****************************************************/
/*! exports provided: conicProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicProjection", function() { return conicProjection; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");


function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = _math__WEBPACK_IMPORTED_MODULE_0__["pi"] / 3,
      m = Object(_index__WEBPACK_IMPORTED_MODULE_1__["projectionMutator"])(projectAt),
      p = m(phi0, phi1);

  p.parallels = function (_) {
    return arguments.length ? m(phi0 = _[0] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi1 = _[1] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"]) : [phi0 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], phi1 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  };

  return p;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicConformal.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicConformal.js ***!
  \**************************************************************/
/*! exports provided: conicConformalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicConformalRaw", function() { return conicConformalRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _mercator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mercator */ "./node_modules/d3-geo/src/projection/mercator.js");




function tany(y) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      n = y0 === y1 ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0) : Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(cy0 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1)) / Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(tany(y1) / tany(y0)),
      f = cy0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(tany(y0), n) / n;
  if (!n) return _mercator__WEBPACK_IMPORTED_MODULE_2__["mercatorRaw"];

  function project(x, y) {
    if (f > 0) {
      if (y < -_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) y = -_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"];
    } else {
      if (y > _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) y = _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"];
    }

    var r = f / Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(tany(y), n);
    return [r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(n * x), f - r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(n * x)];
  }

  project.invert = function (x, y) {
    var fy = f - y,
        r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(n) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + fy * fy);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(fy)) / n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(fy), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(f / r, 1 / n)) - _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
  };

  return project;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conic__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicConformalRaw).scale(109.5).parallels([30, 30]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicEqualArea.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicEqualArea.js ***!
  \**************************************************************/
/*! exports provided: conicEqualAreaRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicEqualAreaRaw", function() { return conicEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cylindricalEqualArea */ "./node_modules/d3-geo/src/projection/cylindricalEqualArea.js");



function conicEqualAreaRaw(y0, y1) {
  var sy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0),
      n = (sy0 + Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y1)) / 2; // Are the parallels symmetrical around the Equator?

  if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(n) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) return Object(_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_2__["cylindricalEqualAreaRaw"])(y0);
  var c = 1 + sy0 * (2 * n - sy0),
      r0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(c) / n;

  function project(x, y) {
    var r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(c - 2 * n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)) / n;
    return [r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x *= n), r0 - r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x)];
  }

  project.invert = function (x, y) {
    var r0y = r0 - y;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(r0y)) / n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(r0y), Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conic__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicEquidistant.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicEquidistant.js ***!
  \****************************************************************/
/*! exports provided: conicEquidistantRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicEquidistantRaw", function() { return conicEquidistantRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _equirectangular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equirectangular */ "./node_modules/d3-geo/src/projection/equirectangular.js");



function conicEquidistantRaw(y0, y1) {
  var cy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      n = y0 === y1 ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0) : (cy0 - Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1)) / (y1 - y0),
      g = cy0 / n + y0;
  if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(n) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) return _equirectangular__WEBPACK_IMPORTED_MODULE_2__["equirectangularRaw"];

  function project(x, y) {
    var gy = g - y,
        nx = n * x;
    return [gy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(nx), g - gy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(nx)];
  }

  project.invert = function (x, y) {
    var gy = g - y;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(gy)) / n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(gy), g - Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(n) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + gy * gy)];
  };

  return project;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conic__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/cylindricalEqualArea.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/cylindricalEqualArea.js ***!
  \********************************************************************/
/*! exports provided: cylindricalEqualAreaRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cylindricalEqualAreaRaw", function() { return cylindricalEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi) / cosPhi0];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(y * cosPhi0)];
  };

  return forward;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/equirectangular.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/equirectangular.js ***!
  \***************************************************************/
/*! exports provided: equirectangularRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equirectangularRaw", function() { return equirectangularRaw; });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_0__["default"])(equirectangularRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/fit.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/fit.js ***!
  \***************************************************/
/*! exports provided: fitExtent, fitSize, fitWidth, fitHeight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitExtent", function() { return fitExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitSize", function() { return fitSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitWidth", function() { return fitWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitHeight", function() { return fitHeight; });
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds */ "./node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  Object(_stream__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds__WEBPACK_IMPORTED_MODULE_1__["default"]));
  fitBounds(_path_bounds__WEBPACK_IMPORTED_MODULE_1__["default"].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function (b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}
function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}
function fitWidth(projection, width, object) {
  return fit(projection, function (b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}
function fitHeight(projection, height, object) {
  return fit(projection, function (b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/gnomonic.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/gnomonic.js ***!
  \********************************************************/
/*! exports provided: gnomonicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gnomonicRaw", function() { return gnomonicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function gnomonicRaw(x, y) {
  var cy = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x) * cy;
  return [cy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x) / k, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y) / k];
}
gnomonicRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(_math__WEBPACK_IMPORTED_MODULE_0__["atan"]);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(gnomonicRaw).scale(144.049).clipAngle(60);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/identity.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/identity.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _clip_rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clip/rectangle */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo/src/projection/fit.js");





function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? _identity__WEBPACK_IMPORTED_MODULE_1__["default"] : Object(_transform__WEBPACK_IMPORTED_MODULE_2__["transformer"])({
    point: function point(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var k = 1,
      tx = 0,
      ty = 0,
      sx = 1,
      sy = 1,
      transform = _identity__WEBPACK_IMPORTED_MODULE_1__["default"],
      // scale, translate and reflect
  x0 = null,
      y0,
      x1,
      y1,
      // clip extent
  _postclip = _identity__WEBPACK_IMPORTED_MODULE_1__["default"],
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function stream(_stream) {
      return cache && cacheStream === _stream ? cache : cache = transform(_postclip(cacheStream = _stream));
    },
    postclip: function postclip(_) {
      return arguments.length ? (_postclip = _, x0 = y0 = x1 = y1 = null, reset()) : _postclip;
    },
    clipExtent: function clipExtent(_) {
      return arguments.length ? (_postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity__WEBPACK_IMPORTED_MODULE_1__["default"]) : Object(_clip_rectangle__WEBPACK_IMPORTED_MODULE_0__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function scale(_) {
      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function translate(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function reflectX(_) {
      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function reflectY(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function fitExtent(extent, object) {
      return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitExtent"])(projection, extent, object);
    },
    fitSize: function fitSize(size, object) {
      return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitSize"])(projection, size, object);
    },
    fitWidth: function fitWidth(width, object) {
      return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitWidth"])(projection, width, object);
    },
    fitHeight: function fitHeight(height, object) {
      return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitHeight"])(projection, height, object);
    }
  };
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/index.js ***!
  \*****************************************************/
/*! exports provided: default, projectionMutator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectionMutator", function() { return projectionMutator; });
/* harmony import */ var _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clip/antimeridian */ "./node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../clip/circle */ "./node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/rectangle */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../compose */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rotation */ "./node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./resample */ "./node_modules/d3-geo/src/projection/resample.js");










var transformRadians = Object(_transform__WEBPACK_IMPORTED_MODULE_7__["transformer"])({
  point: function point(x, y) {
    this.stream.point(x * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], y * _math__WEBPACK_IMPORTED_MODULE_5__["radians"]);
  }
});

function transformRotate(rotate) {
  return Object(_transform__WEBPACK_IMPORTED_MODULE_7__["transformer"])({
    point: function point(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy) {
  function transform(x, y) {
    return [dx + k * x, dy - k * y];
  }

  transform.invert = function (x, y) {
    return [(x - dx) / k, (dy - y) / k];
  };

  return transform;
}

function scaleTranslateRotate(k, dx, dy, alpha) {
  var cosAlpha = Object(_math__WEBPACK_IMPORTED_MODULE_5__["cos"])(alpha),
      sinAlpha = Object(_math__WEBPACK_IMPORTED_MODULE_5__["sin"])(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;

  function transform(x, y) {
    return [a * x - b * y + dx, dy - b * x - a * y];
  }

  transform.invert = function (x, y) {
    return [ai * x - bi * y + ci, fi - bi * x - ai * y];
  };

  return transform;
}

function projection(project) {
  return projectionMutator(function () {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project,
      k = 150,
      // scale
  x = 480,
      y = 250,
      // translate
  lambda = 0,
      phi = 0,
      // center
  deltaLambda = 0,
      deltaPhi = 0,
      deltaGamma = 0,
      rotate,
      // pre-rotate
  alpha = 0,
      // post-rotate
  theta = null,
      preclip = _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__["default"],
      // pre-clip angle
  x0 = null,
      y0,
      x1,
      y1,
      postclip = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      // post-clip extent
  delta2 = 0.5,
      // precision
  projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], point[1] * _math__WEBPACK_IMPORTED_MODULE_5__["radians"]);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], point[1] * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  }

  projection.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function (_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function (_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function (_) {
    return arguments.length ? (preclip = +_ ? Object(_clip_circle__WEBPACK_IMPORTED_MODULE_1__["default"])(theta = _ * _math__WEBPACK_IMPORTED_MODULE_5__["radians"]) : (theta = null, _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__["default"]), reset()) : theta * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"];
  };

  projection.clipExtent = function (_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity__WEBPACK_IMPORTED_MODULE_4__["default"]) : Object(_clip_rectangle__WEBPACK_IMPORTED_MODULE_2__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function (_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function (_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function (_) {
    return arguments.length ? (lambda = _[0] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], phi = _[1] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], recenter()) : [lambda * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], phi * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  };

  projection.rotate = function (_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], deltaPhi = _[1] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], deltaGamma = _.length > 2 ? _[2] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"] : 0, recenter()) : [deltaLambda * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], deltaPhi * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], deltaGamma * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  };

  projection.angle = function (_) {
    return arguments.length ? (alpha = _ % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], recenter()) : alpha * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"];
  };

  projection.precision = function (_) {
    return arguments.length ? (projectResample = Object(_resample__WEBPACK_IMPORTED_MODULE_9__["default"])(projectTransform, delta2 = _ * _), reset()) : Object(_math__WEBPACK_IMPORTED_MODULE_5__["sqrt"])(delta2);
  };

  projection.fitExtent = function (extent, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_8__["fitExtent"])(projection, extent, object);
  };

  projection.fitSize = function (size, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_8__["fitSize"])(projection, size, object);
  };

  projection.fitWidth = function (width, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_8__["fitWidth"])(projection, width, object);
  };

  projection.fitHeight = function (height, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_8__["fitHeight"])(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),
        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
    rotate = Object(_rotation__WEBPACK_IMPORTED_MODULE_6__["rotateRadians"])(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = Object(_compose__WEBPACK_IMPORTED_MODULE_3__["default"])(project, transform);
    projectRotateTransform = Object(_compose__WEBPACK_IMPORTED_MODULE_3__["default"])(rotate, projectTransform);
    projectResample = Object(_resample__WEBPACK_IMPORTED_MODULE_9__["default"])(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function () {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/mercator.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/mercator.js ***!
  \********************************************************/
/*! exports provided: mercatorRaw, default, mercatorProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercatorRaw", function() { return mercatorRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercatorProjection", function() { return mercatorProjection; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rotation */ "./node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function mercatorRaw(lambda, phi) {
  return [lambda, Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + phi) / 2))];
}

mercatorRaw.invert = function (x, y) {
  return [x, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["exp"])(y)) - _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return mercatorProjection(mercatorRaw).scale(961 / _math__WEBPACK_IMPORTED_MODULE_0__["tau"]);
});
function mercatorProjection(project) {
  var m = Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null,
      y0,
      x1,
      y1; // clip extent

  m.scale = function (_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function (_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function (_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function (_) {
    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = _math__WEBPACK_IMPORTED_MODULE_0__["pi"] * scale(),
        t = m(Object(_rotation__WEBPACK_IMPORTED_MODULE_1__["default"])(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/naturalEarth1.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/naturalEarth1.js ***!
  \*************************************************************/
/*! exports provided: naturalEarth1Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "naturalEarth1Raw", function() { return naturalEarth1Raw; });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");


function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi,
      phi4 = phi2 * phi2;
  return [lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))), phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))];
}

naturalEarth1Raw.invert = function (x, y) {
  var phi = y,
      i = 25,
      delta;

  do {
    var phi2 = phi * phi,
        phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  return [x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_0__["default"])(naturalEarth1Raw).scale(175.295);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/orthographic.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/orthographic.js ***!
  \************************************************************/
/*! exports provided: orthographicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orthographicRaw", function() { return orthographicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function orthographicRaw(x, y) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)];
}
orthographicRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(_math__WEBPACK_IMPORTED_MODULE_0__["asin"]);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(orthographicRaw).scale(249.5).clipAngle(90 + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/resample.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/resample.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo/src/transform.js");



var maxDepth = 16,
    // maximum depth of subdivision
cosMinDistance = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(30 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]); // cos(minimum angular distance)

/* harmony default export */ __webpack_exports__["default"] = (function (project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
});

function resampleNone(project) {
  return Object(_transform__WEBPACK_IMPORTED_MODULE_2__["transformer"])({
    point: function point(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {
  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;

    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a * a + b * b + c * c),
          phi2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(c /= m),
          lambda2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(c) - 1) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda0 - lambda1) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? (lambda0 + lambda1) / 2 : Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;

      if (dz * dz / d2 > delta2 // perpendicular projected distance
      || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
      || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }

  return function (stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
    lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function polygonStart() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function polygonEnd() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])([lambda, phi]),
          p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/stereographic.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/stereographic.js ***!
  \*************************************************************/
/*! exports provided: stereographicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stereographicRaw", function() { return stereographicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function stereographicRaw(x, y) {
  var cy = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y),
      k = 1 + Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x) * cy;
  return [cy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x) / k, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y) / k];
}
stereographicRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function (z) {
  return 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(z);
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(stereographicRaw).scale(250).clipAngle(142);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/transverseMercator.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/transverseMercator.js ***!
  \******************************************************************/
/*! exports provided: transverseMercatorRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transverseMercatorRaw", function() { return transverseMercatorRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator */ "./node_modules/d3-geo/src/projection/mercator.js");


function transverseMercatorRaw(lambda, phi) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function (x, y) {
  return [-y, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["exp"])(x)) - _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var m = Object(_mercator__WEBPACK_IMPORTED_MODULE_1__["mercatorProjection"])(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function (_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function (_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90]).scale(159.155);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/rotation.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/rotation.js ***!
  \*********************************************/
/*! exports provided: rotateRadians, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateRadians", function() { return rotateRadians; });
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compose */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda - _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda < -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda + _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math__WEBPACK_IMPORTED_MODULE_1__["tau"]) ? deltaPhi || deltaGamma ? Object(_compose__WEBPACK_IMPORTED_MODULE_0__["default"])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}

function forwardRotationLambda(deltaLambda) {
  return function (lambda, phi) {
    return lambda += deltaLambda, [lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda - _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda < -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda + _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(deltaPhi),
      sinDeltaPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(deltaPhi),
      cosDeltaGamma = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(deltaGamma),
      sinDeltaGamma = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
        y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(k * cosDeltaGamma + y * sinDeltaGamma)];
  }

  rotation.invert = function (lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
        y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(k * cosDeltaPhi - x * sinDeltaPhi)];
  };

  return rotation;
}

/* harmony default export */ __webpack_exports__["default"] = (function (rotate) {
  rotate = rotateRadians(rotate[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], rotate[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], rotate.length > 2 ? rotate[2] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"] : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
    return coordinates[0] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates[1] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates;
  }

  forward.invert = function (coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
    return coordinates[0] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates[1] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates;
  };

  return forward;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/stream.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/stream.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function Feature(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function FeatureCollection(object, stream) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) {
      streamGeometry(features[i].geometry, stream);
    }
  }
};
var streamGeometryType = {
  Sphere: function Sphere(object, stream) {
    stream.sphere();
  },
  Point: function Point(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function MultiPoint(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      object = coordinates[i], stream.point(object[0], object[1], object[2]);
    }
  },
  LineString: function LineString(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function MultiLineString(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      streamLine(coordinates[i], stream, 0);
    }
  },
  Polygon: function Polygon(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function MultiPolygon(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      streamPolygon(coordinates[i], stream);
    }
  },
  GeometryCollection: function GeometryCollection(object, stream) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) {
      streamGeometry(geometries[i], stream);
    }
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1,
      n = coordinates.length - closed,
      coordinate;
  stream.lineStart();

  while (++i < n) {
    coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  }

  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1,
      n = coordinates.length;
  stream.polygonStart();

  while (++i < n) {
    streamLine(coordinates[i], stream, 1);
  }

  stream.polygonEnd();
}

/* harmony default export */ __webpack_exports__["default"] = (function (object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
});

/***/ }),

/***/ "./node_modules/d3-geo/src/transform.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/transform.js ***!
  \**********************************************/
/*! exports provided: default, transformer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformer", function() { return transformer; });
/* harmony default export */ __webpack_exports__["default"] = (function (methods) {
  return {
    stream: transformer(methods)
  };
});
function transformer(methods) {
  return function (stream) {
    var s = new TransformStream();

    for (var key in methods) {
      s[key] = methods[key];
    }

    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function point(x, y) {
    this.stream.point(x, y);
  },
  sphere: function sphere() {
    this.stream.sphere();
  },
  lineStart: function lineStart() {
    this.stream.lineStart();
  },
  lineEnd: function lineEnd() {
    this.stream.lineEnd();
  },
  polygonStart: function polygonStart() {
    this.stream.polygonStart();
  },
  polygonEnd: function polygonEnd() {
    this.stream.polygonEnd();
  }
};

/***/ }),

/***/ "./node_modules/d3-interpolate/index.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-interpolate/index.js ***!
  \**********************************************/
/*! exports provided: interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateNumber, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, piecewise, quantize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/value */ "./node_modules/d3-interpolate/src/value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return _src_value__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/array */ "./node_modules/d3-interpolate/src/array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return _src_array__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_basis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/basis */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return _src_basis__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_basisClosed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/basisClosed */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return _src_basisClosed__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_date__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/date */ "./node_modules/d3-interpolate/src/date.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return _src_date__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/number */ "./node_modules/d3-interpolate/src/number.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return _src_number__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/object */ "./node_modules/d3-interpolate/src/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return _src_object__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_round__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/round */ "./node_modules/d3-interpolate/src/round.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return _src_round__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/string */ "./node_modules/d3-interpolate/src/string.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return _src_string__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_transform_index__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/transform/index */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return _src_transform_index__WEBPACK_IMPORTED_MODULE_9__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return _src_transform_index__WEBPACK_IMPORTED_MODULE_9__["interpolateTransformSvg"]; });

/* harmony import */ var _src_zoom__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/zoom */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return _src_zoom__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _src_rgb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/rgb */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return _src_rgb__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return _src_rgb__WEBPACK_IMPORTED_MODULE_11__["rgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return _src_rgb__WEBPACK_IMPORTED_MODULE_11__["rgbBasisClosed"]; });

/* harmony import */ var _src_hsl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/hsl */ "./node_modules/d3-interpolate/src/hsl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return _src_hsl__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return _src_hsl__WEBPACK_IMPORTED_MODULE_12__["hslLong"]; });

/* harmony import */ var _src_lab__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/lab */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return _src_lab__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _src_hcl__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/hcl */ "./node_modules/d3-interpolate/src/hcl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return _src_hcl__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return _src_hcl__WEBPACK_IMPORTED_MODULE_14__["hclLong"]; });

/* harmony import */ var _src_cubehelix__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/cubehelix */ "./node_modules/d3-interpolate/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return _src_cubehelix__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return _src_cubehelix__WEBPACK_IMPORTED_MODULE_15__["cubehelixLong"]; });

/* harmony import */ var _src_piecewise__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/piecewise */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewise", function() { return _src_piecewise__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _src_quantize__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/quantize */ "./node_modules/d3-interpolate/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _src_quantize__WEBPACK_IMPORTED_MODULE_17__["default"]; });




















/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value */ "./node_modules/d3-interpolate/src/value.js");

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) {
    x[i] = Object(_value__WEBPACK_IMPORTED_MODULE_0__["default"])(a[i], b[i]);
  }

  for (; i < nb; ++i) {
    c[i] = b[i];
  }

  return function (t) {
    for (i = 0; i < na; ++i) {
      c[i] = x[i](t);
    }

    return c;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/*! exports provided: basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basis", function() { return basis; });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1,
      t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
/* harmony default export */ __webpack_exports__["default"] = (function (values) {
  var n = values.length - 1;
  return function (t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-interpolate/src/basis.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values) {
  var n = values.length;
  return function (t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(_basis__WEBPACK_IMPORTED_MODULE_0__["basis"])((t - i / n) * n, v0, v1, v2, v3);
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/*! exports provided: hue, gamma, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hue", function() { return hue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gamma", function() { return gamma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nogamma; });
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/cubehelix.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/cubehelix.js ***!
  \******************************************************/
/*! exports provided: default, cubehelixLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubehelixLong", function() { return cubehelixLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(end)).h),
          s = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
          l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
          opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
      return function (t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;
    return cubehelix;
  }(1);
}

/* harmony default export */ __webpack_exports__["default"] = (cubehelix(_color__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var cubehelixLong = cubehelix(_color__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var d = new Date();
  return a = +a, b -= a, function (t) {
    return d.setTime(a + b * t), d;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/hcl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hcl.js ***!
  \************************************************/
/*! exports provided: default, hclLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hclLong", function() { return hclLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function (start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(end)).h),
        c = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.c, end.c),
        l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

/* harmony default export */ __webpack_exports__["default"] = (hcl(_color__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hclLong = hcl(_color__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./node_modules/d3-interpolate/src/hsl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hsl.js ***!
  \************************************************/
/*! exports provided: default, hslLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslLong", function() { return hslLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function (start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(end)).h),
        s = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
        l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

/* harmony default export */ __webpack_exports__["default"] = (hsl(_color__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hslLong = hsl(_color__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-interpolate/src/color.js");


function lab(start, end) {
  var l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(start)).l, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(end)).l),
      a = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.a, end.a),
      b = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.b, end.b),
      opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
  return function (t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return a = +a, b -= a, function (t) {
    return a + b * t;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value */ "./node_modules/d3-interpolate/src/value.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var i = {},
      c = {},
      k;
  if (a === null || _typeof(a) !== "object") a = {};
  if (b === null || _typeof(b) !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(_value__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function (t) {
    for (k in i) {
      c[k] = i[k](t);
    }

    return c;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return piecewise; });
function piecewise(interpolate, values) {
  var i = 0,
      n = values.length - 1,
      v = values[0],
      I = new Array(n < 0 ? 0 : n);

  while (i < n) {
    I[i] = interpolate(v, v = values[++i]);
  }

  return function (t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/quantize.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/quantize.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (interpolator, n) {
  var samples = new Array(n);

  for (var i = 0; i < n; ++i) {
    samples[i] = interpolator(i / (n - 1));
  }

  return samples;
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/*! exports provided: default, rgbBasis, rgbBasisClosed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasis", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasisClosed", function() { return rgbBasisClosed; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basisClosed */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color */ "./node_modules/d3-interpolate/src/color.js");




/* harmony default export */ __webpack_exports__["default"] = ((function rgbGamma(y) {
  var color = Object(_color__WEBPACK_IMPORTED_MODULE_3__["gamma"])(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(start)).r, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(_color__WEBPACK_IMPORTED_MODULE_3__["default"])(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;
  return rgb;
})(1));

function rgbSpline(spline) {
  return function (colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i,
        color;

    for (i = 0; i < n; ++i) {
      color = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }

    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function (t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis__WEBPACK_IMPORTED_MODULE_1__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed__WEBPACK_IMPORTED_MODULE_2__["default"]);

/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return a = +a, b -= a, function (t) {
    return Math.round(a + b * t);
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-interpolate/src/number.js");

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function () {
    return b;
  };
}

function one(b) {
  return function (t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
      // scan index for next number in b
  am,
      // current match in a
  bm,
      // current match in b
  bs,
      // string preceding current number in b, if any
  i = -1,
      // index in s
  s = [],
      // string constants and placeholders
  q = []; // number interpolators
  // Coerce inputs to strings.

  a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)
      });
    }

    bi = reB.lastIndex;
  } // Add remains of b.


  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  } // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.


  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) {
      s[(o = q[i]).i] = o.x(t);
    }

    return s.join("");
  });
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/*! exports provided: identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
/* harmony default export */ __webpack_exports__["default"] = (function (a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/*! exports provided: interpolateTransformCss, interpolateTransformSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return interpolateTransformSvg; });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({
        i: i - 4,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)
      }, {
        i: i - 2,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)
      });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path

      q.push({
        i: s.push(pop(s) + "rotate(", null, degParen) - 2,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({
        i: s.push(pop(s) + "skewX(", null, degParen) - 2,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)
      }, {
        i: i - 2,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)
      });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function (a, b) {
    var s = [],
        // string constants and placeholders
    q = []; // number interpolators

    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc

    return function (t) {
      var i = -1,
          n = q.length,
          o;

      while (++i < n) {
        s[(o = q[i]).i] = o.x(t);
      }

      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse__WEBPACK_IMPORTED_MODULE_1__["parseCss"], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse__WEBPACK_IMPORTED_MODULE_1__["parseSvg"], ", ", ")", ")");

/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/*! exports provided: parseCss, parseSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCss", function() { return parseCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSvg", function() { return parseSvg; });
/* harmony import */ var _decompose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose */ "./node_modules/d3-interpolate/src/transform/decompose.js");

var cssNode, cssRoot, cssView, svgNode;
function parseCss(value) {
  if (value === "none") return _decompose__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return Object(_decompose__WEBPACK_IMPORTED_MODULE_0__["default"])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
  if (value == null) return _decompose__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose__WEBPACK_IMPORTED_MODULE_0__["identity"];
  value = value.matrix;
  return Object(_decompose__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _rgb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./date */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./object */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-interpolate/src/constant.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }









/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var t = _typeof(b),
      c;

  return b == null || t === "boolean" ? Object(_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(b) : (t === "number" ? _number__WEBPACK_IMPORTED_MODULE_4__["default"] : t === "string" ? (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, _rgb__WEBPACK_IMPORTED_MODULE_1__["default"]) : _string__WEBPACK_IMPORTED_MODULE_6__["default"] : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? _rgb__WEBPACK_IMPORTED_MODULE_1__["default"] : b instanceof Date ? _date__WEBPACK_IMPORTED_MODULE_3__["default"] : Array.isArray(b) ? _array__WEBPACK_IMPORTED_MODULE_2__["default"] : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object__WEBPACK_IMPORTED_MODULE_5__["default"] : _number__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b);
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
} // p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]


/* harmony default export */ __webpack_exports__["default"] = (function (p0, p1) {
  var ux0 = p0[0],
      uy0 = p0[1],
      w0 = p0[2],
      ux1 = p1[0],
      uy1 = p1[1],
      w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S; // Special case for u0 ≅ u1.

  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;

    i = function i(t) {
      return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
    };
  } // General case.
  else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;

      i = function i(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
      };
    }

  i.duration = S * 1000;
  return i;
});

/***/ }),

/***/ "./node_modules/d3-request/index.js":
/*!******************************************!*\
  !*** ./node_modules/d3-request/index.js ***!
  \******************************************/
/*! exports provided: request, html, json, text, xml, csv, tsv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/request */ "./node_modules/d3-request/src/request.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "request", function() { return _src_request__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/html */ "./node_modules/d3-request/src/html.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _src_html__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/json */ "./node_modules/d3-request/src/json.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "json", function() { return _src_json__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/text */ "./node_modules/d3-request/src/text.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "text", function() { return _src_text__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_xml__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/xml */ "./node_modules/d3-request/src/xml.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "xml", function() { return _src_xml__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_csv__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/csv */ "./node_modules/d3-request/src/csv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return _src_csv__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_tsv__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/tsv */ "./node_modules/d3-request/src/tsv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsv", function() { return _src_tsv__WEBPACK_IMPORTED_MODULE_6__["default"]; });









/***/ }),

/***/ "./node_modules/d3-request/src/csv.js":
/*!********************************************!*\
  !*** ./node_modules/d3-request/src/csv.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/index.js");
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-request/src/dsv.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])("text/csv", d3_dsv__WEBPACK_IMPORTED_MODULE_0__["csvParse"]));

/***/ }),

/***/ "./node_modules/d3-request/src/dsv.js":
/*!********************************************!*\
  !*** ./node_modules/d3-request/src/dsv.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request */ "./node_modules/d3-request/src/request.js");

/* harmony default export */ __webpack_exports__["default"] = (function (defaultMimeType, parse) {
  return function (url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])(url).mimeType(defaultMimeType);

    r.row = function (_) {
      return arguments.length ? r.response(responseOf(parse, row = _)) : row;
    };

    r.row(row);
    return callback ? r.get(callback) : r;
  };
});

function responseOf(parse, row) {
  return function (request) {
    return parse(request.responseText, row);
  };
}

/***/ }),

/***/ "./node_modules/d3-request/src/html.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-request/src/html.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type */ "./node_modules/d3-request/src/type.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_type__WEBPACK_IMPORTED_MODULE_0__["default"])("text/html", function (xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
}));

/***/ }),

/***/ "./node_modules/d3-request/src/json.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-request/src/json.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type */ "./node_modules/d3-request/src/type.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_type__WEBPACK_IMPORTED_MODULE_0__["default"])("application/json", function (xhr) {
  return JSON.parse(xhr.responseText);
}));

/***/ }),

/***/ "./node_modules/d3-request/src/request.js":
/*!************************************************!*\
  !*** ./node_modules/d3-request/src/request.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-collection */ "./node_modules/d3-collection/index.js");
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function (url, callback) {
  var request,
      event = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_1__["dispatch"])("beforesend", "progress", "load", "error"),
      _mimeType,
      headers = Object(d3_collection__WEBPACK_IMPORTED_MODULE_0__["map"])(),
      xhr = new XMLHttpRequest(),
      _user = null,
      _password = null,
      _response,
      _responseType,
      _timeout = 0; // If IE does not support CORS, use XDomainRequest.


  if (typeof XDomainRequest !== "undefined" && !("withCredentials" in xhr) && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest();
  "onload" in xhr ? xhr.onload = xhr.onerror = xhr.ontimeout = respond : xhr.onreadystatechange = function (o) {
    xhr.readyState > 3 && respond(o);
  };

  function respond(o) {
    var status = xhr.status,
        result;

    if (!status && hasResponse(xhr) || status >= 200 && status < 300 || status === 304) {
      if (_response) {
        try {
          result = _response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }

      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function (e) {
    event.call("progress", request, e);
  };

  request = {
    header: function header(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);else headers.set(name, value + "");
      return request;
    },
    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function mimeType(value) {
      if (!arguments.length) return _mimeType;
      _mimeType = value == null ? null : value + "";
      return request;
    },
    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function responseType(value) {
      if (!arguments.length) return _responseType;
      _responseType = value;
      return request;
    },
    timeout: function timeout(value) {
      if (!arguments.length) return _timeout;
      _timeout = +value;
      return request;
    },
    user: function user(value) {
      return arguments.length < 1 ? _user : (_user = value == null ? null : value + "", request);
    },
    password: function password(value) {
      return arguments.length < 1 ? _password : (_password = value == null ? null : value + "", request);
    },
    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function response(value) {
      _response = value;
      return request;
    },
    // Alias for send("GET", …).
    get: function get(data, callback) {
      return request.send("GET", data, callback);
    },
    // Alias for send("POST", …).
    post: function post(data, callback) {
      return request.send("POST", data, callback);
    },
    // If callback is non-null, it will be used for error and load events.
    send: function send(method, data, callback) {
      xhr.open(method, url, true, _user, _password);
      if (_mimeType != null && !headers.has("accept")) headers.set("accept", _mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
      if (_mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(_mimeType);
      if (_responseType != null) xhr.responseType = _responseType;
      if (_timeout > 0) xhr.timeout = _timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function (xhr) {
        callback(null, xhr);
      });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },
    abort: function abort() {
      xhr.abort();
      return request;
    },
    on: function on() {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
});

function fixCallback(callback) {
  return function (error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text" ? xhr.response // null on error
  : xhr.responseText; // "" on error
}

/***/ }),

/***/ "./node_modules/d3-request/src/text.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-request/src/text.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type */ "./node_modules/d3-request/src/type.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_type__WEBPACK_IMPORTED_MODULE_0__["default"])("text/plain", function (xhr) {
  return xhr.responseText;
}));

/***/ }),

/***/ "./node_modules/d3-request/src/tsv.js":
/*!********************************************!*\
  !*** ./node_modules/d3-request/src/tsv.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/index.js");
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-request/src/dsv.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])("text/tab-separated-values", d3_dsv__WEBPACK_IMPORTED_MODULE_0__["tsvParse"]));

/***/ }),

/***/ "./node_modules/d3-request/src/type.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-request/src/type.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request */ "./node_modules/d3-request/src/request.js");

/* harmony default export */ __webpack_exports__["default"] = (function (defaultMimeType, response) {
  return function (url, callback) {
    var r = Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])(url).mimeType(defaultMimeType).response(response);

    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }

    return r;
  };
});

/***/ }),

/***/ "./node_modules/d3-request/src/xml.js":
/*!********************************************!*\
  !*** ./node_modules/d3-request/src/xml.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type */ "./node_modules/d3-request/src/type.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_type__WEBPACK_IMPORTED_MODULE_0__["default"])("application/xml", function (xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
}));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/index.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/index.js ***!
  \**************************************************/
/*! exports provided: schemeCategory10, schemeAccent, schemeDark2, schemePaired, schemePastel1, schemePastel2, schemeSet1, schemeSet2, schemeSet3, interpolateBrBG, schemeBrBG, interpolatePRGn, schemePRGn, interpolatePiYG, schemePiYG, interpolatePuOr, schemePuOr, interpolateRdBu, schemeRdBu, interpolateRdGy, schemeRdGy, interpolateRdYlBu, schemeRdYlBu, interpolateRdYlGn, schemeRdYlGn, interpolateSpectral, schemeSpectral, interpolateBuGn, schemeBuGn, interpolateBuPu, schemeBuPu, interpolateGnBu, schemeGnBu, interpolateOrRd, schemeOrRd, interpolatePuBuGn, schemePuBuGn, interpolatePuBu, schemePuBu, interpolatePuRd, schemePuRd, interpolateRdPu, schemeRdPu, interpolateYlGnBu, schemeYlGnBu, interpolateYlGn, schemeYlGn, interpolateYlOrBr, schemeYlOrBr, interpolateYlOrRd, schemeYlOrRd, interpolateBlues, schemeBlues, interpolateGreens, schemeGreens, interpolateGreys, schemeGreys, interpolatePurples, schemePurples, interpolateReds, schemeReds, interpolateOranges, schemeOranges, interpolateCubehelixDefault, interpolateRainbow, interpolateWarm, interpolateCool, interpolateSinebow, interpolateViridis, interpolateMagma, interpolateInferno, interpolatePlasma */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_categorical_category10__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/categorical/category10 */ "./node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return _src_categorical_category10__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_categorical_Accent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/categorical/Accent */ "./node_modules/d3-scale-chromatic/src/categorical/Accent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeAccent", function() { return _src_categorical_Accent__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_categorical_Dark2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/categorical/Dark2 */ "./node_modules/d3-scale-chromatic/src/categorical/Dark2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeDark2", function() { return _src_categorical_Dark2__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_categorical_Paired__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/categorical/Paired */ "./node_modules/d3-scale-chromatic/src/categorical/Paired.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePaired", function() { return _src_categorical_Paired__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_categorical_Pastel1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/categorical/Pastel1 */ "./node_modules/d3-scale-chromatic/src/categorical/Pastel1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel1", function() { return _src_categorical_Pastel1__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_categorical_Pastel2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/categorical/Pastel2 */ "./node_modules/d3-scale-chromatic/src/categorical/Pastel2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel2", function() { return _src_categorical_Pastel2__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_categorical_Set1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/categorical/Set1 */ "./node_modules/d3-scale-chromatic/src/categorical/Set1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet1", function() { return _src_categorical_Set1__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_categorical_Set2__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/categorical/Set2 */ "./node_modules/d3-scale-chromatic/src/categorical/Set2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet2", function() { return _src_categorical_Set2__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_categorical_Set3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/categorical/Set3 */ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet3", function() { return _src_categorical_Set3__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_diverging_BrBG__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/diverging/BrBG */ "./node_modules/d3-scale-chromatic/src/diverging/BrBG.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBrBG", function() { return _src_diverging_BrBG__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBrBG", function() { return _src_diverging_BrBG__WEBPACK_IMPORTED_MODULE_9__["scheme"]; });

/* harmony import */ var _src_diverging_PRGn__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/diverging/PRGn */ "./node_modules/d3-scale-chromatic/src/diverging/PRGn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePRGn", function() { return _src_diverging_PRGn__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePRGn", function() { return _src_diverging_PRGn__WEBPACK_IMPORTED_MODULE_10__["scheme"]; });

/* harmony import */ var _src_diverging_PiYG__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/diverging/PiYG */ "./node_modules/d3-scale-chromatic/src/diverging/PiYG.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePiYG", function() { return _src_diverging_PiYG__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePiYG", function() { return _src_diverging_PiYG__WEBPACK_IMPORTED_MODULE_11__["scheme"]; });

/* harmony import */ var _src_diverging_PuOr__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/diverging/PuOr */ "./node_modules/d3-scale-chromatic/src/diverging/PuOr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuOr", function() { return _src_diverging_PuOr__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuOr", function() { return _src_diverging_PuOr__WEBPACK_IMPORTED_MODULE_12__["scheme"]; });

/* harmony import */ var _src_diverging_RdBu__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/diverging/RdBu */ "./node_modules/d3-scale-chromatic/src/diverging/RdBu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdBu", function() { return _src_diverging_RdBu__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdBu", function() { return _src_diverging_RdBu__WEBPACK_IMPORTED_MODULE_13__["scheme"]; });

/* harmony import */ var _src_diverging_RdGy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/diverging/RdGy */ "./node_modules/d3-scale-chromatic/src/diverging/RdGy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdGy", function() { return _src_diverging_RdGy__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdGy", function() { return _src_diverging_RdGy__WEBPACK_IMPORTED_MODULE_14__["scheme"]; });

/* harmony import */ var _src_diverging_RdYlBu__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/diverging/RdYlBu */ "./node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlBu", function() { return _src_diverging_RdYlBu__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdYlBu", function() { return _src_diverging_RdYlBu__WEBPACK_IMPORTED_MODULE_15__["scheme"]; });

/* harmony import */ var _src_diverging_RdYlGn__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/diverging/RdYlGn */ "./node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlGn", function() { return _src_diverging_RdYlGn__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdYlGn", function() { return _src_diverging_RdYlGn__WEBPACK_IMPORTED_MODULE_16__["scheme"]; });

/* harmony import */ var _src_diverging_Spectral__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/diverging/Spectral */ "./node_modules/d3-scale-chromatic/src/diverging/Spectral.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSpectral", function() { return _src_diverging_Spectral__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSpectral", function() { return _src_diverging_Spectral__WEBPACK_IMPORTED_MODULE_17__["scheme"]; });

/* harmony import */ var _src_sequential_multi_BuGn__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/sequential-multi/BuGn */ "./node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuGn", function() { return _src_sequential_multi_BuGn__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBuGn", function() { return _src_sequential_multi_BuGn__WEBPACK_IMPORTED_MODULE_18__["scheme"]; });

/* harmony import */ var _src_sequential_multi_BuPu__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/sequential-multi/BuPu */ "./node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuPu", function() { return _src_sequential_multi_BuPu__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBuPu", function() { return _src_sequential_multi_BuPu__WEBPACK_IMPORTED_MODULE_19__["scheme"]; });

/* harmony import */ var _src_sequential_multi_GnBu__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/sequential-multi/GnBu */ "./node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGnBu", function() { return _src_sequential_multi_GnBu__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGnBu", function() { return _src_sequential_multi_GnBu__WEBPACK_IMPORTED_MODULE_20__["scheme"]; });

/* harmony import */ var _src_sequential_multi_OrRd__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/sequential-multi/OrRd */ "./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOrRd", function() { return _src_sequential_multi_OrRd__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeOrRd", function() { return _src_sequential_multi_OrRd__WEBPACK_IMPORTED_MODULE_21__["scheme"]; });

/* harmony import */ var _src_sequential_multi_PuBuGn__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/sequential-multi/PuBuGn */ "./node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBuGn", function() { return _src_sequential_multi_PuBuGn__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuBuGn", function() { return _src_sequential_multi_PuBuGn__WEBPACK_IMPORTED_MODULE_22__["scheme"]; });

/* harmony import */ var _src_sequential_multi_PuBu__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/sequential-multi/PuBu */ "./node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBu", function() { return _src_sequential_multi_PuBu__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuBu", function() { return _src_sequential_multi_PuBu__WEBPACK_IMPORTED_MODULE_23__["scheme"]; });

/* harmony import */ var _src_sequential_multi_PuRd__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/sequential-multi/PuRd */ "./node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuRd", function() { return _src_sequential_multi_PuRd__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuRd", function() { return _src_sequential_multi_PuRd__WEBPACK_IMPORTED_MODULE_24__["scheme"]; });

/* harmony import */ var _src_sequential_multi_RdPu__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/sequential-multi/RdPu */ "./node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdPu", function() { return _src_sequential_multi_RdPu__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdPu", function() { return _src_sequential_multi_RdPu__WEBPACK_IMPORTED_MODULE_25__["scheme"]; });

/* harmony import */ var _src_sequential_multi_YlGnBu__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/sequential-multi/YlGnBu */ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGnBu", function() { return _src_sequential_multi_YlGnBu__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlGnBu", function() { return _src_sequential_multi_YlGnBu__WEBPACK_IMPORTED_MODULE_26__["scheme"]; });

/* harmony import */ var _src_sequential_multi_YlGn__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/sequential-multi/YlGn */ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGn", function() { return _src_sequential_multi_YlGn__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlGn", function() { return _src_sequential_multi_YlGn__WEBPACK_IMPORTED_MODULE_27__["scheme"]; });

/* harmony import */ var _src_sequential_multi_YlOrBr__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/sequential-multi/YlOrBr */ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrBr", function() { return _src_sequential_multi_YlOrBr__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlOrBr", function() { return _src_sequential_multi_YlOrBr__WEBPACK_IMPORTED_MODULE_28__["scheme"]; });

/* harmony import */ var _src_sequential_multi_YlOrRd__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/sequential-multi/YlOrRd */ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrRd", function() { return _src_sequential_multi_YlOrRd__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlOrRd", function() { return _src_sequential_multi_YlOrRd__WEBPACK_IMPORTED_MODULE_29__["scheme"]; });

/* harmony import */ var _src_sequential_single_Blues__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./src/sequential-single/Blues */ "./node_modules/d3-scale-chromatic/src/sequential-single/Blues.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBlues", function() { return _src_sequential_single_Blues__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBlues", function() { return _src_sequential_single_Blues__WEBPACK_IMPORTED_MODULE_30__["scheme"]; });

/* harmony import */ var _src_sequential_single_Greens__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./src/sequential-single/Greens */ "./node_modules/d3-scale-chromatic/src/sequential-single/Greens.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreens", function() { return _src_sequential_single_Greens__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGreens", function() { return _src_sequential_single_Greens__WEBPACK_IMPORTED_MODULE_31__["scheme"]; });

/* harmony import */ var _src_sequential_single_Greys__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./src/sequential-single/Greys */ "./node_modules/d3-scale-chromatic/src/sequential-single/Greys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreys", function() { return _src_sequential_single_Greys__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGreys", function() { return _src_sequential_single_Greys__WEBPACK_IMPORTED_MODULE_32__["scheme"]; });

/* harmony import */ var _src_sequential_single_Purples__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./src/sequential-single/Purples */ "./node_modules/d3-scale-chromatic/src/sequential-single/Purples.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePurples", function() { return _src_sequential_single_Purples__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePurples", function() { return _src_sequential_single_Purples__WEBPACK_IMPORTED_MODULE_33__["scheme"]; });

/* harmony import */ var _src_sequential_single_Reds__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./src/sequential-single/Reds */ "./node_modules/d3-scale-chromatic/src/sequential-single/Reds.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateReds", function() { return _src_sequential_single_Reds__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeReds", function() { return _src_sequential_single_Reds__WEBPACK_IMPORTED_MODULE_34__["scheme"]; });

/* harmony import */ var _src_sequential_single_Oranges__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./src/sequential-single/Oranges */ "./node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOranges", function() { return _src_sequential_single_Oranges__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeOranges", function() { return _src_sequential_single_Oranges__WEBPACK_IMPORTED_MODULE_35__["scheme"]; });

/* harmony import */ var _src_sequential_multi_cubehelix__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./src/sequential-multi/cubehelix */ "./node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return _src_sequential_multi_cubehelix__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _src_sequential_multi_rainbow__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./src/sequential-multi/rainbow */ "./node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return _src_sequential_multi_rainbow__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return _src_sequential_multi_rainbow__WEBPACK_IMPORTED_MODULE_37__["warm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return _src_sequential_multi_rainbow__WEBPACK_IMPORTED_MODULE_37__["cool"]; });

/* harmony import */ var _src_sequential_multi_sinebow__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./src/sequential-multi/sinebow */ "./node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSinebow", function() { return _src_sequential_multi_sinebow__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _src_sequential_multi_viridis__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./src/sequential-multi/viridis */ "./node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return _src_sequential_multi_viridis__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return _src_sequential_multi_viridis__WEBPACK_IMPORTED_MODULE_39__["magma"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return _src_sequential_multi_viridis__WEBPACK_IMPORTED_MODULE_39__["inferno"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return _src_sequential_multi_viridis__WEBPACK_IMPORTED_MODULE_39__["plasma"]; });










































/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Accent.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Accent.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Dark2.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Dark2.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Paired.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Paired.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Pastel1.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Pastel1.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Pastel2.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Pastel2.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Set1.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Set1.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Set2.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Set2.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Set3.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/category10.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/category10.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/colors.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/colors.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (specifier) {
  var n = specifier.length / 6 | 0,
      colors = new Array(n),
      i = 0;

  while (i < n) {
    colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  }

  return colors;
});

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/diverging/BrBG.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/BrBG.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("d8b365f5f5f55ab4ac", "a6611adfc27d80cdc1018571", "a6611adfc27df5f5f580cdc1018571", "8c510ad8b365f6e8c3c7eae55ab4ac01665e", "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e", "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e", "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e", "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30", "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/diverging/PRGn.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/PRGn.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("af8dc3f7f7f77fbf7b", "7b3294c2a5cfa6dba0008837", "7b3294c2a5cff7f7f7a6dba0008837", "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837", "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837", "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837", "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837", "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b", "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/diverging/PiYG.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/PiYG.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("e9a3c9f7f7f7a1d76a", "d01c8bf1b6dab8e1864dac26", "d01c8bf1b6daf7f7f7b8e1864dac26", "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221", "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221", "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221", "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221", "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419", "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/diverging/PuOr.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/PuOr.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("998ec3f7f7f7f1a340", "5e3c99b2abd2fdb863e66101", "5e3c99b2abd2f7f7f7fdb863e66101", "542788998ec3d8daebfee0b6f1a340b35806", "542788998ec3d8daebf7f7f7fee0b6f1a340b35806", "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806", "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806", "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08", "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/diverging/RdBu.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/RdBu.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("ef8a62f7f7f767a9cf", "ca0020f4a58292c5de0571b0", "ca0020f4a582f7f7f792c5de0571b0", "b2182bef8a62fddbc7d1e5f067a9cf2166ac", "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac", "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac", "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac", "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061", "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/diverging/RdGy.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/RdGy.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("ef8a62ffffff999999", "ca0020f4a582bababa404040", "ca0020f4a582ffffffbababa404040", "b2182bef8a62fddbc7e0e0e09999994d4d4d", "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d", "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d", "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d", "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a", "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js ***!
  \*****************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("fc8d59ffffbf91bfdb", "d7191cfdae61abd9e92c7bb6", "d7191cfdae61ffffbfabd9e92c7bb6", "d73027fc8d59fee090e0f3f891bfdb4575b4", "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4", "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4", "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4", "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695", "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js ***!
  \*****************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("fc8d59ffffbf91cf60", "d7191cfdae61a6d96a1a9641", "d7191cfdae61ffffbfa6d96a1a9641", "d73027fc8d59fee08bd9ef8b91cf601a9850", "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850", "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850", "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850", "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837", "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/diverging/Spectral.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/Spectral.js ***!
  \*******************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("fc8d59ffffbf99d594", "d7191cfdae61abdda42b83ba", "d7191cfdae61ffffbfabdda42b83ba", "d53e4ffc8d59fee08be6f59899d5943288bd", "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd", "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd", "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd", "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2", "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/ramp.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/ramp.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (scheme) {
  return Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateRgbBasis"])(scheme[scheme.length - 1]);
});

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("e5f5f999d8c92ca25f", "edf8fbb2e2e266c2a4238b45", "edf8fbb2e2e266c2a42ca25f006d2c", "edf8fbccece699d8c966c2a42ca25f006d2c", "edf8fbccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("e0ecf49ebcda8856a7", "edf8fbb3cde38c96c688419d", "edf8fbb3cde38c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("e0f3dba8ddb543a2ca", "f0f9e8bae4bc7bccc42b8cbe", "f0f9e8bae4bc7bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("fee8c8fdbb84e34a33", "fef0d9fdcc8afc8d59d7301f", "fef0d9fdcc8afc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("ece7f2a6bddb2b8cbe", "f1eef6bdc9e174a9cf0570b0", "f1eef6bdc9e174a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("ece2f0a6bddb1c9099", "f6eff7bdc9e167a9cf02818a", "f6eff7bdc9e167a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("e7e1efc994c7dd1c77", "f1eef6d7b5d8df65b0ce1256", "f1eef6d7b5d8df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("fde0ddfa9fb5c51b8a", "feebe2fbb4b9f768a1ae017e", "feebe2fbb4b9f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("f7fcb9addd8e31a354", "ffffccc2e69978c679238443", "ffffccc2e69978c67931a354006837", "ffffccd9f0a3addd8e78c67931a354006837", "ffffccd9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("edf8b17fcdbb2c7fb8", "ffffcca1dab441b6c4225ea8", "ffffcca1dab441b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("fff7bcfec44fd95f0e", "ffffd4fed98efe9929cc4c02", "ffffd4fed98efe9929d95f0e993404", "ffffd4fee391fec44ffe9929d95f0e993404", "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("ffeda0feb24cf03b20", "ffffb2fecc5cfd8d3ce31a1c", "ffffb2fecc5cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(300, 0.5, 0.0), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(-240, 0.5, 1.0)));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js ***!
  \*************************************************************************/
/*! exports provided: warm, cool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "warm", function() { return warm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cool", function() { return cool; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");


var warm = Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(-100, 0.75, 0.35), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(80, 1.50, 0.8));
var cool = Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(260, 0.75, 0.35), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(80, 1.50, 0.8));
var c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])();
/* harmony default export */ __webpack_exports__["default"] = (function (t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
});

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");

var c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(),
    pi_1_3 = Math.PI / 3,
    pi_2_3 = Math.PI * 2 / 3;
/* harmony default export */ __webpack_exports__["default"] = (function (t) {
  var x;
  t = (0.5 - t) * Math.PI;
  c.r = 255 * (x = Math.sin(t)) * x;
  c.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
  c.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
  return c + "";
});

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js ***!
  \*************************************************************************/
/*! exports provided: default, magma, inferno, plasma */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "magma", function() { return magma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inferno", function() { return inferno; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plasma", function() { return plasma; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");


function ramp(range) {
  var n = range.length;
  return function (t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")));
var magma = ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-single/Blues.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Blues.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("deebf79ecae13182bd", "eff3ffbdd7e76baed62171b5", "eff3ffbdd7e76baed63182bd08519c", "eff3ffc6dbef9ecae16baed63182bd08519c", "eff3ffc6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-single/Greens.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Greens.js ***!
  \*************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("e5f5e0a1d99b31a354", "edf8e9bae4b374c476238b45", "edf8e9bae4b374c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-single/Greys.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Greys.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("f0f0f0bdbdbd636363", "f7f7f7cccccc969696525252", "f7f7f7cccccc969696636363252525", "f7f7f7d9d9d9bdbdbd969696636363252525", "f7f7f7d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js ***!
  \**************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("fee6cefdae6be6550d", "feeddefdbe85fd8d3cd94701", "feeddefdbe85fd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-single/Purples.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Purples.js ***!
  \**************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("efedf5bcbddc756bb1", "f2f0f7cbc9e29e9ac86a51a3", "f2f0f7cbc9e29e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-single/Reds.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Reds.js ***!
  \***********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./node_modules/d3-scale-chromatic/src/ramp.js");


var scheme = new Array(3).concat("fee0d2fc9272de2d26", "fee5d9fcae91fb6a4acb181d", "fee5d9fcae91fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));

/***/ }),

/***/ "./node_modules/d3-selection/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-selection/index.js ***!
  \********************************************/
/*! exports provided: create, creator, local, matcher, mouse, namespace, namespaces, clientPoint, select, selectAll, selection, selector, selectorAll, style, touch, touches, window, event, customEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/create */ "./node_modules/d3-selection/src/create.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _src_create__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/creator */ "./node_modules/d3-selection/src/creator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return _src_creator__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_local__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/local */ "./node_modules/d3-selection/src/local.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return _src_local__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_matcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/matcher */ "./node_modules/d3-selection/src/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _src_matcher__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/mouse */ "./node_modules/d3-selection/src/mouse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return _src_mouse__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_namespace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/namespace */ "./node_modules/d3-selection/src/namespace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return _src_namespace__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_namespaces__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/namespaces */ "./node_modules/d3-selection/src/namespaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return _src_namespaces__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/point */ "./node_modules/d3-selection/src/point.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clientPoint", function() { return _src_point__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_select__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/select */ "./node_modules/d3-selection/src/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _src_select__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_selectAll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/selectAll */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return _src_selectAll__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _src_selection_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/selection/index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return _src_selection_index__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _src_selector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/selector */ "./node_modules/d3-selection/src/selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return _src_selector__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _src_selectorAll__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/selectorAll */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return _src_selectorAll__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _src_selection_style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/selection/style */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _src_selection_style__WEBPACK_IMPORTED_MODULE_13__["styleValue"]; });

/* harmony import */ var _src_touch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/touch */ "./node_modules/d3-selection/src/touch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touch", function() { return _src_touch__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _src_touches__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/touches */ "./node_modules/d3-selection/src/touches.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touches", function() { return _src_touches__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _src_window__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/window */ "./node_modules/d3-selection/src/window.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _src_window__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _src_selection_on__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/selection/on */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "event", function() { return _src_selection_on__WEBPACK_IMPORTED_MODULE_17__["event"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return _src_selection_on__WEBPACK_IMPORTED_MODULE_17__["customEvent"]; });




















/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select */ "./node_modules/d3-selection/src/select.js");


/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  return Object(_select__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
});

/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function () {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces__WEBPACK_IMPORTED_MODULE_1__["xhtml"] && document.documentElement.namespaceURI === _namespaces__WEBPACK_IMPORTED_MODULE_1__["xhtml"] ? document.createElement(name) : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function () {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  var fullname = Object(_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/local.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/local.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return local; });
var nextId = 0;
function local() {
  return new Local();
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function get(node) {
    var id = this._;

    while (!(id in node)) {
      if (!(node = node.parentNode)) return;
    }

    return node[id];
  },
  set: function set(node, value) {
    return node[this._] = value;
  },
  remove: function remove(node) {
    return this._ in node && delete node[this._];
  },
  toString: function toString() {
    return this._;
  }
};

/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var matcher = function matcher(selector) {
  return function () {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;

  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector;

    matcher = function matcher(selector) {
      return function () {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (matcher);

/***/ }),

/***/ "./node_modules/d3-selection/src/mouse.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/mouse.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-selection/src/point.js");


/* harmony default export */ __webpack_exports__["default"] = (function (node) {
  var event = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])();
  if (event.changedTouches) event = event.changedTouches[0];
  return Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, event);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-selection/src/namespaces.js");

/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  var prefix = name += "",
      i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {
    space: _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"][prefix],
    local: name
  } : name;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/*! exports provided: xhtml, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhtml", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";
/* harmony default export */ __webpack_exports__["default"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});

/***/ }),

/***/ "./node_modules/d3-selection/src/point.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/point.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});

/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (selector) {
  return typeof selector === "string" ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[document.querySelector(selector)]], [document.documentElement]) : new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[selector]], _selection_index__WEBPACK_IMPORTED_MODULE_0__["root"]);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (selector) {
  return typeof selector === "string" ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([document.querySelectorAll(selector)], [document.documentElement]) : new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([selector == null ? [] : selector], _selection_index__WEBPACK_IMPORTED_MODULE_0__["root"]);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-selection/src/creator.js");

/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  var create = typeof name === "function" ? name : Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function () {
    return this.appendChild(create.apply(this, arguments));
  });
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function () {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function () {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  var fullname = Object(_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }

  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function add(name) {
    var i = this._names.indexOf(name);

    if (i < 0) {
      this._names.push(name);

      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function remove(name) {
    var i = this._names.indexOf(name);

    if (i >= 0) {
      this._names.splice(i, 1);

      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function contains(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;

  while (++i < n) {
    list.add(names[i]);
  }
}

function classedRemove(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;

  while (++i < n) {
    list.remove(names[i]);
  }
}

function classedTrue(names) {
  return function () {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function () {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function () {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()),
        i = -1,
        n = names.length;

    while (++i < n) {
      if (!list.contains(names[i])) return false;
    }

    return true;
  }

  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

/* harmony default export */ __webpack_exports__["default"] = (function (deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./node_modules/d3-selection/src/constant.js");



var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length; // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.

  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  } // Put any non-null nodes that don’t fit into exit.


  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue; // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.

  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);

      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  } // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.


  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);

    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  } // Add any remaining nodes that were not bound to data to exit.


  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (function (value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function (d) {
      data[++j] = d;
    });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;
  if (typeof value !== "function") value = Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.

    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;

        while (!(next = updateGroup[i1]) && ++i1 < dataLength) {
          ;
        }

        previous._next = next || null;
      }
    }
  }

  update = new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = Object(_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function () {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function () {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return !this.node();
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/*! exports provided: default, EnterNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterNode", function() { return EnterNode; });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return new _index__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._enter || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});
function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function appendChild(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function insertBefore(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function querySelector(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function querySelectorAll(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return new _index__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._exit || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher */ "./node_modules/d3-selection/src/matcher.js");


/* harmony default export */ __webpack_exports__["default"] = (function (match) {
  if (typeof match !== "function") match = Object(_matcher__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function () {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/*! exports provided: root, Selection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selection", function() { return Selection; });
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exit */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./order */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sort */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./call */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./nodes */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./node */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./size */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./empty */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./each */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./attr */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./style */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./property */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./classed */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./text */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./html */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./raise */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lower */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./append */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./insert */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./remove */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./clone */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./datum */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./on */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./dispatch */ "./node_modules/d3-selection/src/selection/dispatch.js");






























var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_1__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_2__["default"],
  data: _data__WEBPACK_IMPORTED_MODULE_3__["default"],
  enter: _enter__WEBPACK_IMPORTED_MODULE_4__["default"],
  exit: _exit__WEBPACK_IMPORTED_MODULE_5__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_6__["default"],
  order: _order__WEBPACK_IMPORTED_MODULE_7__["default"],
  sort: _sort__WEBPACK_IMPORTED_MODULE_8__["default"],
  call: _call__WEBPACK_IMPORTED_MODULE_9__["default"],
  nodes: _nodes__WEBPACK_IMPORTED_MODULE_10__["default"],
  node: _node__WEBPACK_IMPORTED_MODULE_11__["default"],
  size: _size__WEBPACK_IMPORTED_MODULE_12__["default"],
  empty: _empty__WEBPACK_IMPORTED_MODULE_13__["default"],
  each: _each__WEBPACK_IMPORTED_MODULE_14__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_15__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_16__["default"],
  property: _property__WEBPACK_IMPORTED_MODULE_17__["default"],
  classed: _classed__WEBPACK_IMPORTED_MODULE_18__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_19__["default"],
  html: _html__WEBPACK_IMPORTED_MODULE_20__["default"],
  raise: _raise__WEBPACK_IMPORTED_MODULE_21__["default"],
  lower: _lower__WEBPACK_IMPORTED_MODULE_22__["default"],
  append: _append__WEBPACK_IMPORTED_MODULE_23__["default"],
  insert: _insert__WEBPACK_IMPORTED_MODULE_24__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_25__["default"],
  clone: _clone__WEBPACK_IMPORTED_MODULE_26__["default"],
  datum: _datum__WEBPACK_IMPORTED_MODULE_27__["default"],
  on: _on__WEBPACK_IMPORTED_MODULE_28__["default"],
  dispatch: _dispatch__WEBPACK_IMPORTED_MODULE_29__["default"]
};
/* harmony default export */ __webpack_exports__["default"] = (selection);

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, before) {
  var create = typeof name === "function" ? name : Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function () {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return this.each(lower);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (selection) {
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](merges, this._parents);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var nodes = new Array(this.size()),
      i = -1;
  this.each(function () {
    nodes[++i] = this;
  });
  return nodes;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/*! exports provided: event, default, customEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return customEvent; });
var filterEvents = {};
var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;

  if (!("onmouseenter" in element)) {
    filterEvents = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    };
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function (event) {
    var related = event.relatedTarget;

    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function (event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).

    event = event1;

    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {
      type: t,
      name: name
    };
  });
}

function onRemove(typename) {
  return function () {
    var on = this.__on;
    if (!on) return;

    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }

    if (++i) on.length = i;else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function (d, i, group) {
    var on = this.__on,
        o,
        listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {
      type: typename.type,
      name: typename.name,
      value: value,
      listener: listener,
      capture: capture
    };
    if (!on) this.__on = [o];else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (typename, value, capture) {
  var typenames = parseTypenames(typename + ""),
      i,
      n = typenames.length,
      t;

  if (arguments.length < 2) {
    var on = this.node().__on;

    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;

  for (i = 0; i < n; ++i) {
    this.each(on(typenames[i], value, capture));
  }

  return this;
});
function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;

  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function propertyRemove(name) {
  return function () {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function () {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return this.each(raise);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return this.each(remove);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-selection/src/selector.js");


/* harmony default export */ __webpack_exports__["default"] = (function (select) {
  if (typeof select !== "function") select = Object(_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll */ "./node_modules/d3-selection/src/selectorAll.js");


/* harmony default export */ __webpack_exports__["default"] = (function (select) {
  if (typeof select !== "function") select = Object(_selectorAll__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, parents);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var size = 0;
  this.each(function () {
    ++size;
  });
  return size;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }

    sortgroup.sort(compareNode);
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (update) {
  return new Array(update.length);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/*! exports provided: default, styleValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styleValue", function() { return styleValue; });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function () {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
});
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || Object(_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function none() {}

/* harmony default export */ __webpack_exports__["default"] = (function (selector) {
  return selector == null ? none : function () {
    return this.querySelector(selector);
  };
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["default"] = (function (selector) {
  return selector == null ? empty : function () {
    return this.querySelectorAll(selector);
  };
});

/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-selection/src/selection/on.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var current = _selection_on__WEBPACK_IMPORTED_MODULE_0__["event"],
      source;

  while (source = current.sourceEvent) {
    current = source;
  }

  return current;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/touch.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/touch.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-selection/src/point.js");


/* harmony default export */ __webpack_exports__["default"] = (function (node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touch);
    }
  }

  return null;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/touches.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/touches.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-selection/src/point.js");


/* harmony default export */ __webpack_exports__["default"] = (function (node, touches) {
  if (touches == null) touches = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touches[i]);
  }

  return points;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (node) {
  return node.ownerDocument && node.ownerDocument.defaultView || // node is a Node
  node.document && node // node is a Window
  || node.defaultView; // node is a Document
});

/***/ }),

/***/ "./node_modules/d3-timer/index.js":
/*!****************************************!*\
  !*** ./node_modules/d3-timer/index.js ***!
  \****************************************/
/*! exports provided: now, timer, timerFlush, timeout, interval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _src_timer__WEBPACK_IMPORTED_MODULE_0__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _src_timer__WEBPACK_IMPORTED_MODULE_0__["timer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return _src_timer__WEBPACK_IMPORTED_MODULE_0__["timerFlush"]; });

/* harmony import */ var _src_timeout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/timeout */ "./node_modules/d3-timer/src/timeout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _src_timeout__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_interval__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/interval */ "./node_modules/d3-timer/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _src_interval__WEBPACK_IMPORTED_MODULE_2__["default"]; });





/***/ }),

/***/ "./node_modules/d3-timer/src/interval.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-timer/src/interval.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer */ "./node_modules/d3-timer/src/timer.js");

/* harmony default export */ __webpack_exports__["default"] = (function (callback, delay, time) {
  var t = new _timer__WEBPACK_IMPORTED_MODULE_0__["Timer"](),
      total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? Object(_timer__WEBPACK_IMPORTED_MODULE_0__["now"])() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
});

/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer */ "./node_modules/d3-timer/src/timer.js");

/* harmony default export */ __webpack_exports__["default"] = (function (callback, delay, time) {
  var t = new _timer__WEBPACK_IMPORTED_MODULE_0__["Timer"]();
  delay = delay == null ? 0 : +delay;
  t.restart(function (elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});

/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/*! exports provided: now, Timer, timer, timerFlush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return timerFlush; });
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var frame = 0,
    // is an animation frame pending?
timeout = 0,
    // is a timeout pending?
interval = 0,
    // are any timers active?
pokeDelay = 1000,
    // how frequently we check for clock skew
taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === "object" && performance.now ? performance : Date,
    setFrame = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function restart(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);

    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;else taskHead = this;
      taskTail = this;
    }

    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function stop() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now(); // Get the current time, if not already set.

  ++frame; // Pretend we’ve set an alarm, if we haven’t already.

  var t = taskHead,
      e;

  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }

  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;

  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(),
      delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0,
      t1 = taskHead,
      t2,
      time = Infinity;

  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }

  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.

  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.

  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

/***/ }),

/***/ "./node_modules/d3-transition/index.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-transition/index.js ***!
  \*********************************************/
/*! exports provided: transition, active, interrupt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/selection/index */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _src_transition_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/transition/index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return _src_transition_index__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_active__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/active */ "./node_modules/d3-transition/src/active.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "active", function() { return _src_active__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_interrupt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/interrupt */ "./node_modules/d3-transition/src/interrupt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return _src_interrupt__WEBPACK_IMPORTED_MODULE_3__["default"]; });






/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


var root = [null];
/* harmony default export */ __webpack_exports__["default"] = (function (node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";

    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule__WEBPACK_IMPORTED_MODULE_1__["SCHEDULED"] && schedule.name === name) {
        return new _transition_index__WEBPACK_IMPORTED_MODULE_0__["Transition"]([[node]], root, name, +i);
      }
    }
  }

  return null;
});

/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule */ "./node_modules/d3-transition/src/transition/schedule.js");

/* harmony default export */ __webpack_exports__["default"] = (function (node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;
  if (!schedules) return;
  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty = false;
      continue;
    }

    active = schedule.state > _transition_schedule__WEBPACK_IMPORTED_MODULE_0__["STARTING"] && schedule.state < _transition_schedule__WEBPACK_IMPORTED_MODULE_0__["ENDING"];
    schedule.state = _transition_schedule__WEBPACK_IMPORTED_MODULE_0__["ENDED"];
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});

/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _interrupt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition */ "./node_modules/d3-transition/src/selection/transition.js");



d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.interrupt = _interrupt__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.transition = _transition__WEBPACK_IMPORTED_MODULE_2__["default"];

/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interrupt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt */ "./node_modules/d3-transition/src/interrupt.js");

/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  return this.each(function () {
    Object(_interrupt__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
});

/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transition/index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/schedule */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/index.js");




var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_2__["easeCubicInOut"]
};

function inherit(node, id) {
  var timing;

  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), defaultTiming;
    }
  }

  return timing;
}

/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  var id, timing;

  if (name instanceof _transition_index__WEBPACK_IMPORTED_MODULE_0__["Transition"]) {
    id = name._id, name = name._name;
  } else {
    id = Object(_transition_index__WEBPACK_IMPORTED_MODULE_0__["newId"])(), (timing = defaultTiming).time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(_transition_schedule__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0,
        value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0,
        value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["namespace"])(name),
      i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformSvg"] : _interpolate__WEBPACK_IMPORTED_MODULE_3__["default"];
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(_tween__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");


function attrTweenNS(fullname, value) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }

  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.setAttribute(name, i(t));
    };
  }

  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function () {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function () {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).delay;
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function () {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function () {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).duration;
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error();
  return function () {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  var id = this._id;
  return arguments.length ? this.each(easeConstant(id, value)) : Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).ease;
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function (match) {
  if (typeof match !== "function") match = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, this._name, this._id);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/*! exports provided: Transition, default, newId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return Transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newId", function() { return newId; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attrTween */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delay */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ease */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filter */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./on */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./remove */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./select */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selection */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./style */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./styleTween */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./text */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./transition */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./tween */ "./node_modules/d3-transition/src/transition/tween.js");


















var id = 0;
function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}
function transition(name) {
  return Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select__WEBPACK_IMPORTED_MODULE_10__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_11__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_6__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_7__["default"],
  selection: _selection__WEBPACK_IMPORTED_MODULE_12__["default"],
  transition: _transition__WEBPACK_IMPORTED_MODULE_16__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on__WEBPACK_IMPORTED_MODULE_8__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_1__["default"],
  attrTween: _attrTween__WEBPACK_IMPORTED_MODULE_2__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_13__["default"],
  styleTween: _styleTween__WEBPACK_IMPORTED_MODULE_14__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_15__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_9__["default"],
  tween: _tween__WEBPACK_IMPORTED_MODULE_17__["default"],
  delay: _delay__WEBPACK_IMPORTED_MODULE_3__["default"],
  duration: _duration__WEBPACK_IMPORTED_MODULE_4__["default"],
  ease: _ease__WEBPACK_IMPORTED_MODULE_5__["default"]
};

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"] : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"] : (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"]) : d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateString"])(a, b);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-transition/src/transition/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (transition) {
  if (transition._id !== this._id) throw new Error();

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Transition"](merges, this._parents, this._name, this._id);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function (t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0,
      on1,
      sit = start(name) ? _schedule__WEBPACK_IMPORTED_MODULE_0__["init"] : _schedule__WEBPACK_IMPORTED_MODULE_0__["set"];
  return function () {
    var schedule = sit(this, id),
        on = schedule.on; // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.

    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, listener) {
  var id = this._id;
  return arguments.length < 2 ? Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function removeFunction(id) {
  return function () {
    var parent = this.parentNode;

    for (var i in this.__transition) {
      if (+i !== id) return;
    }

    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return this.on("end.remove", removeFunction(this._id));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/*! exports provided: CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED, default, init, set, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATED", function() { return CREATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEDULED", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING", function() { return STARTING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTED", function() { return STARTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUNNING", function() { return RUNNING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDING", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDED", function() { return ENDED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/index.js");


var emptyOn = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "end", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
/* harmony default export */ __webpack_exports__["default"] = (function (node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index,
    // For context during callback.
    group: group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});
function init(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error("too late");
  return schedule;
}
function set(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error("too late");
  return schedule;
}
function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("too late");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween; // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!

  schedules[id] = self;
  self.timer = Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timer"])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately.

    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o; // If the state is not SCHEDULED, then we previously errored on start.

    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue; // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!

      if (o.state === STARTED) return Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(start); // Interrupt the active transition, if any.
      // Dispatch the interrupt event.

      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
          o.state = ENDED;
          o.timer.stop();
          delete schedules[i];
        }
    } // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.


    Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(function () {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    }); // Dispatch the start event.
    // Note this must be done before the tween are initialized.

    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted

    self.state = STARTED; // Initialize the tween, deleting null tween.

    tween = new Array(n = self.tween.length);

    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }

    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    } // Dispatch the end event.


    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];

    for (var i in schedules) {
      return;
    } // eslint-disable-line no-unused-vars


    delete node.__transition;
  }
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function (select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["default"])(subgroup[i], name, id, i, subgroup, Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id));
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, name, id);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function (select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["default"])(child, name, id, k, children, inherit);
          }
        }

        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, parents, name, id);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");

var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.constructor;
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return new Selection(this._groups, this._parents);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate */ "./node_modules/d3-transition/src/transition/interpolate.js");





function styleRemove(name, interpolate) {
  var value00, value10, interpolate0;
  return function () {
    var style = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["window"])(this).getComputedStyle(this, null),
        value0 = style.getPropertyValue(name),
        value1 = (this.style.removeProperty(name), style.getPropertyValue(name));
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["window"])(this).getComputedStyle(this, null).getPropertyValue(name);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var style = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["window"])(this).getComputedStyle(this, null),
        value0 = style.getPropertyValue(name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), style.getPropertyValue(name));
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformCss"] : _interpolate__WEBPACK_IMPORTED_MODULE_3__["default"];
  return value == null ? this.styleTween(name, styleRemove(name, i)).on("end.style." + name, styleRemoveEnd(name)) : this.styleTween(name, typeof value === "function" ? styleFunction(name, i, Object(_tween__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "style." + name, value)) : styleConstant(name, i, value + ""), priority);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function styleTween(name, value, priority) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.style.setProperty(name, i(t), priority);
    };
  }

  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function () {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return this.tween("text", typeof value === "function" ? textFunction(Object(_tween__WEBPACK_IMPORTED_MODULE_0__["tweenValue"])(this, "text", value)) : textConstant(value == null ? "" : value + ""));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  var name = this._name,
      id0 = this._id,
      id1 = Object(_index__WEBPACK_IMPORTED_MODULE_0__["newId"])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(_schedule__WEBPACK_IMPORTED_MODULE_1__["get"])(node, id0);
        Object(_schedule__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id1);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/*! exports provided: default, tweenValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenValue", function() { return tweenValue; });
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function () {
    var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween; // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.

    if (tween !== tween0) {
      tween1 = tween0 = tween;

      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function () {
    var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween; // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.

    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();

      for (var t = {
        name: name,
        value: value
      }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }

      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  var id = this._id;
  name += "";

  if (arguments.length < 2) {
    var tween = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).tween;

    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }

    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});
function tweenValue(transition, name, value) {
  var id = transition._id;
  transition.each(function () {
    var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function (node) {
    return Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(node, id).value[name];
  };
}

/***/ }),

/***/ "./node_modules/d3-zoom/index.js":
/*!***************************************!*\
  !*** ./node_modules/d3-zoom/index.js ***!
  \***************************************/
/*! exports provided: zoom, zoomTransform, zoomIdentity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/zoom */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return _src_zoom__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/transform */ "./node_modules/d3-zoom/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return _src_transform__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return _src_transform__WEBPACK_IMPORTED_MODULE_1__["identity"]; });




/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomEvent; });
function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");

function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
});

/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/*! exports provided: Transform, identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function scale(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function translate(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function apply(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function applyX(x) {
    return x * this.k + this.x;
  },
  applyY: function applyY(y) {
    return y * this.k + this.y;
  },
  invert: function invert(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function invertX(x) {
    return (x - this.x) / this.k;
  },
  invertY: function invertY(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function rescaleX(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function rescaleY(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function toString() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  return node.__zoom || identity;
}

/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/index.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transform */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-zoom/src/noevent.js");








 // Ignore right-click, since that should open the context menu.

function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].button;
}

function defaultExtent() {
  var e = this,
      w,
      h;

  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }

  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || _transform__WEBPACK_IMPORTED_MODULE_7__["identity"];
}

function defaultWheelDelta() {
  return -d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].deltaY * (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].deltaMode ? 120 : 1) / 500;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["interpolateZoom"],
      gestures = [],
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function (collection, transform) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);

    if (collection !== selection) {
      schedule(collection, transform);
    } else {
      selection.interrupt().each(function () {
        gesture(this, arguments).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
      });
    }
  };

  zoom.scaleBy = function (selection, k) {
    zoom.scaleTo(selection, function () {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function (selection, k) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    });
  };

  zoom.translateBy = function (selection, x, y) {
    zoom.transform(selection, function () {
      return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function (selection, x, y) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p = centroid(e);
      return constrain(_transform__WEBPACK_IMPORTED_MODULE_7__["identity"].translate(p[0], p[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
    });
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k,
        y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform__WEBPACK_IMPORTED_MODULE_7__["Transform"](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, center) {
    transition.on("start.zoom", function () {
      gesture(this, arguments).start();
    }).on("interrupt.zoom end.zoom", function () {
      gesture(this, arguments).end();
    }).tween("zoom", function () {
      var that = this,
          args = arguments,
          g = gesture(that, args),
          e = extent.apply(that, args),
          p = center || centroid(e),
          w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
          a = that.__zoom,
          b = typeof transform === "function" ? transform.apply(that, args) : transform,
          i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function (t) {
        if (t === 1) t = b; // Avoid rounding error on end.
        else {
            var l = i(t),
                k = w / l[2];
            t = new _transform__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, p[0] - l[0] * k, p[1] - l[1] * k);
          }
        g.zoom(null, t);
      };
    });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }

    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function start() {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }

      return this;
    },
    zoom: function zoom(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function end() {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }

      return this;
    },
    emit: function emit(type) {
      Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["customEvent"])(new _event__WEBPACK_IMPORTED_MODULE_6__["default"](zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this); // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.

    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }

      clearTimeout(g.wheel);
    } // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return; // Otherwise, capture the mouse point and location at the start.
      else {
          g.mouse = [p, t.invert(p)];
          Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
          g.start();
        }

    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["default"])();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this),
        x0 = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientX,
        y0 = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientY;
    Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragDisable"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view);
    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();
    g.mouse = [p, this.__zoom.invert(p)];
    Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
    g.start();

    function mousemoved() {
      Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["default"])();

      if (!g.moved) {
        var dx = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientX - x0,
            dy = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }

      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragEnable"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view, g.moved);
      Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["default"])();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);
    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["default"])();
    if (duration > 0) Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).transition().duration(duration).call(schedule, t1, p0);else Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches,
        started,
        n = touches.length,
        i,
        t,
        p;
    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();

    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["touch"])(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;else if (!g.touch1) g.touch1 = p;
    } // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.


    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);

      if (!g.touch1) {
        g.end();
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function () {
        touchstarting = null;
      }, touchDelay);
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches,
        n = touches.length,
        i,
        t,
        p,
        l;
    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["default"])();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["touch"])(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }

    t = g.that.__zoom;

    if (g.touch1) {
      var p0 = g.touch0[0],
          l0 = g.touch0[1],
          p1 = g.touch1[0],
          l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches,
        n = touches.length,
        i,
        t;
    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, touchDelay);

    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }

    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);else g.end();
  }

  zoom.wheelDelta = function (_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_5__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_5__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function (_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function (_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function (_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function (_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function (_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
});

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/promise-polyfill/src/finally.js":
/*!******************************************************!*\
  !*** ./node_modules/promise-polyfill/src/finally.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (callback) {
  var constructor = this.constructor;
  return this.then(function (value) {
    return constructor.resolve(callback()).then(function () {
      return value;
    });
  }, function (reason) {
    return constructor.resolve(callback()).then(function () {
      return constructor.reject(reason);
    });
  });
});

/***/ }),

/***/ "./node_modules/promise-polyfill/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/promise-polyfill/src/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony import */ var _finally__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./finally */ "./node_modules/promise-polyfill/src/finally.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

 // Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())

var setTimeoutFunc = setTimeout;

function noop() {} // Polyfill for Function.prototype.bind


function bind(fn, thisArg) {
  return function () {
    fn.apply(thisArg, arguments);
  };
}

function Promise(fn) {
  if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  this._state = 0;
  this._handled = false;
  this._value = undefined;
  this._deferreds = [];
  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }

  if (self._state === 0) {
    self._deferreds.push(deferred);

    return;
  }

  self._handled = true;

  Promise._immediateFn(function () {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;

    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }

    var ret;

    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }

    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');

    if (newValue && (_typeof(newValue) === 'object' || typeof newValue === 'function')) {
      var then = newValue.then;

      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }

    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function () {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }

  self._deferreds = null;
}

function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}
/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */


function doResolve(fn, self) {
  var done = false;

  try {
    fn(function (value) {
      if (done) return;
      done = true;
      resolve(self, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(self, reason);
    });
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function (onFulfilled, onRejected) {
  var prom = new this.constructor(noop);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = _finally__WEBPACK_IMPORTED_MODULE_0__["default"];

Promise.all = function (arr) {
  return new Promise(function (resolve, reject) {
    if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (_typeof(val) === 'object' || typeof val === 'function')) {
          var then = val.then;

          if (typeof then === 'function') {
            then.call(val, function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }

        args[i] = val;

        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function (value) {
  if (value && _typeof(value) === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function (resolve) {
    resolve(value);
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
}; // Use polyfill for setImmediate for performance gains


Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {
  setImmediate(fn);
} || function (fn) {
  setTimeoutFunc(fn, 0);
};

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/* harmony default export */ __webpack_exports__["default"] = (Promise);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/promise-polyfill/src/polyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/promise-polyfill/src/polyfill.js ***!
  \*******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/promise-polyfill/src/index.js");
/* harmony import */ var _finally__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./finally */ "./node_modules/promise-polyfill/src/finally.js");



var globalNS = function () {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof global !== 'undefined') {
    return global;
  }

  throw new Error('unable to locate global object');
}();

if (!globalNS.Promise) {
  globalNS.Promise = _index__WEBPACK_IMPORTED_MODULE_0__["default"];
} else if (!globalNS.Promise.prototype['finally']) {
  globalNS.Promise.prototype['finally'] = _finally__WEBPACK_IMPORTED_MODULE_1__["default"];
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/topojson-client/index.js":
/*!***********************************************!*\
  !*** ./node_modules/topojson-client/index.js ***!
  \***********************************************/
/*! exports provided: bbox, feature, mesh, meshArcs, merge, mergeArcs, neighbors, quantize, transform, untransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/bbox */ "./node_modules/topojson-client/src/bbox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bbox", function() { return _src_bbox__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_feature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/feature */ "./node_modules/topojson-client/src/feature.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "feature", function() { return _src_feature__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/mesh */ "./node_modules/topojson-client/src/mesh.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mesh", function() { return _src_mesh__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "meshArcs", function() { return _src_mesh__WEBPACK_IMPORTED_MODULE_2__["meshArcs"]; });

/* harmony import */ var _src_merge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/merge */ "./node_modules/topojson-client/src/merge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _src_merge__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeArcs", function() { return _src_merge__WEBPACK_IMPORTED_MODULE_3__["mergeArcs"]; });

/* harmony import */ var _src_neighbors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/neighbors */ "./node_modules/topojson-client/src/neighbors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "neighbors", function() { return _src_neighbors__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_quantize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/quantize */ "./node_modules/topojson-client/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _src_quantize__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_transform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/transform */ "./node_modules/topojson-client/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return _src_transform__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_untransform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/untransform */ "./node_modules/topojson-client/src/untransform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "untransform", function() { return _src_untransform__WEBPACK_IMPORTED_MODULE_7__["default"]; });










/***/ }),

/***/ "./node_modules/topojson-client/src/bbox.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/bbox.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform */ "./node_modules/topojson-client/src/transform.js");

/* harmony default export */ __webpack_exports__["default"] = (function (topology) {
  var t = Object(_transform__WEBPACK_IMPORTED_MODULE_0__["default"])(topology.transform),
      key,
      x0 = Infinity,
      y0 = x0,
      x1 = -x0,
      y1 = -x0;

  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0) x0 = p[0];
    if (p[0] > x1) x1 = p[0];
    if (p[1] < y0) y0 = p[1];
    if (p[1] > y1) y1 = p[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(bboxGeometry);
        break;

      case "Point":
        bboxPoint(o.coordinates);
        break;

      case "MultiPoint":
        o.coordinates.forEach(bboxPoint);
        break;
    }
  }

  topology.arcs.forEach(function (arc) {
    var i = -1,
        n = arc.length,
        p;

    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }
  });

  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }

  return [x0, y0, x1, y1];
});

/***/ }),

/***/ "./node_modules/topojson-client/src/bisect.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/bisect.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, x) {
  var lo = 0,
      hi = a.length;

  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;else hi = mid;
  }

  return lo;
});

/***/ }),

/***/ "./node_modules/topojson-client/src/feature.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/feature.js ***!
  \*****************************************************/
/*! exports provided: default, feature, object */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "feature", function() { return feature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "object", function() { return object; });
/* harmony import */ var _reverse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse */ "./node_modules/topojson-client/src/reverse.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform */ "./node_modules/topojson-client/src/transform.js");


/* harmony default export */ __webpack_exports__["default"] = (function (topology, o) {
  return o.type === "GeometryCollection" ? {
    type: "FeatureCollection",
    features: o.geometries.map(function (o) {
      return feature(topology, o);
    })
  } : feature(topology, o);
});
function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {
    type: "Feature",
    properties: properties,
    geometry: geometry
  } : bbox == null ? {
    type: "Feature",
    id: id,
    properties: properties,
    geometry: geometry
  } : {
    type: "Feature",
    id: id,
    bbox: bbox,
    properties: properties,
    geometry: geometry
  };
}
function object(topology, o) {
  var transformPoint = Object(_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();

    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }

    if (i < 0) Object(_reverse__WEBPACK_IMPORTED_MODULE_0__["default"])(points, n);
  }

  function point(p) {
    return transformPoint(p);
  }

  function line(arcs) {
    var points = [];

    for (var i = 0, n = arcs.length; i < n; ++i) {
      arc(arcs[i], points);
    }

    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.

    return points;
  }

  function ring(arcs) {
    var points = line(arcs);

    while (points.length < 4) {
      points.push(points[0]);
    } // This may happen if an arc has only two points.


    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type,
        coordinates;

    switch (type) {
      case "GeometryCollection":
        return {
          type: type,
          geometries: o.geometries.map(geometry)
        };

      case "Point":
        coordinates = point(o.coordinates);
        break;

      case "MultiPoint":
        coordinates = o.coordinates.map(point);
        break;

      case "LineString":
        coordinates = line(o.arcs);
        break;

      case "MultiLineString":
        coordinates = o.arcs.map(line);
        break;

      case "Polygon":
        coordinates = polygon(o.arcs);
        break;

      case "MultiPolygon":
        coordinates = o.arcs.map(polygon);
        break;

      default:
        return null;
    }

    return {
      type: type,
      coordinates: coordinates
    };
  }

  return geometry(o);
}

/***/ }),

/***/ "./node_modules/topojson-client/src/identity.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/identity.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x;
});

/***/ }),

/***/ "./node_modules/topojson-client/src/merge.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/merge.js ***!
  \***************************************************/
/*! exports provided: default, mergeArcs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeArcs", function() { return mergeArcs; });
/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch */ "./node_modules/topojson-client/src/stitch.js");



function planarRingArea(ring) {
  var i = -1,
      n = ring.length,
      a,
      b = ring[n - 1],
      area = 0;

  while (++i < n) {
    a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  }

  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ __webpack_exports__["default"] = (function (topology) {
  return Object(_feature__WEBPACK_IMPORTED_MODULE_0__["object"])(topology, mergeArcs.apply(this, arguments));
});
function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];
  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;

      case "Polygon":
        extract(o.arcs);
        break;

      case "MultiPolygon":
        o.arcs.forEach(extract);
        break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function (ring) {
      ring.forEach(function (arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea(Object(_feature__WEBPACK_IMPORTED_MODULE_0__["object"])(topology, {
      type: "Polygon",
      arcs: [ring]
    }).coordinates[0]);
  }

  polygons.forEach(function (polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);

      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function (ring) {
          ring.forEach(function (arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });
  polygons.forEach(function (polygon) {
    delete polygon._;
  });
  return {
    type: "MultiPolygon",
    arcs: groups.map(function (polygons) {
      var arcs = [],
          n; // Extract the exterior (unique) arcs.

      polygons.forEach(function (polygon) {
        polygon.forEach(function (ring) {
          ring.forEach(function (arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      }); // Stitch the arcs into one or more rings.

      arcs = Object(_stitch__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs); // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.

      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    })
  };
}

/***/ }),

/***/ "./node_modules/topojson-client/src/mesh.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/mesh.js ***!
  \**************************************************/
/*! exports provided: default, meshArcs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshArcs", function() { return meshArcs; });
/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch */ "./node_modules/topojson-client/src/stitch.js");


/* harmony default export */ __webpack_exports__["default"] = (function (topology) {
  return Object(_feature__WEBPACK_IMPORTED_MODULE_0__["object"])(topology, meshArcs.apply(this, arguments));
});
function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) {
    arcs[i] = i;
  }
  return {
    type: "MultiLineString",
    arcs: Object(_stitch__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs)
  };
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({
      i: i,
      g: geom
    });
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;

      case "LineString":
        extract1(o.arcs);
        break;

      case "MultiLineString":
      case "Polygon":
        extract2(o.arcs);
        break;

      case "MultiPolygon":
        extract3(o.arcs);
        break;
    }
  }

  geometry(object);
  geomsByArc.forEach(filter == null ? function (geoms) {
    arcs.push(geoms[0].i);
  } : function (geoms) {
    if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
  });
  return arcs;
}

/***/ }),

/***/ "./node_modules/topojson-client/src/neighbors.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/neighbors.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect */ "./node_modules/topojson-client/src/bisect.js");

/* harmony default export */ __webpack_exports__["default"] = (function (objects) {
  var indexesByArc = {},
      // arc index -> array of object indexes
  neighbors = objects.map(function () {
    return [];
  });

  function line(arcs, i) {
    arcs.forEach(function (a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function (arc) {
      line(arc, i);
    });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function (o) {
      geometry(o, i);
    });else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function MultiPolygon(arcs, i) {
      arcs.forEach(function (arc) {
        polygon(arc, i);
      });
    }
  };
  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j],
            ik = indexes[k],
            n;
        if ((n = neighbors[ij])[i = Object(_bisect__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = Object(_bisect__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
});

/***/ }),

/***/ "./node_modules/topojson-client/src/quantize.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/quantize.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _untransform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./untransform */ "./node_modules/topojson-client/src/untransform.js");


/* harmony default export */ __webpack_exports__["default"] = (function (topology, transform) {
  if (topology.transform) throw new Error("already quantized");

  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be ≥2");
    box = topology.bbox || Object(_bbox__WEBPACK_IMPORTED_MODULE_0__["default"])(topology);
    var x0 = box[0],
        y0 = box[1],
        x1 = box[2],
        y1 = box[3],
        n;
    transform = {
      scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1],
      translate: [x0, y0]
    };
  } else {
    box = topology.bbox;
  }

  var t = Object(_untransform__WEBPACK_IMPORTED_MODULE_1__["default"])(transform),
      box,
      key,
      inputs = topology.objects,
      outputs = {};

  function quantizePoint(point) {
    return t(point);
  }

  function quantizeGeometry(input) {
    var output;

    switch (input.type) {
      case "GeometryCollection":
        output = {
          type: "GeometryCollection",
          geometries: input.geometries.map(quantizeGeometry)
        };
        break;

      case "Point":
        output = {
          type: "Point",
          coordinates: quantizePoint(input.coordinates)
        };
        break;

      case "MultiPoint":
        output = {
          type: "MultiPoint",
          coordinates: input.coordinates.map(quantizePoint)
        };
        break;

      default:
        return input;
    }

    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }

  function quantizeArc(input) {
    var i = 0,
        j = 1,
        n = input.length,
        p,
        output = new Array(n); // pessimistic

    output[0] = t(input[0], 0);

    while (++i < n) {
      if ((p = t(input[i], i))[0] || p[1]) output[j++] = p;
    } // non-coincident points


    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points

    output.length = j;
    return output;
  }

  for (key in inputs) {
    outputs[key] = quantizeGeometry(inputs[key]);
  }

  return {
    type: "Topology",
    bbox: box,
    transform: transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
});

/***/ }),

/***/ "./node_modules/topojson-client/src/reverse.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/reverse.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array, n) {
  var t,
      j = array.length,
      i = j - n;

  while (i < --j) {
    t = array[i], array[i++] = array[j], array[j] = t;
  }
});

/***/ }),

/***/ "./node_modules/topojson-client/src/stitch.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/stitch.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1; // Stitch empty arcs first, since they may be subsumed by other arcs.

  arcs.forEach(function (i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i],
        t;

    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function (i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f,
        g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;

      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;

      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i],
        p0 = arc[0],
        p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {
      p1[0] += dp[0], p1[1] += dp[1];
    });else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function (i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function (i) {
    if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
  });
  return fragments;
});

/***/ }),

/***/ "./node_modules/topojson-client/src/transform.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/transform.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ "./node_modules/topojson-client/src/identity.js");

/* harmony default export */ __webpack_exports__["default"] = (function (transform) {
  if (transform == null) return _identity__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function (input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;

    while (j < n) {
      output[j] = input[j], ++j;
    }

    return output;
  };
});

/***/ }),

/***/ "./node_modules/topojson-client/src/untransform.js":
/*!*********************************************************!*\
  !*** ./node_modules/topojson-client/src/untransform.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ "./node_modules/topojson-client/src/identity.js");

/* harmony default export */ __webpack_exports__["default"] = (function (transform) {
  if (transform == null) return _identity__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function (input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n),
        x1 = Math.round((input[0] - dx) / kx),
        y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;

    while (j < n) {
      output[j] = input[j], ++j;
    }

    return output;
  };
});

/***/ }),

/***/ "./node_modules/underscore/underscore.js":
/*!***********************************************!*\
  !*** ./node_modules/underscore/underscore.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function () {
  // Baseline setup
  // --------------
  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self.self === self && self || (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global.global === global && global || this || {}; // Save the previous value of the `_` variable.

  var previousUnderscore = root._; // Save bytes in the minified (but not gzipped) version:

  var ArrayProto = Array.prototype,
      ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null; // Create quick reference variables for speed access to core prototypes.

  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty; // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.

  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create; // Naked function reference for surrogate-prototype-swapping.

  var Ctor = function Ctor() {}; // Create a safe reference to the Underscore object for use below.


  var _ = function _(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  }; // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)


  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }

    exports._ = _;
  } else {
    root._ = _;
  } // Current version.


  _.VERSION = '1.9.1'; // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.

  var optimizeCb = function optimizeCb(func, context, argCount) {
    if (context === void 0) return func;

    switch (argCount == null ? 3 : argCount) {
      case 1:
        return function (value) {
          return func.call(context, value);
        };
      // The 2-argument case is omitted because we’re not using it.

      case 3:
        return function (value, index, collection) {
          return func.call(context, value, index, collection);
        };

      case 4:
        return function (accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
    }

    return function () {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee; // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result — either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.

  var cb = function cb(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  }; // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.


  _.iteratee = builtinIteratee = function builtinIteratee(value, context) {
    return cb(value, context, Infinity);
  }; // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the function’s
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6’s "rest parameter".


  var restArguments = function restArguments(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function () {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;

      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }

      switch (startIndex) {
        case 0:
          return func.call(this, rest);

        case 1:
          return func.call(this, arguments[0], rest);

        case 2:
          return func.call(this, arguments[0], arguments[1], rest);
      }

      var args = Array(startIndex + 1);

      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }

      args[startIndex] = rest;
      return func.apply(this, args);
    };
  }; // An internal function for creating a new object that inherits from another.


  var baseCreate = function baseCreate(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor();
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function shallowProperty(key) {
    return function (obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function has(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  };

  var deepGet = function deepGet(obj, path) {
    var length = path.length;

    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }

    return length ? obj : void 0;
  }; // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094


  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');

  var isArrayLike = function isArrayLike(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  }; // Collection Functions
  // --------------------
  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.


  _.each = _.forEach = function (obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;

    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);

      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }

    return obj;
  }; // Return the results of applying the iteratee to each element.


  _.map = _.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);

    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);

    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }

    return results;
  }; // Create a reducing function iterating left or right.


  var createReduce = function createReduce(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function reducer(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;

      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }

      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }

      return memo;
    };

    return function (obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  }; // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.


  _.reduce = _.foldl = _.inject = createReduce(1); // The right-associative version of reduce, also known as `foldr`.

  _.reduceRight = _.foldr = createReduce(-1); // Return the first value which passes a truth test. Aliased as `detect`.

  _.find = _.detect = function (obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  }; // Return all the elements that pass a truth test.
  // Aliased as `select`.


  _.filter = _.select = function (obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);

    _.each(obj, function (value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });

    return results;
  }; // Return all the elements for which a truth test fails.


  _.reject = function (obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  }; // Determine whether all of the elements match a truth test.
  // Aliased as `all`.


  _.every = _.all = function (obj, predicate, context) {
    predicate = cb(predicate, context);

    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;

    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }

    return true;
  }; // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.


  _.some = _.any = function (obj, predicate, context) {
    predicate = cb(predicate, context);

    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;

    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }

    return false;
  }; // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.


  _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  }; // Invoke a method (with arguments) on every item in a collection.


  _.invoke = restArguments(function (obj, path, args) {
    var contextPath, func;

    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }

    return _.map(obj, function (context) {
      var method = func;

      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }

        if (context == null) return void 0;
        method = context[path];
      }

      return method == null ? method : method.apply(context, args);
    });
  }); // Convenience version of a common use case of `map`: fetching a property.

  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  }; // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.


  _.where = function (obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  }; // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.


  _.findWhere = function (obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  }; // Return the maximum element (or element-based computation).


  _.max = function (obj, iteratee, context) {
    var result = -Infinity,
        lastComputed = -Infinity,
        value,
        computed;

    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);

      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];

        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);

      _.each(obj, function (v, index, list) {
        computed = iteratee(v, index, list);

        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }

    return result;
  }; // Return the minimum element (or element-based computation).


  _.min = function (obj, iteratee, context) {
    var result = Infinity,
        lastComputed = Infinity,
        value,
        computed;

    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);

      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];

        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);

      _.each(obj, function (v, index, list) {
        computed = iteratee(v, index, list);

        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }

    return result;
  }; // Shuffle a collection.


  _.shuffle = function (obj) {
    return _.sample(obj, Infinity);
  }; // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.


  _.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }

    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;

    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);

      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }

    return sample.slice(0, n);
  }; // Sort the object's values by a criterion produced by an iteratee.


  _.sortBy = function (obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function (value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;

      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }

      return left.index - right.index;
    }), 'value');
  }; // An internal function used for aggregate "group by" operations.


  var group = function group(behavior, partition) {
    return function (obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);

      _.each(obj, function (value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });

      return result;
    };
  }; // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.


  _.groupBy = group(function (result, value, key) {
    if (has(result, key)) result[key].push(value);else result[key] = [value];
  }); // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.

  _.indexBy = group(function (result, value, key) {
    result[key] = value;
  }); // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.

  _.countBy = group(function (result, value, key) {
    if (has(result, key)) result[key]++;else result[key] = 1;
  });
  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g; // Safely create a real, live array from anything iterable.

  _.toArray = function (obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);

    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }

    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  }; // Return the number of elements in an object.


  _.size = function (obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  }; // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.


  _.partition = group(function (result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true); // Array Functions
  // ---------------
  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.

  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  }; // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.


  _.initial = function (array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  }; // Get the last element of an array. Passing **n** will return the last N
  // values in the array.


  _.last = function (array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  }; // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.


  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  }; // Trim out all falsy values from an array.


  _.compact = function (array) {
    return _.filter(array, Boolean);
  }; // Internal implementation of a recursive `flatten` function.


  var flatten = function flatten(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;

    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];

      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0,
              len = value.length;

          while (j < len) {
            output[idx++] = value[j++];
          }
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }

    return output;
  }; // Flatten out an array, either recursively (by default), or just one level.


  _.flatten = function (array, shallow) {
    return flatten(array, shallow, false);
  }; // Return a version of the array that does not contain the specified value(s).


  _.without = restArguments(function (array, otherArrays) {
    return _.difference(array, otherArrays);
  }); // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.

  _.uniq = _.unique = function (array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }

    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];

    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;

      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }

    return result;
  }; // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.


  _.union = restArguments(function (arrays) {
    return _.uniq(flatten(arrays, true, true));
  }); // Produce an array that contains every item shared between all the
  // passed-in arrays.

  _.intersection = function (array) {
    var result = [];
    var argsLength = arguments.length;

    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;

      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }

      if (j === argsLength) result.push(item);
    }

    return result;
  }; // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.


  _.difference = restArguments(function (array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  }); // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.

  _.unzip = function (array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }

    return result;
  }; // Zip together multiple lists into a single array -- elements that share
  // an index go together.


  _.zip = restArguments(_.unzip); // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.

  _.object = function (list, values) {
    var result = {};

    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }

    return result;
  }; // Generator function to create the findIndex and findLastIndex functions.


  var createPredicateIndexFinder = function createPredicateIndexFinder(dir) {
    return function (array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;

      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }

      return -1;
    };
  }; // Returns the first index on an array-like that passes a predicate test.


  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1); // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.

  _.sortedIndex = function (array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0,
        high = getLength(array);

    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;
    }

    return low;
  }; // Generator function to create the indexOf and lastIndexOf functions.


  var createIndexFinder = function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function (array, item, idx) {
      var i = 0,
          length = getLength(array);

      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }

      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }

      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }

      return -1;
    };
  }; // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.


  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex); // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).

  _.range = function (start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }

    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  }; // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.


  _.chunk = function (array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0,
        length = array.length;

    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }

    return result;
  }; // Function (ahem) Functions
  // ------------------
  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.


  var executeBound = function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  }; // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.


  _.bind = restArguments(function (func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function (callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  }); // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.

  _.partial = restArguments(function (func, boundArgs) {
    var placeholder = _.partial.placeholder;

    var bound = function bound() {
      var position = 0,
          length = boundArgs.length;
      var args = Array(length);

      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }

      while (position < arguments.length) {
        args.push(arguments[position++]);
      }

      return executeBound(func, bound, this, this, args);
    };

    return bound;
  });
  _.partial.placeholder = _; // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.

  _.bindAll = restArguments(function (obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');

    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  }); // Memoize an expensive function by storing its results.

  _.memoize = function (func, hasher) {
    var memoize = function memoize(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };

    memoize.cache = {};
    return memoize;
  }; // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.


  _.delay = restArguments(function (func, wait, args) {
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  }); // Defers a function, scheduling it to run after the current call stack has
  // cleared.

  _.defer = _.partial(_.delay, _, 1); // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.

  _.throttle = function (func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function later() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function throttled() {
      var now = _.now();

      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;

      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }

      return result;
    };

    throttled.cancel = function () {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  }; // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.


  _.debounce = function (func, wait, immediate) {
    var timeout, result;

    var later = function later(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function (args) {
      if (timeout) clearTimeout(timeout);

      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function () {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  }; // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.


  _.wrap = function (func, wrapper) {
    return _.partial(wrapper, func);
  }; // Returns a negated version of the passed-in predicate.


  _.negate = function (predicate) {
    return function () {
      return !predicate.apply(this, arguments);
    };
  }; // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.


  _.compose = function () {
    var args = arguments;
    var start = args.length - 1;
    return function () {
      var i = start;
      var result = args[start].apply(this, arguments);

      while (i--) {
        result = args[i].call(this, result);
      }

      return result;
    };
  }; // Returns a function that will only be executed on and after the Nth call.


  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  }; // Returns a function that will only be executed up to (but not including) the Nth call.


  _.before = function (times, func) {
    var memo;
    return function () {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }

      if (times <= 1) func = null;
      return memo;
    };
  }; // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.


  _.once = _.partial(_.before, 2);
  _.restArguments = restArguments; // Object Functions
  // ----------------
  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.

  var hasEnumBug = !{
    toString: null
  }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto; // Constructor is a special case.

    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];

      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }; // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.


  _.keys = function (obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];

    for (var key in obj) {
      if (has(obj, key)) keys.push(key);
    } // Ahem, IE < 9.


    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  }; // Retrieve all the property names of an object.


  _.allKeys = function (obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];

    for (var key in obj) {
      keys.push(key);
    } // Ahem, IE < 9.


    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  }; // Retrieve the values of an object's properties.


  _.values = function (obj) {
    var keys = _.keys(obj);

    var length = keys.length;
    var values = Array(length);

    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }

    return values;
  }; // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.


  _.mapObject = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);

    var keys = _.keys(obj),
        length = keys.length,
        results = {};

    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }

    return results;
  }; // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.


  _.pairs = function (obj) {
    var keys = _.keys(obj);

    var length = keys.length;
    var pairs = Array(length);

    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }

    return pairs;
  }; // Invert the keys and values of an object. The values must be serializable.


  _.invert = function (obj) {
    var result = {};

    var keys = _.keys(obj);

    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }

    return result;
  }; // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.


  _.functions = _.methods = function (obj) {
    var names = [];

    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }

    return names.sort();
  }; // An internal function for creating assigner functions.


  var createAssigner = function createAssigner(keysFunc, defaults) {
    return function (obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;

      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;

        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }

      return obj;
    };
  }; // Extend a given object with all the properties in passed-in object(s).


  _.extend = createAssigner(_.allKeys); // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

  _.extendOwn = _.assign = createAssigner(_.keys); // Returns the first key on an object that passes a predicate test.

  _.findKey = function (obj, predicate, context) {
    predicate = cb(predicate, context);

    var keys = _.keys(obj),
        key;

    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  }; // Internal pick helper function to determine if `obj` has key `key`.


  var keyInObj = function keyInObj(value, key, obj) {
    return key in obj;
  }; // Return a copy of the object only containing the whitelisted properties.


  _.pick = restArguments(function (obj, keys) {
    var result = {},
        iteratee = keys[0];
    if (obj == null) return result;

    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }

    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }

    return result;
  }); // Return a copy of the object without the blacklisted properties.

  _.omit = restArguments(function (obj, keys) {
    var iteratee = keys[0],
        context;

    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);

      iteratee = function iteratee(value, key) {
        return !_.contains(keys, key);
      };
    }

    return _.pick(obj, iteratee, context);
  }); // Fill in a given object with default properties.

  _.defaults = createAssigner(_.allKeys, true); // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.

  _.create = function (prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  }; // Create a (shallow-cloned) duplicate of an object.


  _.clone = function (obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  }; // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.


  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  }; // Returns whether an object has a given set of `key:value` pairs.


  _.isMatch = function (object, attrs) {
    var keys = _.keys(attrs),
        length = keys.length;

    if (object == null) return !length;
    var obj = Object(object);

    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }

    return true;
  }; // Internal recursive comparison function for `isEqual`.


  var eq, deepEq;

  eq = function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b; // `null` or `undefined` only equal to itself (strict comparison).

    if (a == null || b == null) return false; // `NaN`s are equivalent, but non-reflexive.

    if (a !== a) return b !== b; // Exhaust primitive checks

    var type = _typeof(a);

    if (type !== 'function' && type !== 'object' && _typeof(b) != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  }; // Internal recursive comparison function for `isEqual`.


  deepEq = function deepEq(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names.

    var className = toString.call(a);
    if (className !== toString.call(b)) return false;

    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]': // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')

      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;

      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values.

        return +a === 0 ? 1 / +a === 1 / b : +a === +b;

      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;

      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';

    if (!areArrays) {
      if (_typeof(a) != 'object' || _typeof(b) != 'object') return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.

      var aCtor = a.constructor,
          bCtor = b.constructor;

      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
        return false;
      }
    } // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.


    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;

    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    } // Add the first object to the stack of traversed objects.


    aStack.push(a);
    bStack.push(b); // Recursively compare objects and arrays.

    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties.

      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a),
          key;

      length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.

      if (_.keys(b).length !== length) return false;

      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    } // Remove the first object from the stack of traversed objects.


    aStack.pop();
    bStack.pop();
    return true;
  }; // Perform a deep comparison to check if two objects are equal.


  _.isEqual = function (a, b) {
    return eq(a, b);
  }; // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.


  _.isEmpty = function (obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  }; // Is a given value a DOM element?


  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  }; // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray


  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) === '[object Array]';
  }; // Is a given variable an object?


  _.isObject = function (obj) {
    var type = _typeof(obj);

    return type === 'function' || type === 'object' && !!obj;
  }; // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.


  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  }); // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.


  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return has(obj, 'callee');
    };
  } // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).


  var nodelist = root.document && root.document.childNodes;

  if (typeof /./ != 'function' && (typeof Int8Array === "undefined" ? "undefined" : _typeof(Int8Array)) != 'object' && typeof nodelist != 'function') {
    _.isFunction = function (obj) {
      return typeof obj == 'function' || false;
    };
  } // Is a given object a finite number?


  _.isFinite = function (obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  }; // Is the given value `NaN`?


  _.isNaN = function (obj) {
    return _.isNumber(obj) && isNaN(obj);
  }; // Is a given value a boolean?


  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  }; // Is a given value equal to null?


  _.isNull = function (obj) {
    return obj === null;
  }; // Is a given variable undefined?


  _.isUndefined = function (obj) {
    return obj === void 0;
  }; // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).


  _.has = function (obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }

    var length = path.length;

    for (var i = 0; i < length; i++) {
      var key = path[i];

      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }

      obj = obj[key];
    }

    return !!length;
  }; // Utility Functions
  // -----------------
  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.


  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  }; // Keep the identity function around for default iteratees.


  _.identity = function (value) {
    return value;
  }; // Predicate-generating functions. Often useful outside of Underscore.


  _.constant = function (value) {
    return function () {
      return value;
    };
  };

  _.noop = function () {}; // Creates a function that, when passed an object, will traverse that object’s
  // properties down the given `path`, specified as an array of keys or indexes.


  _.property = function (path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }

    return function (obj) {
      return deepGet(obj, path);
    };
  }; // Generates a function for a given object that returns a given property.


  _.propertyOf = function (obj) {
    if (obj == null) {
      return function () {};
    }

    return function (path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  }; // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.


  _.matcher = _.matches = function (attrs) {
    attrs = _.extendOwn({}, attrs);
    return function (obj) {
      return _.isMatch(obj, attrs);
    };
  }; // Run a function **n** times.


  _.times = function (n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);

    for (var i = 0; i < n; i++) {
      accum[i] = iteratee(i);
    }

    return accum;
  }; // Return a random integer between min and max (inclusive).


  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }

    return min + Math.floor(Math.random() * (max - min + 1));
  }; // A (possibly faster) way to get the current timestamp as an integer.


  _.now = Date.now || function () {
    return new Date().getTime();
  }; // List of HTML entities for escaping.


  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };

  var unescapeMap = _.invert(escapeMap); // Functions for escaping and unescaping strings to/from HTML interpolation.


  var createEscaper = function createEscaper(map) {
    var escaper = function escaper(match) {
      return map[match];
    }; // Regexes for identifying a key that needs to be escaped.


    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function (string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };

  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap); // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.

  _.result = function (obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;

    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }

    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];

      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }

      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }

    return obj;
  }; // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.


  var idCounter = 0;

  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  }; // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.


  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  }; // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.

  var noMatch = /(.)^/; // Certain characters need to be escaped so that they can be put into a
  // string literal.

  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    "\u2028": 'u2028',
    "\u2029": 'u2029'
  };
  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function escapeChar(match) {
    return '\\' + escapes[match];
  }; // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.


  _.template = function (text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings); // Combine delimiters into one regular expression via alternation.

    var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g'); // Compile the template source, escaping string literals appropriately.

    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      } // Adobe VMs need the match returned to produce the correct offset.


      return match;
    });
    source += "';\n"; // If a variable is not specified, place data values in local scope.

    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
    source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
    var render;

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function template(data) {
      return render.call(this, data, _);
    }; // Provide the compiled source as a convenience for precompilation.


    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';
    return template;
  }; // Add a "chain" function. Start chaining a wrapped Underscore object.


  _.chain = function (obj) {
    var instance = _(obj);

    instance._chain = true;
    return instance;
  }; // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  // Helper function to continue chaining intermediate results.


  var chainResult = function chainResult(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  }; // Add your own custom functions to the Underscore object.


  _.mixin = function (obj) {
    _.each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];

      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });

    return _;
  }; // Add all of the Underscore functions to the wrapper object.


  _.mixin(_); // Add all mutator Array functions to the wrapper.


  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
    var method = ArrayProto[name];

    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  }); // Add all accessor Array functions to the wrapper.


  _.each(['concat', 'join', 'slice'], function (name) {
    var method = ArrayProto[name];

    _.prototype[name] = function () {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  }); // Extracts the result from a wrapped and chained object.


  _.prototype.value = function () {
    return this._wrapped;
  }; // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.


  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function () {
    return String(this._wrapped);
  }; // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.


  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return _;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./src/agent.mjs":
/*!***********************!*\
  !*** ./src/agent.mjs ***!
  \***********************/
/*! exports provided: createAgent */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAgent", function() { return createAgent; });
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./d3 */ "./src/d3.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./micro */ "./src/micro.mjs");



/**
 * Returns a new agent. An agent executes tasks and stores the result of the most recently completed task.
 *
 * A task is a value or promise, or a function that returns a value or promise. After submitting a task to
 * an agent using the submit() method, the task is evaluated and its result becomes the agent's value,
 * replacing the previous value. If a task is submitted to an agent while an earlier task is still in
 * progress, the earlier task is cancelled and its result ignored. Evaluation of a task may even be skipped
 * entirely if cancellation occurs early enough.
 *
 * Agents are D3 event emitters. When a submitted task is accepted for invocation by an agent, a
 * "submit" event is emitted. This event has the agent as its sole argument. When a task finishes and
 * the agent's value changes, an "update" event is emitted, providing (value, agent) as arguments. If a task
 * fails by either throwing an exception or rejecting a promise, a "reject" event having arguments (err, agent)
 * is emitted. If an event handler throws an error, a "fail" event having arguments (err, agent) is emitted.
 *
 * The current task can be cancelled by invoking the agent.cancel() method, and the cancel status is available
 * as the Boolean agent.cancel.requested key. Within the task callback, the "this" context is set to the agent,
 * so a task can know to abort execution by checking the this.cancel.requested key. Similarly, a task can cancel
 * itself by invoking this.cancel().
 *
 * Example pseudocode:
 * <pre>
 *     const agent = createAgent();
 *     agent.on("update", function(value) {
 *         console.log("task completed: " + value);  // same as agent.value()
 *     });
 *
 *     function someLongAsynchronousProcess(x) {  // x === "abc"
 *         return new Promise(...);
 *     }
 *
 *     agent.submit(someLongAsynchronousProcess, "abc");
 * </pre>
 *
 * UNDONE: agent should behave like model, supporting "?" in event names and wrapping, not inheriting, d3 dispatch.
 *
 * @param {Object} [options]
 * @returns {Object}
 */

function createAgent(options) {
  var name = options.name,
      initial = options.initial,
      _options$events = options.events,
      events = _options$events === void 0 ? [] : _options$events;
  var allEvents = events.concat(["submit", "update", "reject", "fail"]);
  var dispatch = _d3__WEBPACK_IMPORTED_MODULE_0__["dispatch"].apply(undefined, allEvents);
  /**
   * @returns {Function} a cancel function for a task.
   */

  function cancelFactory() {
    return function cancel() {
      cancel.requested = true;
      return agent;
    };
  }
  /**
   * Invokes the specified task.
   * @param cancel the task's cancel function.
   * @param taskAndArguments the [task-function-or-value, arg0, arg1, ...] array.
   */


  function runTask(cancel, taskAndArguments) {
    var task;

    function run(args) {
      return cancel.requested ? null : underscore__WEBPACK_IMPORTED_MODULE_1__.isFunction(task) ? task.apply(agent, args) : task;
    }

    function accept(result) {
      if (!cancel.requested) {
        _value = result;
        dispatch.call("update", null, result, agent);
      }
    }

    function reject(err) {
      if (!cancel.requested) {
        // ANNOYANCE: when cancelled, this task's error is silently suppressed
        dispatch.call("reject", null, err, agent);
      }
    }

    function fail(err) {
      dispatch.call("fail", null, err, agent);
    }

    try {
      // When all arguments are resolved, invoke the task then either accept or reject the result.
      task = taskAndArguments[0];
      Promise.all(underscore__WEBPACK_IMPORTED_MODULE_1__.tail(taskAndArguments)).then(run).then(accept, reject).catch(fail);
      dispatch.call("submit", null, agent);
    } catch (err) {
      fail(err);
    }
  }

  var _value = initial;

  var runTask_debounced = underscore__WEBPACK_IMPORTED_MODULE_1__.debounce(runTask, 0); // ignore multiple simultaneous submissions--reduces noise


  var agent = _micro__WEBPACK_IMPORTED_MODULE_2__["assign"](dispatch, {
    /**
     * @returns {Object} this agent's current value.
     */
    value: function value() {
      return _value;
    },

    /**
     * Cancels this agent's most recently submitted task.
     */
    cancel: cancelFactory(),

    /**
     * Submit a new task and arguments to invoke the task with. The task may return a promise for
     * asynchronous tasks, and all arguments may be either values or promises. The previously submitted
     * task, if any, is immediately cancelled.
     * @returns {agent} the agent.
     */
    submit: function submit(task, arg0, arg1, and_so_on) {
      // immediately cancel the previous task
      this.cancel(); // schedule the new task and update the agent with its associated cancel function

      runTask_debounced(this.cancel = cancelFactory(), arguments);
      return this;
    },
    toString: function toString() {
      return name;
    }
  });
  return agent;
}

/***/ }),

/***/ "./src/blacklist.mjs":
/*!***************************!*\
  !*** ./src/blacklist.mjs ***!
  \***************************/
/*! exports provided: contains, deny */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return contains; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deny", function() { return deny; });
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./d3 */ "./src/d3.mjs");

var blacklist = [/dailymail/i, /tamilinstanews/i, /xtremeweatherforecast/i, /oracle77.asuscomm/i];
function contains(referrer) {
  var host = referrer.split("/")[2] || "";
  return blacklist.some(function (regex) {
    return regex.test(host);
  });
}
function deny() {
  return _d3__WEBPACK_IMPORTED_MODULE_0__["select"]("body").attr("style", "font-size: 12em; color: red;").text("XX - contact @cambecc").selectAll("*").remove();
}

/***/ }),

/***/ "./src/canvas/twod.mjs":
/*!*****************************!*\
  !*** ./src/canvas/twod.mjs ***!
  \*****************************/
/*! exports provided: createCanvas, clearContext, clearCanvas, makeStrokeRenderer, makeLayerRenderer */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvas", function() { return createCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearContext", function() { return clearContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearCanvas", function() { return clearCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeStrokeRenderer", function() { return makeStrokeRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeLayerRenderer", function() { return makeLayerRenderer; });
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/*
 * twod: canvas 2d helpers
 *
 * Copyright (c) 2018 Cameron Beccario
 */
 // /**
//  * Resize the canvas's drawing buffer.
//  *
//  * @param {HTMLCanvasElement} canvas element to resize
//  * @param {number} width of drawing buffer
//  * @param {number} height of drawing buffer
//  */
// export function resizeDrawingBuffer(canvas, width, height) {
//     if (canvas.width !== width || canvas.height !== height) {
//         canvas.width = width;
//         canvas.height = height;
//     }
// }
//
// /**
//  * Resize the canvas's drawing buffer to match the canvas's display size using the specified pixel ratio. For example,
//  * a ratio of 2.0 would make the drawing buffer twice the size in each dimension as the display size (and thus 4x the
//  * pixel count), whereas a ratio of 0.5 halves the size.
//  *
//  * @param {HTMLCanvasElement} canvas element to resize.
//  * @param {number} pixelRatio ratio of drawing buffer size to display size in each dimension.
//  */
// export function resizeDrawingBufferToDisplay(canvas, pixelRatio) {
//     resizeDrawingBuffer(
//         canvas,
//         Math.round(canvas.clientWidth * pixelRatio),
//         Math.round(canvas.clientHeight * pixelRatio));
// }

/**
 * @param {number} [width] width of drawing buffer
 * @param {number} [height] height of drawing buffer
 * @returns {HTMLCanvasElement}
 */

function createCanvas() {
  var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var result =
  /** @type {HTMLCanvasElement} */
  document.createElement("canvas");
  result.width = width;
  result.height = height; // resizeDrawingBuffer(result, width, height);

  return result;
}
/** @param {CanvasRenderingContext2D} ctx clears this 2d context */

function clearContext(ctx) {
  var _ctx$canvas = ctx.canvas,
      width = _ctx$canvas.width,
      height = _ctx$canvas.height;
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, width, height);
  ctx.restore();
}
/** @param {HTMLCanvasElement} canvas clears the 2d context of the canvas */

function clearCanvas(canvas) {
  clearContext(canvas.getContext("2d"));
}
function makeStrokeRenderer(mesh, options) {
  return {
    /**
     * @param {CanvasRenderingContext2D} context
     * @param path D3 path function
     */
    renderTo: function renderTo(context, path) {
      _micro__WEBPACK_IMPORTED_MODULE_0__["assign"](context, options);
      context.beginPath();
      path(mesh);
      context.stroke();
    }
  };
}
function makeLayerRenderer(renderers) {
  return {
    /**
     * @param {CanvasRenderingContext2D} context
     * @param path D3 path function
     */
    renderTo: function renderTo(context, path) {
      clearContext(context);
      path.context(context);
      context.lineJoin = "bevel";
      renderers.forEach(function (r) {
        return r.renderTo(context, path);
      });
    }
  };
}

/***/ }),

/***/ "./src/clock.mjs":
/*!***********************!*\
  !*** ./src/clock.mjs ***!
  \***********************/
/*! exports provided: now, calibration, calibrated */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calibration", function() { return calibration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calibrated", function() { return calibrated; });
/*
 * clock: a singleton wall clock that can be calibrated against the server or explicitly set.
 *
 *   const clock = require("./clock");                                    // uncalibrated clock using system time
 *   const clock = require("./clock").calibration({fixed: new Date()});   // clock set to a fixed time
 *   const clock = require("./clock").calibration({server: "/"});         // clock synchronized with server at url
 *
 *   const calibration = clock.calibration();                             // current calibration
 *   clock.calibrated().then(calibration => console.log(calibration));    // promise for pending calibration
 *
 *   clock.now();  // current time according to clock, in millis.
 *
 * Example calibrations:
 *   {skew: 0}                   // uncalibrated
 *   {fixed: 1448172991313}      // fixed
 *   {skew: 0, δ: 200, θ: 300}   // server calibrated
 */
// CONSIDER: switch this to a registry of Clock objects that each have a name. Default instance can have an
// undefined name. This avoids a singleton instance which is unnecessarily restrictive.
var _now = skewClock;
var _calibration = {
  skew: 0
};

var _p = Promise.resolve(_calibration);

function skewClock() {
  return Date.now() + _calibration.skew;
}

function fixedClock() {
  return _calibration.fixed;
}

function calibrate(url) {
  // Calculate offset θ by measuring round-trip time δ of an HTTPS request against the "Date" header of the
  // response (i.e., the server's time). See https://en.wikipedia.org/wiki/Network_Time_Protocol.
  //
  // server      t1--t2
  //            /      \
  // client   t0        t3
  //
  // The precision of t0 and t3 is in milliseconds whereas t1 and t2 is in seconds. But we don't care because
  // we don't need sub-second accuracy.
  return new Promise(function (resolve, reject) {
    var req = new XMLHttpRequest();
    var t0 = Date.now();

    req.onload = function () {
      var t3 = Date.now();
      var t2 = new Date(req.getResponseHeader("Date")).getTime() || NaN;
      var t1 = t2;
      var δ = t3 - t0 - (t2 - t1);
      var θ = (t1 - t0 + (t2 - t3)) / 2; // Use offset when larger than 10 sec and larger than round-trip by an order of magnitude. Seems legit.

      var skew = Math.abs(θ) > Math.max(10000, δ * 10) ? θ : 0;
      resolve({
        skew: skew,
        δ: δ,
        θ: θ
      });
    };

    req.onerror = reject;
    req.open("HEAD", url);
    req.setRequestHeader("Cache-Control", "no-cache");
    req.send();
  });
}
/** @returns {number} unix time */


function now() {
  return _now();
}
/**
 * @param {Object?} c sets the calibration: {server: url} or {fixed: date}. When server specified, an XHR fetches
 *        the server time. The `calibrated` method returns this operation's promise. Example server url: "/"
 * @returns {Object} current calibration {skew: number} or {fixed: number}, or undefined when setting calibration.
 */

function calibration(c) {
  if (c === undefined) {
    return _calibration;
  }

  if (typeof c.server === "string") {
    _p = calibrate(c.server).then(function (c) {
      _now = skewClock;
      return _calibration = c;
    });
  } else {
    var fixed = +new Date(c.fixed);

    if (fixed === fixed) {
      _now = fixedClock;
      _p = Promise.resolve(_calibration = {
        fixed: fixed
      });
    } else {
      _now = skewClock;
      _p = Promise.resolve(_calibration = {
        skew: +c.skew || 0
      });
    }
  }
}
/** @returns {Promise} a promise for the most recently set calibration. */

function calibrated() {
  return _p;
}

/***/ }),

/***/ "./src/consts.mjs":
/*!************************!*\
  !*** ./src/consts.mjs ***!
  \************************/
/*! exports provided: π, τ, DEG, RAD, MISSING */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "π", function() { return π; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "τ", function() { return τ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEG", function() { return DEG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RAD", function() { return RAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MISSING", function() { return MISSING; });
var π = Math.PI;
var τ = 2 * π;
var DEG = 360 / τ;
var RAD = τ / 360;
var MISSING = 7e37;

/***/ }),

/***/ "./src/d3.mjs":
/*!********************!*\
  !*** ./src/d3.mjs ***!
  \********************/
/*! exports provided: nest, set, map, keys, values, entries, color, rgb, hsl, lab, hcl, lch, gray, cubehelix, dispatch, drag, dragDisable, dragEnable, easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut, geoArea, geoBounds, geoCentroid, geoCircle, geoClipAntimeridian, geoClipCircle, geoClipExtent, geoClipRectangle, geoContains, geoDistance, geoGraticule, geoGraticule10, geoInterpolate, geoLength, geoPath, geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEqualAreaRaw, geoAzimuthalEquidistant, geoAzimuthalEquidistantRaw, geoConicConformal, geoConicConformalRaw, geoConicEqualArea, geoConicEqualAreaRaw, geoConicEquidistant, geoConicEquidistantRaw, geoEquirectangular, geoEquirectangularRaw, geoGnomonic, geoGnomonicRaw, geoIdentity, geoProjection, geoProjectionMutator, geoMercator, geoMercatorRaw, geoNaturalEarth1, geoNaturalEarth1Raw, geoOrthographic, geoOrthographicRaw, geoStereographic, geoStereographicRaw, geoTransverseMercator, geoTransverseMercatorRaw, geoRotation, geoStream, geoTransform, geoAiry, geoAiryRaw, geoAitoff, geoAitoffRaw, geoArmadillo, geoArmadilloRaw, geoAugust, geoAugustRaw, geoBaker, geoBakerRaw, geoBerghaus, geoBerghausRaw, geoBertin1953, geoBertin1953Raw, geoBoggs, geoBoggsRaw, geoBonne, geoBonneRaw, geoBottomley, geoBottomleyRaw, geoBromley, geoBromleyRaw, geoChamberlin, geoChamberlinRaw, geoChamberlinAfrica, geoCollignon, geoCollignonRaw, geoCraig, geoCraigRaw, geoCraster, geoCrasterRaw, geoCylindricalEqualArea, geoCylindricalEqualAreaRaw, geoCylindricalStereographic, geoCylindricalStereographicRaw, geoEckert1, geoEckert1Raw, geoEckert2, geoEckert2Raw, geoEckert3, geoEckert3Raw, geoEckert4, geoEckert4Raw, geoEckert5, geoEckert5Raw, geoEckert6, geoEckert6Raw, geoEisenlohr, geoEisenlohrRaw, geoFahey, geoFaheyRaw, geoFoucaut, geoFoucautRaw, geoGilbert, geoGingery, geoGingeryRaw, geoGinzburg4, geoGinzburg4Raw, geoGinzburg5, geoGinzburg5Raw, geoGinzburg6, geoGinzburg6Raw, geoGinzburg8, geoGinzburg8Raw, geoGinzburg9, geoGinzburg9Raw, geoGringorten, geoGringortenRaw, geoGuyou, geoGuyouRaw, geoHammer, geoHammerRaw, geoHammerRetroazimuthal, geoHammerRetroazimuthalRaw, geoHealpix, geoHealpixRaw, geoHill, geoHillRaw, geoHomolosine, geoHomolosineRaw, geoHyperelliptical, geoHyperellipticalRaw, geoInterrupt, geoInterruptedBoggs, geoInterruptedHomolosine, geoInterruptedMollweide, geoInterruptedMollweideHemispheres, geoInterruptedSinuMollweide, geoInterruptedSinusoidal, geoKavrayskiy7, geoKavrayskiy7Raw, geoLagrange, geoLagrangeRaw, geoLarrivee, geoLarriveeRaw, geoLaskowski, geoLaskowskiRaw, geoLittrow, geoLittrowRaw, geoLoximuthal, geoLoximuthalRaw, geoMiller, geoMillerRaw, geoModifiedStereographic, geoModifiedStereographicRaw, geoModifiedStereographicAlaska, geoModifiedStereographicGs48, geoModifiedStereographicGs50, geoModifiedStereographicMiller, geoModifiedStereographicLee, geoMollweide, geoMollweideRaw, geoMtFlatPolarParabolic, geoMtFlatPolarParabolicRaw, geoMtFlatPolarQuartic, geoMtFlatPolarQuarticRaw, geoMtFlatPolarSinusoidal, geoMtFlatPolarSinusoidalRaw, geoNaturalEarth, geoNaturalEarthRaw, geoNaturalEarth2, geoNaturalEarth2Raw, geoNellHammer, geoNellHammerRaw, geoPatterson, geoPattersonRaw, geoPolyconic, geoPolyconicRaw, geoPolyhedral, geoPolyhedralButterfly, geoPolyhedralCollignon, geoPolyhedralWaterman, geoProject, geoGringortenQuincuncial, geoPeirceQuincuncial, geoPierceQuincuncial, geoQuantize, geoQuincuncial, geoRectangularPolyconic, geoRectangularPolyconicRaw, geoRobinson, geoRobinsonRaw, geoSatellite, geoSatelliteRaw, geoSinuMollweide, geoSinuMollweideRaw, geoSinusoidal, geoSinusoidalRaw, geoStitch, geoTimes, geoTimesRaw, geoTwoPointAzimuthal, geoTwoPointAzimuthalRaw, geoTwoPointAzimuthalUsa, geoTwoPointEquidistant, geoTwoPointEquidistantRaw, geoTwoPointEquidistantUsa, geoVanDerGrinten, geoVanDerGrintenRaw, geoVanDerGrinten2, geoVanDerGrinten2Raw, geoVanDerGrinten3, geoVanDerGrinten3Raw, geoVanDerGrinten4, geoVanDerGrinten4Raw, geoWagner4, geoWagner4Raw, geoWagner6, geoWagner6Raw, geoWagner7, geoWagner7Raw, geoWiechel, geoWiechelRaw, geoWinkel3, geoWinkel3Raw, interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateNumber, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, piecewise, quantize, request, html, json, text, xml, csv, tsv, schemeCategory10, schemeAccent, schemeDark2, schemePaired, schemePastel1, schemePastel2, schemeSet1, schemeSet2, schemeSet3, interpolateBrBG, schemeBrBG, interpolatePRGn, schemePRGn, interpolatePiYG, schemePiYG, interpolatePuOr, schemePuOr, interpolateRdBu, schemeRdBu, interpolateRdGy, schemeRdGy, interpolateRdYlBu, schemeRdYlBu, interpolateRdYlGn, schemeRdYlGn, interpolateSpectral, schemeSpectral, interpolateBuGn, schemeBuGn, interpolateBuPu, schemeBuPu, interpolateGnBu, schemeGnBu, interpolateOrRd, schemeOrRd, interpolatePuBuGn, schemePuBuGn, interpolatePuBu, schemePuBu, interpolatePuRd, schemePuRd, interpolateRdPu, schemeRdPu, interpolateYlGnBu, schemeYlGnBu, interpolateYlGn, schemeYlGn, interpolateYlOrBr, schemeYlOrBr, interpolateYlOrRd, schemeYlOrRd, interpolateBlues, schemeBlues, interpolateGreens, schemeGreens, interpolateGreys, schemeGreys, interpolatePurples, schemePurples, interpolateReds, schemeReds, interpolateOranges, schemeOranges, interpolateCubehelixDefault, interpolateRainbow, interpolateWarm, interpolateCool, interpolateSinebow, interpolateViridis, interpolateMagma, interpolateInferno, interpolatePlasma, create, creator, local, matcher, mouse, namespace, namespaces, clientPoint, select, selectAll, selection, selector, selectorAll, style, touch, touches, window, event, customEvent, zoom, zoomTransform, zoomIdentity */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-collection */ "./node_modules/d3-collection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nest", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["nest"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "set", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["set"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["map"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["keys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["values"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "entries", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["entries"]; });

/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return d3_color__WEBPACK_IMPORTED_MODULE_1__["color"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return d3_color__WEBPACK_IMPORTED_MODULE_1__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return d3_color__WEBPACK_IMPORTED_MODULE_1__["hsl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return d3_color__WEBPACK_IMPORTED_MODULE_1__["lab"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return d3_color__WEBPACK_IMPORTED_MODULE_1__["hcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return d3_color__WEBPACK_IMPORTED_MODULE_1__["lch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return d3_color__WEBPACK_IMPORTED_MODULE_1__["gray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return d3_color__WEBPACK_IMPORTED_MODULE_1__["cubehelix"]; });

/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return d3_dispatch__WEBPACK_IMPORTED_MODULE_2__["dispatch"]; });

/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return d3_drag__WEBPACK_IMPORTED_MODULE_3__["drag"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return d3_drag__WEBPACK_IMPORTED_MODULE_3__["dragDisable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return d3_drag__WEBPACK_IMPORTED_MODULE_3__["dragEnable"]; });

/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeLinear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeQuad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeQuadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeQuadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeQuadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeCubic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeCubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeCubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeCubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easePoly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easePolyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easePolyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easePolyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeSin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeSinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeSinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeSinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeExp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeExpIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeExpOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeExpInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeCircle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeCircleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeCircleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeCircleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeBounce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeBounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeBounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeBounceInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeBack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeBackIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeBackOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeBackInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeElastic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeElasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeElasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_4__["easeElasticInOut"]; });

/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArea", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBounds", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoBounds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCentroid", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoCentroid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCircle", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoCircle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipAntimeridian", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoClipAntimeridian"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipCircle", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoClipCircle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipExtent", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoClipExtent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipRectangle", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoClipRectangle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoContains", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoContains"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoDistance", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoDistance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoGraticule"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule10", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoGraticule10"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterpolate", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoInterpolate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLength", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoLength"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPath", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoPath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbers", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoAlbers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbersUsa", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoAlbersUsa"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualArea", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoAzimuthalEqualArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualAreaRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoAzimuthalEqualAreaRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistant", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoAzimuthalEquidistant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistantRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoAzimuthalEquidistantRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformal", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoConicConformal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformalRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoConicConformalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualArea", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoConicEqualArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualAreaRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoConicEqualAreaRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistant", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoConicEquidistant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistantRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoConicEquidistantRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangular", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoEquirectangular"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangularRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoEquirectangularRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonic", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoGnomonic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonicRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoGnomonicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoIdentity", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoIdentity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjection", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoProjection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjectionMutator", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoProjectionMutator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercator", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoMercator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercatorRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoMercatorRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoNaturalEarth1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1Raw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoNaturalEarth1Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographic", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoOrthographic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographicRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoOrthographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographic", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoStereographic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographicRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoStereographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercator", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoTransverseMercator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercatorRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoTransverseMercatorRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRotation", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoRotation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStream", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoStream"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransform", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_5__["geoTransform"]; });

/* harmony import */ var d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-geo-projection */ "./node_modules/d3-geo-projection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAiry", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoAiry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAiryRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoAiryRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAitoff", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoAitoff"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAitoffRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoAitoffRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArmadillo", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoArmadillo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArmadilloRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoArmadilloRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAugust", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoAugust"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAugustRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoAugustRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBaker", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBaker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBakerRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBakerRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBerghaus", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBerghaus"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBerghausRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBerghausRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBertin1953", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBertin1953"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBertin1953Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBertin1953Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBoggs", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBoggs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBoggsRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBoggsRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBonne", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBonne"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBonneRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBonneRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBottomley", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBottomley"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBottomleyRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBottomleyRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBromley", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBromley"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBromleyRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoBromleyRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlin", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoChamberlin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlinRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoChamberlinRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlinAfrica", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoChamberlinAfrica"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCollignon", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoCollignon"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCollignonRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoCollignonRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraig", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoCraig"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraigRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoCraigRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraster", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoCraster"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCrasterRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoCrasterRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalEqualArea", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoCylindricalEqualArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalEqualAreaRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoCylindricalEqualAreaRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalStereographic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoCylindricalStereographic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalStereographicRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoCylindricalStereographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert1", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert1Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert1Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert2", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert2Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert2Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert3", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert3Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert3Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert4", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert4Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert4Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert5", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert5"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert5Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert5Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert6", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert6"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert6Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEckert6Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEisenlohr", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEisenlohr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEisenlohrRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoEisenlohrRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFahey", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoFahey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFaheyRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoFaheyRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFoucaut", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoFoucaut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFoucautRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoFoucautRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGilbert", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGilbert"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGingery", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGingery"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGingeryRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGingeryRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg4", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGinzburg4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg4Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGinzburg4Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg5", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGinzburg5"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg5Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGinzburg5Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg6", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGinzburg6"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg6Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGinzburg6Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg8", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGinzburg8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg8Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGinzburg8Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg9", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGinzburg9"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg9Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGinzburg9Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringorten", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGringorten"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringortenRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGringortenRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGuyou", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGuyou"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGuyouRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGuyouRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammer", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHammer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHammerRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRetroazimuthal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHammerRetroazimuthal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRetroazimuthalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHammerRetroazimuthalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHealpix", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHealpix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHealpixRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHealpixRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHill", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHill"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHillRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHillRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHomolosine", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHomolosine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHomolosineRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHomolosineRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHyperelliptical", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHyperelliptical"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHyperellipticalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoHyperellipticalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterrupt", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoInterrupt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedBoggs", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoInterruptedBoggs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedHomolosine", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoInterruptedHomolosine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedMollweide", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoInterruptedMollweide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedMollweideHemispheres", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoInterruptedMollweideHemispheres"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedSinuMollweide", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoInterruptedSinuMollweide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedSinusoidal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoInterruptedSinusoidal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoKavrayskiy7", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoKavrayskiy7"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoKavrayskiy7Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoKavrayskiy7Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLagrange", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoLagrange"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLagrangeRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoLagrangeRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLarrivee", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoLarrivee"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLarriveeRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoLarriveeRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLaskowski", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoLaskowski"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLaskowskiRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoLaskowskiRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLittrow", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoLittrow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLittrowRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoLittrowRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLoximuthal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoLoximuthal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLoximuthalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoLoximuthalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMiller", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoMiller"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMillerRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoMillerRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoModifiedStereographic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoModifiedStereographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicAlaska", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoModifiedStereographicAlaska"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicGs48", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoModifiedStereographicGs48"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicGs50", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoModifiedStereographicGs50"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicMiller", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoModifiedStereographicMiller"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicLee", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoModifiedStereographicLee"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMollweide", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoMollweide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMollweideRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoMollweideRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarParabolic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoMtFlatPolarParabolic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarParabolicRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoMtFlatPolarParabolicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarQuartic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoMtFlatPolarQuartic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarQuarticRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoMtFlatPolarQuarticRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarSinusoidal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoMtFlatPolarSinusoidal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarSinusoidalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoMtFlatPolarSinusoidalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoNaturalEarth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarthRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoNaturalEarthRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth2", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoNaturalEarth2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth2Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoNaturalEarth2Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNellHammer", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoNellHammer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNellHammerRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoNellHammerRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPatterson", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoPatterson"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPattersonRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoPattersonRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyconic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoPolyconic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyconicRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoPolyconicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedral", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoPolyhedral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralButterfly", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoPolyhedralButterfly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralCollignon", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoPolyhedralCollignon"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralWaterman", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoPolyhedralWaterman"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProject", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoProject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringortenQuincuncial", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoGringortenQuincuncial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPeirceQuincuncial", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoPeirceQuincuncial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPierceQuincuncial", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoPierceQuincuncial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoQuantize", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoQuantize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoQuincuncial", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoQuincuncial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRectangularPolyconic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoRectangularPolyconic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRectangularPolyconicRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoRectangularPolyconicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRobinson", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoRobinson"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRobinsonRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoRobinsonRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSatellite", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoSatellite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSatelliteRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoSatelliteRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinuMollweide", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoSinuMollweide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinuMollweideRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoSinuMollweideRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinusoidal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoSinusoidal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinusoidalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoSinusoidalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStitch", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoStitch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTimes", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoTimes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTimesRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoTimesRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoTwoPointAzimuthal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoTwoPointAzimuthalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthalUsa", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoTwoPointAzimuthalUsa"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistant", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoTwoPointEquidistant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistantRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoTwoPointEquidistantRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistantUsa", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoTwoPointEquidistantUsa"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoVanDerGrinten"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrintenRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoVanDerGrintenRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten2", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoVanDerGrinten2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten2Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoVanDerGrinten2Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten3", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoVanDerGrinten3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten3Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoVanDerGrinten3Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten4", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoVanDerGrinten4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten4Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoVanDerGrinten4Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner4", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoWagner4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner4Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoWagner4Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner6", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoWagner6"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner6Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoWagner6Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner7", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoWagner7"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner7Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoWagner7Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWiechel", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoWiechel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWiechelRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoWiechelRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWinkel3", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoWinkel3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWinkel3Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_6__["geoWinkel3Raw"]; });

/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateBasisClosed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateDate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateRound"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateTransformSvg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateZoom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateRgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateRgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateRgbBasisClosed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateHsl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateHslLong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateLab"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateHcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateHclLong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateCubehelix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["interpolateCubehelixLong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewise", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["piecewise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["quantize"]; });

/* harmony import */ var d3_request__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-request */ "./node_modules/d3-request/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "request", function() { return d3_request__WEBPACK_IMPORTED_MODULE_8__["request"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return d3_request__WEBPACK_IMPORTED_MODULE_8__["html"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "json", function() { return d3_request__WEBPACK_IMPORTED_MODULE_8__["json"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "text", function() { return d3_request__WEBPACK_IMPORTED_MODULE_8__["text"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "xml", function() { return d3_request__WEBPACK_IMPORTED_MODULE_8__["xml"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return d3_request__WEBPACK_IMPORTED_MODULE_8__["csv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsv", function() { return d3_request__WEBPACK_IMPORTED_MODULE_8__["tsv"]; });

/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeCategory10"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeAccent", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeAccent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeDark2", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeDark2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePaired", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemePaired"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel1", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemePastel1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel2", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemePastel2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet1", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeSet1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet2", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeSet2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet3", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeSet3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBrBG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateBrBG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBrBG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeBrBG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePRGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolatePRGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePRGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemePRGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePiYG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolatePiYG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePiYG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemePiYG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuOr", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolatePuOr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuOr", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemePuOr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateRdBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeRdBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdGy", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateRdGy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdGy", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeRdGy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateRdYlBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdYlBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeRdYlBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateRdYlGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdYlGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeRdYlGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSpectral", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateSpectral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSpectral", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeSpectral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateBuGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBuGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeBuGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuPu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateBuPu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBuPu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeBuPu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGnBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateGnBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGnBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeGnBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOrRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateOrRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeOrRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeOrRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBuGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolatePuBuGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuBuGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemePuBuGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolatePuBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemePuBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolatePuRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemePuRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdPu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateRdPu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdPu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeRdPu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGnBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateYlGnBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlGnBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeYlGnBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateYlGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeYlGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrBr", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateYlOrBr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlOrBr", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeYlOrBr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateYlOrRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlOrRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeYlOrRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBlues", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateBlues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBlues", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeBlues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreens", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateGreens"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGreens", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeGreens"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreys", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateGreys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGreys", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeGreys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePurples", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolatePurples"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePurples", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemePurples"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateReds", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateReds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeReds", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeReds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOranges", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateOranges"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeOranges", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["schemeOranges"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateCubehelixDefault"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateRainbow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateWarm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateCool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSinebow", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateSinebow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateViridis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateMagma"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolateInferno"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_9__["interpolatePlasma"]; });

/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["create"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["creator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["local"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["matcher"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["mouse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["namespace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["namespaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clientPoint", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["clientPoint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["select"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["selectAll"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["selection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["selector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["selectorAll"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["style"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touch", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["touch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touches", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["touches"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "event", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["event"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_10__["customEvent"]; });

/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return d3_zoom__WEBPACK_IMPORTED_MODULE_11__["zoom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return d3_zoom__WEBPACK_IMPORTED_MODULE_11__["zoomTransform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return d3_zoom__WEBPACK_IMPORTED_MODULE_11__["zoomIdentity"]; });

/**
 * @license
 *
 * Copyright 2010-2016 Mike Bostock
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the author nor the names of contributors may be used to
 *   endorse or promote products derived from this software without specific prior
 *   written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Custom D3 Build */













/***/ }),

/***/ "./src/decoder.mjs":
/*!*************************!*\
  !*** ./src/decoder.mjs ***!
  \*************************/
/*! exports provided: decodeUTF8, varpackDecode, undeltaPlane, dequantize, decodePpak, decodePpakBlock, decodeEpak, decodePackedDeltaRle */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeUTF8", function() { return decodeUTF8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "varpackDecode", function() { return varpackDecode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "undeltaPlane", function() { return undeltaPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dequantize", function() { return dequantize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePpak", function() { return decodePpak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePpakBlock", function() { return decodePpakBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeEpak", function() { return decodeEpak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePackedDeltaRle", function() { return decodePackedDeltaRle; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./src/math.mjs");
/**
 * decoder - methods for decoding weather data
 *
 * Copyright (c) 2018 Cameron Beccario
 */

/**
 * Decodes a UTF8 string from an array of bytes.
 *
 * @param {Uint8Array} bytes an array of bytes
 * @returns {String} the decoded String
 */

function decodeUTF8(bytes) {
  var charCodes = [];

  for (var i = 0; i < bytes.length;) {
    var b = bytes[i++];

    switch (b >> 4) {
      case 0xc:
      case 0xd:
        b = (b & 0x1f) << 6 | bytes[i++] & 0x3f;
        break;

      case 0xe:
        b = (b & 0x0f) << 12 | (bytes[i++] & 0x3f) << 6 | bytes[i++] & 0x3f;
        break;

      default: // use value as-is

    }

    charCodes.push(b);
  }

  return String.fromCharCode.apply(null, charCodes);
}
/*
function blockView(data, cols, rows) {
    const area = cols * rows;
    return {
        x: function(i) {
            return i % cols;
        },
        y: function(i) {
            return Math.floor(i / cols) % rows;
        },
        z: function(i) {
            return Math.floor(i / area);
        },
        valueAt: function(x, y, z) {
            if (0 <= x && x < cols) {
                if (0 <= y && y < rows) {
                    const i = z * area + y * cols + x;
                    if (0 <= z && i < data.length) {
                        return data[i];
                    }
                }
            }
            return Number.NaN;
        }
    };
}
*/

function varpackDecode(values, bytes) {
  var i = 0,
      j = 0;

  while (i < bytes.length) {
    var b = bytes[i++];

    if (b < 128) {
      b = b << 25 >> 25;
    } else {
      switch (b >> 4) {
        case 0x8:
        case 0x9:
        case 0xa:
        case 0xb:
          b = b << 26 >> 18 | bytes[i++];
          break;

        case 0xc:
        case 0xd:
          b = b << 27 >> 11 | bytes[i++] << 8 | bytes[i++];
          break;

        case 0xe:
          b = b << 28 >> 4 | bytes[i++] << 16 | bytes[i++] << 8 | bytes[i++];
          break;

        case 0xf:
          if (b === 255) {
            for (var run = 1 + bytes[i++]; run > 0; run--) {
              values[j++] = NaN;
            }

            continue;
          } else {
            b = bytes[i++] << 24 | bytes[i++] << 16 | bytes[i++] << 8 | bytes[i++];
          }

          break;
      }
    }

    values[j++] = b;
  }

  return values;
}
function undeltaPlane(values, cols, rows, grids) {
  var x, y, z, i, j, k, p;

  for (z = 0; z < grids; z++) {
    k = z * cols * rows;

    for (x = 1; x < cols; x++) {
      i = k + x;
      p = values[i - 1];
      values[i] += p === p ? p : 0;
    }

    for (y = 1; y < rows; y++) {
      j = k + y * cols;
      p = values[j - cols];
      values[j] += p === p ? p : 0;

      for (x = 1; x < cols; x++) {
        i = j + x;
        var a = values[i - 1];
        var b = values[i - cols];
        var c = values[i - cols - 1];
        p = a + b - c;
        values[i] += p === p ? p : a === a ? a : b === b ? b : c === c ? c : 0;
      }
    }
  }

  return values;
}
function dequantize(values, scaleFactor) {
  var m = Math.pow(10, scaleFactor);

  for (var i = 0; i < values.length; i++) {
    var v = values[i];
    values[i] = v === v ? v / m : 7e37;
  }

  return values;
}
/**
 * Decodes a quantized delta-plane varpack array of floats.
 *
 * @param {Uint8Array} bytes the encoded values as an array of bytes
 * @param cols size of the x dimension
 * @param rows size of the y dimension
 * @param grids size of the z dimension
 * @param scaleFactor number of decimal digits after (+) or before (-) the decimal point to retain
 * @returns {Float32Array} the decoded values
 */

function decodePpak(bytes, cols, rows, grids, scaleFactor) {
  var values = new Float32Array(cols * rows * grids);
  varpackDecode(values, bytes);
  undeltaPlane(values, cols, rows, grids);
  dequantize(values, scaleFactor);
  return values;
}
/**
 * Decodes a ppak block from a buffer having the format:
 * <pre>
 *       int32   int32   int32      float32     byte[]
 *     [ cols ][ rows ][ grids ][ scaleFactor ][ data ]
 *      ----------------------------------------------
 *                        length
 * </pre>
 * All multi-byte values are BE. The number of resulting values is cols * rows * grids.
 *
 * @param {string} type the ppak type/version string
 * @param {ArrayBuffer} buffer the buffer
 * @param offset buffer byte offset
 * @param length the byte length of the block
 * @returns {{metadata: *, values: Float32Array}} the decoded values
 */

function decodePpakBlock(type, buffer, offset, length) {
  var view = new DataView(buffer, offset, length);
  var bytes = new Uint8Array(buffer, offset + 16, length - 16);
  var cols = view.getInt32(0);
  var rows = view.getInt32(4);
  var grids = view.getInt32(8);
  var scaleFactor = view.getFloat32(12);
  return {
    metadata: {
      type: type,
      cols: cols,
      rows: rows,
      grids: grids,
      scaleFactor: scaleFactor
    },
    values: decodePpak(bytes, cols, rows, grids, scaleFactor)
  };
}
/**
 * Earth-Pack (EPAK) format:
 * <pre>
 *     head  := "head" (BE alpha-4) length (BE int) json (UTF-8 JSON string)
 *     block :=  type  (BE alpha-4) length (BE int) data (byte[])
 *     tail  := "tail"
 *     file  :=  head [block]* tail
 *
 *     head                                  block                           tail
 *     ------------------------------------  ------------------------------  ------
 *    ["head"][0x00000003][0x10, 0x11, 0x12]["ppk2"][0x00000002][0xff, 0xff]["tail"]
 *             ----------  ----------------  ------  ----------  ----------
 *               length          json         type     length       data
 * </pre>
 *
 * @param {ArrayBuffer} buffer the buffer to decode
 * @param {Object} [options] decoding options: {headerOnly: boolean}
 * @returns {{header: *, blocks: Array, metadata: Array}} the decoded values
 */

function decodeEpak(buffer, options) {
  var headerOnly = !!(options || {}).headerOnly;
  var i = 0;
  var view = new DataView(buffer);
  var head = decodeUTF8(new Uint8Array(buffer, i, 4));
  i += 4;

  if (head !== "head") {
    throw new Error("expected 'head' but found '" + head + "'");
  }

  var length = view.getInt32(i);
  i += 4;
  var header = JSON.parse(decodeUTF8(new Uint8Array(buffer, i, length)));
  i += length;
  var block;
  var blocks = [];
  var metadata = [];
  var type;

  while ((type = decodeUTF8(new Uint8Array(buffer, i, 4))) !== "tail" && !headerOnly) {
    i += 4;
    length = view.getInt32(i);
    i += 4;

    switch (type) {
      case "ppak":
      case "ppk2":
        block = decodePpakBlock(type, buffer, i, length);
        break;

      default:
        throw new Error("unknown block type: " + type);
    }

    blocks.push(block.values);
    metadata.push(block.metadata);
    i += length;
  }

  return {
    header: header,
    blocks: blocks,
    metadata: metadata
  };
}
/**
 * Decode an array having "Packed Delta RLE" encoding. This has three steps:
 *
 *    1. Unroll runs:
 *        Replace every tuple element Si := [v, X] with the run of elements it represents: v0, .., v{X-1}
 *
 *    2. Convert running deltas into absolute values:
 *        [D0, .., D{N-1}]  =>  [T0, .., T{N-1}] where Ti := T{i-1} + Di
 *                                                     T0 := D0
 *                                                     Ti == Di when T{i-1} is null or NaN
 *
 *    3. Unpack each value:
 *        [T0, .., T{N-1}]  =>  [R0, .., R{N-1}] where Ri := Ti * scaleFactor + addOffset
 *
 * NaN and null are replaced with 7e37.
 *
 * Example:
 *     [1,[2,5],3,[null,2],4]  ->  [1,2,2,2,2,2,3,null,null,4]  ->  [1,3,5,7,9,11,14,7e37,7e37,4]
 *
 * @param {array} data the encoded array of data.
 * @param {number} scaleFactor the amount to multiply each data point by.
 * @param {number} addOffset the amount to add to each data point.
 * @param {number} length the expected length of the decoded data array.
 * @returns {Float32Array} the array of decoded data.
 */

function decodePackedDeltaRle(data, scaleFactor, addOffset, length) {
  var result = new Float32Array(length);
  var j = 0;

  for (var i = 0, prev = 0; i < data.length && j < length; i++) {
    var raw = data[i];
    var isRun = Array.isArray(raw);
    var val = isRun ? raw[0] : raw;
    var stop = isRun ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["clamp"])(+raw[1] + j, j, length) : j + 1; // guard against malicious run lengths

    var v = +val;

    if (val === null || v !== v) {
      if (!(j < stop)) {
        continue; // ignore zero or NaN length runs
      }

      while (j < stop) {
        result[j++] = 7e37;
      }

      prev = 0;
    } else {
      while (j < stop) {
        var x = (prev = prev + v) * scaleFactor + addOffset;
        result[j++] = x === x ? x : 7e37;
      }
    }
  } // Fill remaining space in the result array, if any.


  while (j < length) {
    result[j++] = 7e37;
  }

  return result;
}

/***/ }),

/***/ "./src/earth.mjs":
/*!***********************!*\
  !*** ./src/earth.mjs ***!
  \***********************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return earth; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts */ "./src/consts.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./src/math.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./agent */ "./src/agent.mjs");
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./d3 */ "./src/d3.mjs");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! topojson-client */ "./node_modules/topojson-client/index.js");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./micro */ "./src/micro.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utc */ "./src/utc.mjs");
/* harmony import */ var _globes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./globes */ "./src/globes.mjs");
/* harmony import */ var _products__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./products */ "./src/products.mjs");
/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./keyboard */ "./src/keyboard.mjs");
/* harmony import */ var _canvas_twod__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./canvas/twod */ "./src/canvas/twod.mjs");
/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lang */ "./src/lang.mjs");
/* harmony import */ var _gl_glTest__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./gl/glTest */ "./src/gl/glTest.mjs");
/* harmony import */ var _gl_fastoverlay__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./gl/fastoverlay */ "./src/gl/fastoverlay.mjs");
/* harmony import */ var _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./framework/sharedState */ "./src/framework/sharedState.mjs");
/* harmony import */ var _framework_sessionState__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./framework/sessionState */ "./src/framework/sessionState.mjs");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * earth - a project to visualize global weather data.
 *
 * Copyright (c) 2018 Cameron Beccario
 *
 * For a free version of this project, see https://github.com/cambecc/earth
 */


















function earth(app) {
  var log = app.log;
  var bridge = app.bridge;
  log.debug("start...");
  var MAX_TASK_TIME = 150; // amount of time before a task yields control (millis)

  var MIN_SLEEP_TIME = 10; // amount of time a task waits before resuming (millis)

  var MIN_MOVE = 6; // slack before a drag operation beings (pixels)

  var MOVE_END_WAIT = 750; // time to wait for a move operation to be considered done (millis)

  var INTENSITY_SCALE_STEP = 10; // step size of particle intensity color scale

  var PARTICLE_LINE_WIDTH = 1; // line width of a drawn particle

  var PARTICLE_MULTIPLIER = 7; // particle count scalar (completely arbitrary--this values looks nice)

  var PARTICLE_REDUCTION = 0.75; // reduce particle count to this much of normal for mobile devices

  var FRAME_RATE = 40; // desired milliseconds per frame

  var REMAINING = "▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫"; // glyphs for remaining progress bar

  var COMPLETED = "▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪"; // glyphs for completed progress bar

  var NULL_WIND_VECTOR = [7e37, 7e37, 7e37]; // undefined location outside the vector field [u, v, m]

  var HOLE_VECTOR = [7e37, 7e37, 0]; // signifies a hole in the vector field

  var TRANSPARENT_BLACK = [0, 0, 0, 0]; // singleton 0 rgba

  var view = _micro__WEBPACK_IMPORTED_MODULE_6__["view"]();
  /**
   * An object to display various types of messages to the user.
   */

  var report = function () {
    // Route all messages to bridge if supported.
    var s = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#status"),
        p = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#progress"),
        total = REMAINING.length;

    var showMessage = _micro__WEBPACK_IMPORTED_MODULE_6__["bindup"](bridge, "showMessage") || function (msg
    /*, isError*/
    ) {
      s.text(msg);
    };

    var showProgress = _micro__WEBPACK_IMPORTED_MODULE_6__["bindup"](bridge, "showProgress") || function (amount) {
      // amount must be int
      if (0 <= amount && amount < 100) {
        var i = Math.ceil(amount / 100 * total);
        var bar = COMPLETED.substr(0, i) + REMAINING.substr(0, total - i);
        return p.classed("invisible", false).text(bar);
      }

      return p.classed("invisible", true).text(""); // progress complete
    };

    return {
      status: function status(msg) {
        return s.classed("bad") ? s : showMessage(msg, false); // errors are sticky until reset
      },
      error: function error(err, context) {
        var msg = err.status ? "".concat(err.status, " ").concat(err.message) : err.message || err;

        switch (err.status) {
          case -1:
            msg = "Server Down";
            break;

          case 404:
            msg = "No Data";
            break;
        }

        if (context) log.error("context", context + "");
        log.error("error", err);
        if (err.stack) log.error("stack", err.stack);
        s.classed("bad", true);
        showMessage(msg, true);
      },
      reset: function reset() {
        s.classed("bad", false);
        showMessage("", false);
      },
      progress: showProgress
    };
  }();

  function newAgent(name, events) {
    return Object(_agent__WEBPACK_IMPORTED_MODULE_3__["createAgent"])({
      name: name,
      events: events
    }).on("reject.affects-report fail.affects-report", report.error);
  } // Construct the page's main internal components:


  var inputController = buildInputController(); // interprets drag/zoom operations

  var meshAgent = newAgent("mesh"); // map data for the earth

  var globeAgent = newAgent("globe"); // the model of the globe

  var gridAgent = newAgent("grid"); // the grid of weather data

  var rendererAgent = newAgent( // the globe SVG renderer
  "renderer", ["start", "render", "redraw"]); // const argoAgent = newAgent("argo");             // SVG argo maker

  var fieldAgent = newAgent("field"); // the interpolated wind vector field

  var fastoverlayAgent = newAgent("fastoverlay"); // the interpolated wind vector field

  var animatorAgent = newAgent("animator"); // the wind animator

  var overlayAgent = newAgent("overlay"); // color overlay over the animation

  var overlayGridAgent = newAgent("overlayGrid"); // grid points drawn on the overlay

  var buttonStateNotifier = newAgent("button"); // notifies consumers of button state changes

  /**
   * The input controller is an object that translates move operations (drag and/or zoom) into mutations of the
   * current globe's projection, and emits events so other page components can react to these move operations.
   *
   * D3's built-in Zoom behavior is used to bind to the document's drag/zoom events, and the input controller
   * interprets D3's events as move operations on the globe. This method is complicated due to the complex
   * event behavior that occurs during drag and zoom.
   *
   * D3 move operations usually occur as "start" -> ("zoom")* -> "end" event chain. During "zoom" events
   * the scale and mouse may change, implying a zoom or drag operation accordingly. These operations are quite
   * noisy. What should otherwise be one smooth continuous zoom is usually comprised of several "start" ->
   * "zoom" -> "end" event chains. A debouncer is used to eliminate the noise by waiting a short period of
   * time to ensure the user has finished the move operation.
   *
   * The "zoom" events may not occur; a simple click operation occurs as either "start" -> "end" or "start" ->
   * "zoom" -> "end". There is additional logic for other corner cases, such as spurious drags which move the globe
   * just a few pixels (most likely unintentional), and the tendency for some touch devices to issue events out of
   * order: "zoom" -> "start" -> "end" (though this may no longer occur with D3 v4).
   *
   * This object emits clean "moveStart" -> ("move")* -> "moveEnd" events for move/zoom operations, and "click"
   * events for everything else.
   */

  function buildInputController() {
    var dispatch = _d3__WEBPACK_IMPORTED_MODULE_4__["dispatch"]("moveStart", "move", "moveEnd", "click");

    var _globe,
        op = null,
        prevClick = {
      time: 0,
      mouse: [0, 0]
    };
    /**
     * @returns {Object} an object to represent the state for one move operation.
     */


    function newOp(startMouse, startScale) {
      return {
        type: "click",
        // initially assumed to be a click operation
        startMouse: startMouse,
        startScale: startScale,
        manipulator: _globe.manipulator(startMouse, startScale)
      };
    }

    function start() {
      op = op || newOp(_d3__WEBPACK_IMPORTED_MODULE_4__["mouse"](this), _globe.projection.scale()); // a new operation begins
    }

    function step() {
      var transform = _d3__WEBPACK_IMPORTED_MODULE_4__["event"].transform || {};
      var currentMouse = _d3__WEBPACK_IMPORTED_MODULE_4__["mouse"](this),
          currentScale = _micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](transform.k, _globe.projection.scale());
      op = op || newOp(currentMouse, 1); // Fix bug on some browsers where zoomstart fires out of order.

      if (op.type === "click") {
        var distanceMoved = Object(_math__WEBPACK_IMPORTED_MODULE_1__["distance"])(currentMouse, op.startMouse);

        if (currentScale === op.startScale && (distanceMoved < MIN_MOVE || isNaN(distanceMoved))) {
          // to reduce annoyance, ignore op if mouse has barely moved and no zoom is occurring
          return;
        }

        dispatch.call("moveStart");
        op.type = "drag";
      }

      if (currentScale !== op.startScale || isNaN(currentMouse[0])) {
        // Whenever a scale change is detected, or mouse is undefined (such as during double-click),
        // stickily switch to a zoom operation.
        op.type = "zoom";
      } // when zooming, ignore whatever the mouse is doing--really cleans up behavior on touch devices


      op.manipulator.move(op.type === "zoom" ? null : currentMouse, currentScale);
      dispatch.call("move");
    }

    function end() {
      if (op === null) return;
      op.manipulator.end();

      if (op.type === "click") {
        // Ignore clicks that occur soon after the previous click and in the same location. Reduces noise
        // on touch devices where taps trigger both touchstart and mousedown events (i.e., two clicks).
        // CONSIDER: is this still necessary after d3 v4 upgrade?
        if (Date.now() - prevClick.time > 500 || Object(_math__WEBPACK_IMPORTED_MODULE_1__["distance"])(prevClick.mouse, op.startMouse) >= MIN_MOVE) {
          dispatch.call("click", null, op.startMouse, _globe.projection.invert(op.startMouse) || []);
          prevClick = {
            time: Date.now(),
            mouse: op.startMouse
          };
        }
      } else {
        scheduleMoveEnd();
      }

      op = null; // the drag/zoom/click operation is over
    }

    var moveEnding = null;

    function scheduleMoveEnd() {
      if (moveEnding) {
        clearTimeout(moveEnding);
      }

      moveEnding = setTimeout(function () {
        moveEnding = null;

        if (!op || op.type !== "drag" && op.type !== "zoom") {
          _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
            orientation: _globe.orientation()
          }, {
            source: "moveEnd"
          });
          dispatch.call("moveEnd");
        }
      }, MOVE_END_WAIT); // wait for a bit to decide if user has stopped moving the globe
    }

    var zoom = _d3__WEBPACK_IMPORTED_MODULE_4__["zoom"]().on("start", start).on("zoom", step).on("end", end);
    var drag = _d3__WEBPACK_IMPORTED_MODULE_4__["drag"]().on("start", start).on("drag", step).on("end", end); // desktop: scroll -> zoom,   drag -> drag
    // mobile:   pinch -> zoom, scroll -> drag

    var display = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#display");

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["isFixedMode"]()) {
      display.on("click", function () {
        start.call(this);
        end.call(this);
      }); // support just clicks
    } else if (_micro__WEBPACK_IMPORTED_MODULE_6__["isEmbeddedInIFrame"]() && !_micro__WEBPACK_IMPORTED_MODULE_6__["isKioskMode"]()) {
      display.call(drag);
    } else {
      display.call(zoom).on("wheel", function () {
        return _d3__WEBPACK_IMPORTED_MODULE_4__["event"].preventDefault();
      }); // prevent scrolling even when at scale extent
    }

    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#show-location").on("click", function () {
      if (navigator.geolocation) {
        report.status("Finding current position...");
        navigator.geolocation.getCurrentPosition(function (pos) {
          report.status("");

          _locate(pos.coords.longitude, pos.coords.latitude);
        }, report.error);
      }
    });

    function reorient(delta, old) {
      var meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!_globe || meta.source === "moveEnd") {
        // reorientation occurred because the user just finished a move operation, so globe is already
        // oriented correctly.
        return;
      }

      dispatch.call("moveStart");

      _globe.orientation(_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("orientation"), view);

      zoom.transform(display, _d3__WEBPACK_IMPORTED_MODULE_4__["zoomIdentity"].scale(_globe.projection.scale()));
      dispatch.call("moveEnd");
    }

    function hotkey(operation, value) {
      if (operation === "zoom") {
        return zoom.scaleBy(display, value);
      }

      if (!moveEnding) {
        dispatch.call("moveStart");
      }

      var proj = _globe.projection,
          rotate = proj.rotate(),
          delta = value / 8;

      switch (operation) {
        case "left":
          proj.rotate([rotate[0] + delta, rotate[1]]);
          break;

        case "right":
          proj.rotate([rotate[0] - delta, rotate[1]]);
          break;

        case "up":
          proj.rotate([rotate[0], rotate[1] - delta]);
          break;

        case "down":
          proj.rotate([rotate[0], rotate[1] + delta]);
          break;
      }

      dispatch.call("move");
      scheduleMoveEnd();
    }

    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:orientation.?", reorient);
    return _micro__WEBPACK_IMPORTED_MODULE_6__["assign"](dispatch, {
      globe: function globe(x) {
        if (x) {
          _globe = x;
          zoom.scaleExtent(_globe.scaleExtent());
          reorient();
        }

        return x ? this : _globe;
      },
      cancelMove: function cancelMove() {
        // Forcefully end the current move operation, if any.
        end();
      },
      hotkey: hotkey
    });
  }

  function orient(coord) {
    var globe = globeAgent.value();

    if (globe) {
      var rotate = globe.locate(coord);

      if (rotate) {
        globe.projection.rotate(rotate);
        _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
          orientation: globe.orientation()
        }); // triggers reorientation
      }
    }
  }

  function _locate(lon, lat) {
    var λ = +lon,
        φ = +lat,
        coord = [λ, φ];

    if (λ !== λ || φ !== φ) {
      removeLocation();
      return;
    }

    saveLocation(null, coord);
    orient(coord);
  }
  /**
   * @param resource the GeoJSON resource's URL
   * @returns {Object} a promise for GeoJSON topology features: {boundaryLo:, boundaryHi:}
   */


  function buildMesh(resource) {
    var cancel = this.cancel;
    report.status("Downloading...");
    var files = [];
    files.push(_micro__WEBPACK_IMPORTED_MODULE_6__["loadJson"](resource));

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["siteInstance"]() === "tara") {
      files.push(_micro__WEBPACK_IMPORTED_MODULE_6__["loadJson"](_products__WEBPACK_IMPORTED_MODULE_9__["products"].gaia("/data/tara/tara-plan-20170829.json")));
      files.push(_micro__WEBPACK_IMPORTED_MODULE_6__["loadJson"](_products__WEBPACK_IMPORTED_MODULE_9__["products"].gaia("/data/tara/tara-track.json")));
    }

    return Promise.all(files).then(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 3),
          topo = _ref2[0],
          taraPlan = _ref2[1],
          taraTrack = _ref2[2];

      if (cancel.requested) return null;
      log.time("building meshes");
      var o = topo.objects;
      var coastLo = topojson_client__WEBPACK_IMPORTED_MODULE_5__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.coastline_tiny : o.coastline_110m);
      var coastHi = topojson_client__WEBPACK_IMPORTED_MODULE_5__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.coastline_110m : o.coastline_50m);
      var lakesLo = topojson_client__WEBPACK_IMPORTED_MODULE_5__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.lakes_tiny : o.lakes_110m);
      var lakesHi = topojson_client__WEBPACK_IMPORTED_MODULE_5__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.lakes_110m : o.lakes_50m);
      var riversLo = topojson_client__WEBPACK_IMPORTED_MODULE_5__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.rivers_tiny : o.rivers_110m);
      var riversHi = topojson_client__WEBPACK_IMPORTED_MODULE_5__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.rivers_110m : o.rivers_50m);
      log.timeEnd("building meshes");
      return {
        coastLo: coastLo,
        coastHi: coastHi,
        lakesLo: lakesLo,
        lakesHi: lakesHi,
        riversLo: riversLo,
        riversHi: riversHi,
        tara: {
          plan: taraPlan,
          track: taraTrack
        }
      };
    });
  }
  /**
   * @param {String} projectionName the desired projection's name.
   * @returns {Object} a globe object.
   */


  function buildGlobe(projectionName) {
    var builder = _globes__WEBPACK_IMPORTED_MODULE_8__[projectionName];

    if (!builder) {
      return Promise.reject("Unknown projection: " + projectionName);
    }

    return builder(view);
  } // Some hacky stuff to ensure only one download can be in progress at a time.


  var downloadsInProgress = 0;

  function buildGrids(isNewPrimaryGrid) {
    report.status("Downloading...");
    log.time("build grids");
    var cancel = this.cancel;
    downloadsInProgress++;
    var attr = Object(_micro__WEBPACK_IMPORTED_MODULE_6__["ø"])(_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].getAll(), _framework_sessionState__WEBPACK_IMPORTED_MODULE_16__["model"].getAll());
    return Promise.all(_products__WEBPACK_IMPORTED_MODULE_9__["products"].productsFor(attr)).then(function (products) {
      var loads = products.map(function (product) {
        return product.load(cancel);
      });
      return Promise.all(loads).then(function (products) {
        return {
          primaryGrid: products[0],
          overlayGrid: products[1] || products[0],
          isNewPrimaryGrid: !!isNewPrimaryGrid
        };
      }).catch(function (err) {
        report.error(err);
        return {
          primaryGrid: products[1] || products[0],
          overlayGrid: products[1] || products[0],
          isNewPrimaryGrid: !!isNewPrimaryGrid
        };
      });
    }).finally(function () {
      downloadsInProgress--;
      log.timeEnd("build grids");
    });
  }
  /**
   * Modifies the configuration to navigate to the chronologically next or previous data layer.
   */


  function navigate(step) {
    if (downloadsInProgress > 0) {
      log.debug("Download in progress--ignoring nav request.");
      return;
    }

    var next = gridAgent.value().overlayGrid.navigate(step);

    if (next) {
      _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save(_micro__WEBPACK_IMPORTED_MODULE_6__["dateToConfig"](next));
    }
  }

  function constructTaraElements(svg, tara, orientation) {
    var g = svg.append("g");
    var plan = {
      type: "LineString",
      coordinates: tara.plan.coordinates.filter(function (e, i) {
        return i > 253;
      })
    }; //g.append("path").attr("class", "tara-route tara-plan-border").datum(plan);

    g.append("path").attr("class", "tara-route tara-plan").datum(plan);
    var points = tara.track.geometries;
    points = points.filter(function (e, i) {
      return i > points.length - 10 || i % 3 === 0;
    });
    var wholeTrack = {
      type: "LineString",
      coordinates: underscore__WEBPACK_IMPORTED_MODULE_2__.map(points, underscore__WEBPACK_IMPORTED_MODULE_2__.property("coordinates"))
    };
    var firstHalf = {
      type: "LineString",
      coordinates: wholeTrack.coordinates.slice(0, 3400)
    };
    var secondHalf = {
      type: "LineString",
      coordinates: wholeTrack.coordinates.slice(3400)
    };
    g.append("path").attr("class", "tara-route tara-track-border").datum(wholeTrack);
    g.append("path").attr("class", "tara-route tara-track-old").datum(firstHalf);
    g.append("path").attr("class", "tara-route tara-track").datum(secondHalf);
    var taraLoc = {
      type: "Point",
      coordinates: underscore__WEBPACK_IMPORTED_MODULE_2__.last(wholeTrack.coordinates),
      size: 4
    };

    if (orientation === "" || orientation.substr(0, 2) === ",,") {
      orient(taraLoc.coordinates);
    }

    g.append("path").attr("class", "tara-loc").datum(taraLoc);

    var last = underscore__WEBPACK_IMPORTED_MODULE_2__.last(points);

    var data = {
      date: last["date"],
      heading: +_micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](last["heading"], NaN),
      speed: +_micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](last["speed"], NaN) * 3.6,
      air_temp: +_micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](last["air_temp"], NaN),
      water_temp: +_micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](last["water_temp"], NaN),
      pressure: +_micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](last["pressure"], NaN)
    };
    var fields = {
      date: _utc__WEBPACK_IMPORTED_MODULE_7__["print"](_utc__WEBPACK_IMPORTED_MODULE_7__["localParts"](data.date), "{yyyy}-{MM}-{dd} {hh}:{mm}"),
      heading: isNaN(data.heading) ? "N/A" : data.heading.toFixed(0),
      speed: isNaN(data.speed) ? "N/A" : data.speed.toFixed(1),
      air_temp: isNaN(data.air_temp) ? "N/A" : data.air_temp.toFixed(1),
      water_temp: isNaN(data.water_temp) ? "N/A" : data.water_temp.toFixed(1),
      pressure: isNaN(data.pressure) ? "N/A" : data.pressure.toFixed(0)
    };
    var div = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#tara-stats");
    div.selectAll("*").remove();
    div.append("p").text("Tara stats:");
    div.append("p").classed("stat", true).text(fields.heading + "° @ " + fields.speed + " km/h");
    div.append("p").classed("stat", true).text(fields.air_temp + " °C (air)");
    div.append("p").classed("stat", true).text(fields.water_temp + " °C (water)");
    div.append("p").classed("stat", true).text(fields.pressure + " hPa");
    div.append("p").text(fields.date);
    div.selectAll(".stat").attr("style", "padding-left: 1em");
    div.classed("invisible", false);
  }

  function buildRenderer(mesh, globe) {
    if (!mesh || !globe) return null;
    report.status("Rendering Globe...");
    log.time("rendering map");
    var mapCtx = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#map").node().getContext("2d");
    var foregroundCtx = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#foreground").node().getContext("2d");
    var annotationSvg = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#annotation");
    var orientation = _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("orientation"); // First clear annotation svg contents.

    _micro__WEBPACK_IMPORTED_MODULE_6__["removeChildren"](annotationSvg.node());
    globe.orientation(orientation, view); // This allows the path function to work.

    var path = _d3__WEBPACK_IMPORTED_MODULE_4__["geoPath"]().projection(globe.projection).pointRadius(function (d) {
      return d.size || 7;
    });

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["siteInstance"]() === "tara") {
      constructTaraElements(annotationSvg, mesh.tara, orientation);
    } // Draw the location mark if one is currently visible.


    updateLocation(); // Throttled draw method helps with slow devices that would get overwhelmed by too many redraw events.

    var REDRAW_WAIT = 5; // milliseconds

    var doDraw_throttled = underscore__WEBPACK_IMPORTED_MODULE_2__.throttle(doDraw, REDRAW_WAIT, {
      leading: false
    });

    var LINE_WIDTH = 1.25;
    var background = globe.backgroundRenderer();
    var graticule = globe.graticuleRenderer();
    var coastLo = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.coastLo, {
      strokeStyle: "#ffffff",
      lineWidth: LINE_WIDTH
    });
    var lakesLo = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.lakesLo, {
      strokeStyle: "#ffffff",
      lineWidth: LINE_WIDTH
    });
    var riversLo = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.riversLo, {
      strokeStyle: "#808080",
      lineWidth: LINE_WIDTH
    });
    var coastHi = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.coastHi, {
      strokeStyle: "#ffffff",
      lineWidth: LINE_WIDTH
    });
    var lakesHi = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.lakesHi, {
      strokeStyle: "#ffffff",
      lineWidth: LINE_WIDTH
    });
    var riversHi = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.riversHi, {
      strokeStyle: "#808080",
      lineWidth: LINE_WIDTH
    });
    var mapRendererLo = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeLayerRenderer"]([background, graticule, coastLo, lakesLo, riversLo]);
    var mapRendererHi = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeLayerRenderer"]([background, graticule, coastHi, lakesHi, riversHi]);
    var foregroundRenderer = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeLayerRenderer"]([globe.foregroundRenderer()]);

    function canvasDraw(isHD) {
      var mapRenderer = isHD ? mapRendererHi : mapRendererLo;
      mapRenderer.renderTo(mapCtx, path);
      foregroundRenderer.renderTo(foregroundCtx, path);
      path.context(null);
    }

    function doDraw() {
      annotationSvg.selectAll("path").attr("d", path);
      canvasDraw(false);
      rendererAgent.call("redraw");
      doDraw_throttled = underscore__WEBPACK_IMPORTED_MODULE_2__.throttle(doDraw, REDRAW_WAIT, {
        leading: false
      });
    } // Attach to map rendering events on input controller.


    inputController.on("moveStart.renderer", function () {
      rendererAgent.call("start");
    });
    inputController.on("move.renderer", function () {
      doDraw_throttled();
    });
    inputController.on("moveEnd.renderer", function () {
      annotationSvg.selectAll("path").attr("d", path);
      canvasDraw(true);
      rendererAgent.call("render");
    }); // Finally, inject the globe model into the input controller. Do it on the next event turn to ensure
    // renderer is fully set up before events start flowing.

    Promise.resolve().then(function () {
      inputController.globe(globe);
    }).catch(report.error);
    log.timeEnd("rendering map");
    return "ready";
  }

  function addArgo() {
    var globe = globeAgent.value();
    if (!globe) return null;
    var svg = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#annotation");
    var type = _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("argoFloat");

    if (svg.selectAll(".argo-" + type).size() > 0) {
      return null;
    }

    var cancel = this.cancel;
    var files = [_micro__WEBPACK_IMPORTED_MODULE_6__["loadJson"](_products__WEBPACK_IMPORTED_MODULE_9__["products"].argoUrl("argo.floats.json"))];
    return Promise.all(files).then(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 1),
          argo = _ref4[0];

      if (cancel.requested) return null;
      log.time("building argo");
      var svg = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#annotation");
      svg.selectAll(".argo").remove();
      var validTypes = ["recent", "operational", "planned", "dead"];

      if (underscore__WEBPACK_IMPORTED_MODULE_2__.indexOf(validTypes, type) >= 0) {
        var path = _d3__WEBPACK_IMPORTED_MODULE_4__["geoPath"]().projection(globe.projection).pointRadius(3);
        svg.append("path").classed("argo argo-" + type, true).datum({
          type: "MultiPoint",
          coordinates: argo[type],
          size: 3
        }).attr("d", path);
      }

      log.timeEnd("building argo");
    });
  }

  function copyTypedArray(target, source) {
    // Some browsers do not support TypedArray.prototype.set, like Android.
    if (underscore__WEBPACK_IMPORTED_MODULE_2__.isFunction(target.set)) {
      target.set(source);
    } else {
      for (var i = 0; i < source.length; i++) {
        target[i] = source[i];
      }
    }
  }

  function createMask(globe) {
    if (!globe) return null;
    log.time("render mask"); // Create a detached canvas, ask the model to define the mask polygon, then fill with an opaque color.

    var width = view.width,
        height = view.height;
    var canvas = _d3__WEBPACK_IMPORTED_MODULE_4__["select"](document.createElement("canvas")).attr("width", width).attr("height", height).node();
    var context = globe.defineMask(canvas.getContext("2d"));
    context.fillStyle = "rgba(255, 0, 0, 1)";
    context.fill(); // d3.select("#display").node().appendChild(canvas);  // make mask visible for debugging
    // Grab a _copy_ of the ImageData. Works around a Chrome bug where holding onto the result of getImageData
    // sometimes results in a blank screen, presumably because the associated detached canvas is garbage collected.

    var imageData = context.createImageData(width, height),
        data = imageData.data; // layout: [r, g, b, a, ...]

    copyTypedArray(data, context.getImageData(0, 0, width, height).data); //const imageData = context.getImageData(0, 0, width, height), data = imageData.data;  // layout: [r, g, b, a, ...]

    log.timeEnd("render mask");
    return {
      imageData: imageData,
      isVisible: function isVisible(x, y) {
        var i = (y * width + x) * 4;
        return data[i + 3] > 0; // non-zero alpha means pixel is visible
      },
      set: function set(x, y, rgba) {
        var i = (y * width + x) * 4;
        data[i] = rgba[0];
        data[i + 1] = rgba[1];
        data[i + 2] = rgba[2];
        data[i + 3] = rgba[3];
        return this;
      }
    };
  }

  function createField(rows, mask, bounds) {
    var xMin = bounds.x;
    var field = {};
    /**
     * Copies the array [x, y, dx, dy, m] into Array 'a' starting at index i. If x or y is out of bounds,
     * then sets the dx, dy, and m values to 7e37.
     *
     * @param x {Number}
     * @param y {Number}
     * @param a {Float32Array}
     * @param i {Number}
     */

    field.move = function (x, y, a, i) {
      var k = Math.round(y);

      if (0 <= k && k < rows.length) {
        var row = rows[k];
        var j = (Math.round(x) - xMin) * 3;

        if (row && 0 <= j && j < row.length) {
          a[i] = x;
          a[i + 1] = y;
          a[i + 2] = row[j]; // dx

          a[i + 3] = row[j + 1]; // dy

          a[i + 4] = row[j + 2]; // m

          return;
        }
      }

      a[i] = x;
      a[i + 1] = y;
      a[i + 2] = 7e37;
      a[i + 3] = 7e37;
      a[i + 4] = 7e37;
    };
    /**
     * @returns {boolean} true if the field is valid at the point (x, y)
     */


    field.isDefined = function (x, y) {
      var k = Math.round(y);

      if (0 <= k && k < rows.length) {
        var row = rows[k];
        var j = (Math.round(x) - xMin) * 3;

        if (row && 0 <= j && j < row.length) {
          return row[j] < 7e37;
        }
      }

      return false;
    };
    /**
     * @returns {boolean} true if the point (x, y) lies inside the outer boundary of the vector field, even if
     *          the vector field has a hole (is undefined) at that point, such as at an island in a field of
     *          ocean currents.
     */


    field.isInsideBoundary = function (x, y) {
      var a = new Float32Array(5); // [x, y, dx, dy, m]

      field.move(x, y, a, 0);
      return a[4] < 7e37; // true if magnitude is defined or is HOLE_VECTOR
    };

    field.overlay = mask.imageData;
    return field;
  }
  /**
   * Calculate distortion of the wind vector caused by the shape of the projection at point (x, y). The wind
   * vector is modified in place and returned by this function.
   */


  function distort(projection, λ, φ, x, y, velocityScale, wind) {
    var u = wind[0] * velocityScale;
    var v = wind[1] * velocityScale;
    var d = _micro__WEBPACK_IMPORTED_MODULE_6__["distortion"](projection, λ, φ, x, y); // Scale distortion vectors by u and v, then add.

    wind[0] = d[0] * u + d[2] * v;
    wind[1] = d[1] * u + d[3] * v;
    return wind;
  }

  var failureReported = false;

  function interpolateField(globe, grids) {
    if (!globe || !grids || !rendererAgent.value()) return null;
    var fastoverlay = fastoverlayAgent.value();
    var fastoverlayResult = fastoverlay !== undefined && fastoverlay.draw() || {
      pass: false
    };
    var useFastOverlay = fastoverlayResult.pass;

    if (fastoverlayResult.err && !failureReported) {
      failureReported = true;
      var msg = JSON.stringify(fastoverlayResult);
      log.debug("fastoverlay failure: ".concat(msg));
      window.ga("send", "event", "gl", msg);
    }

    var mask = createMask(globe);
    var primaryGrid = grids.primaryGrid;
    var overlayGrid = grids.overlayGrid;
    var hasDistinctOverlay = primaryGrid !== overlayGrid; // nothing to do if products failed to load and have no data

    if (!primaryGrid.field || !overlayGrid.field) return null; // TIME-LAPSE
    // if (!primaryGrid.particles) {
    //     report.status("");
    //     return;
    // }

    var interpolationType = "bilinear";
    var primaryField = primaryGrid.field();
    var overlayField = overlayGrid.field();
    var interpolate = primaryField[interpolationType];
    var overlayInterpolate = overlayField[interpolationType];
    log.time("interpolating field");
    var cancel = this.cancel;
    var projection = globe.optimizedProjection();
    var invert = projection.invert.bind(projection);
    var bounds = globe.bounds(view); // How fast particles move on the screen (arbitrary value chosen for aesthetics).

    var velocityScale = primaryGrid.particles.velocityScale;
    var rows = [];
    var point = [];
    var y = bounds.y;
    var colorScale = overlayGrid.scale;
    var hd = _framework_sessionState__WEBPACK_IMPORTED_MODULE_16__["model"].get("hd"),
        step = hd ? 1 : 2;

    function interpolateRow(y) {
      var lastRow = y === bounds.yMax;
      var row = new Float32Array(bounds.width * 3); // [u0, v0, m0, u1, v1, m1, ...]

      for (var x = bounds.x, i = 0; x <= bounds.xMax; x += step, i += step * 3) {
        var lastColumn = x === bounds.xMax;
        var wind = NULL_WIND_VECTOR;

        if (mask.isVisible(x, y)) {
          point[0] = x, point[1] = y;
          var coord = invert(point);
          var color = TRANSPARENT_BLACK;

          if (coord) {
            var λ = coord[0],
                φ = coord[1];

            if (λ === λ) {
              wind = interpolate(coord);
              var scalar = wind[2];

              if (scalar < 7e37) {
                wind = distort(projection, λ, φ, x, y, velocityScale, wind);
                scalar = wind[2];
              } else {
                wind = HOLE_VECTOR;
              }

              if (!useFastOverlay) {
                if (hasDistinctOverlay || primaryField.type === "scalar") {
                  scalar = _micro__WEBPACK_IMPORTED_MODULE_6__["scalarize"](overlayInterpolate(coord));
                }

                if (scalar < 7e37) {
                  color = colorScale.rgba(scalar);
                  color[3] = overlayGrid.alpha.animated;
                }
              }
            }
          }

          mask.set(x, y, color);

          if (!hd) {
            if (!lastColumn) {
              mask.set(x + 1, y, color);

              if (!lastRow) {
                mask.set(x + 1, y + 1, color);
              }
            }

            if (!lastRow) {
              mask.set(x, y + 1, color);
            }
          }
        }

        row[i] = wind[0];
        row[i + 1] = wind[1];
        row[i + 2] = wind[2];

        if (!hd && !lastColumn) {
          row[i + 3] = wind[0];
          row[i + 4] = wind[1];
          row[i + 5] = wind[2];
        }
      }

      rows[y] = row;

      if (!hd) {
        rows[y + 1] = row;
      }
    }

    report.status("");
    report.progress(0); // signal that we are starting interpolation

    return new Promise(function (resolve, reject) {
      (function batchInterpolate() {
        try {
          if (!cancel.requested) {
            var _start = Date.now();

            while (y <= bounds.yMax) {
              interpolateRow(y);
              y += step;

              if (Date.now() - _start > MAX_TASK_TIME) {
                // Interpolation is taking too long. Schedule the next batch for later and yield.
                report.progress(Math.round((y - bounds.y) / (bounds.yMax - bounds.y) * 100));
                setTimeout(batchInterpolate, MIN_SLEEP_TIME);
                return;
              }
            }
          }

          resolve(createField(rows, mask, bounds));
        } catch (e) {
          reject(e);
        }

        report.progress(100); // 100% complete

        log.timeEnd("interpolating field");
      })();
    });
  }

  function animate(globe, grids) {
    if (!globe || !fieldAgent.value() || !grids || !_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("animate")) return false;

    if (grids.isNewPrimaryGrid) {
      _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["clearCanvas"](_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#animation").node()); // clear animation artifacts
    }

    var cancel = this.cancel;
    var bounds = globe.bounds(view); // maxIntensity is the velocity at which particle color intensity is maximum

    var colorStyles = _micro__WEBPACK_IMPORTED_MODULE_6__["windIntensityColorScale"](INTENSITY_SCALE_STEP, grids.primaryGrid.particles.maxIntensity);
    var particleCount = Math.round(bounds.width * PARTICLE_MULTIPLIER);

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]()) {
      particleCount = Math.floor(particleCount * PARTICLE_REDUCTION);
    }

    log.debug("particle count: %s", particleCount);
    var particles = new Float32Array(particleCount * 5);
    var ages = new Int32Array(particleCount);
    var batches = colorStyles.map(function () {
      return new Float32Array(particleCount * 4);
    });
    var sizes = new Int32Array(batches.length);
    var xMin = bounds.x,
        yMin = bounds.y,
        width = bounds.width,
        height = bounds.height;
    var scale = globe.projection.scale();

    function randomize(i, field) {
      var x = xMin + Math.random() * width;
      var y = yMin + Math.random() * height;
      field.move(x, y, particles, i);
    }

    function randomizeWell(i, field) {
      // This function is hrm, but avoids "pulsing"
      for (var attempts = 0; attempts < 10; attempts++) {
        randomize(i, field);
        if (particles[i + 2] < 7e37) return;
      }
    }

    var maxAge, evolve;
    var g = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#animation").node().getContext("2d");

    if (grids.primaryGrid.particles.waves) {
      maxAge = 40;
      evolve = evolveWaves;
      g.fillStyle = "rgba(0, 0, 0, 0.90)";
    } else {
      maxAge = 100;
      evolve = evolveParticles;
      g.fillStyle = _micro__WEBPACK_IMPORTED_MODULE_6__["isFF"]() ? "rgba(0, 0, 0, 0.95)" : "rgba(0, 0, 0, 0.97)"; // FF Mac alpha behaves oddly
    }

    g.lineWidth = PARTICLE_LINE_WIDTH;

    for (var i = 0, j = 0; i < particleCount; i += 1, j += 5) {
      ages[i] = underscore__WEBPACK_IMPORTED_MODULE_2__.random(0, maxAge);
      randomizeWell(j, fieldAgent.value());
    }

    var easeFactor = new Float32Array(maxAge);

    for (var k = 0; k < easeFactor.length; k++) {
      easeFactor[k] = Math.sin(-_consts__WEBPACK_IMPORTED_MODULE_0__["π"] / 2 + k / 7) / 2 + 1 / 2; // fade in/out line intensity
    }

    function evolveWaves() {
      var field = fieldAgent.value();
      var adj = 600 / scale * Math.pow(Math.log(scale) / Math.log(600), 2.5); // use shallower exponential speed scale

      for (var s = 0; s < sizes.length; s++) {
        sizes[s] = 0;
      }

      for (var _i2 = 0, _j = 0; _i2 < particleCount; _i2 += 1, _j += 5) {
        if (++ages[_i2] >= maxAge) {
          ages[_i2] = 0;
          randomize(_j, field);
        }

        var x0 = particles[_j];
        var y0 = particles[_j + 1];
        var dx = particles[_j + 2];
        var dy = particles[_j + 3];
        var x1 = x0 + dx * adj;
        var y1 = y0 + dy * adj;
        var m = particles[_j + 4];

        if (m !== m || !field.isDefined(x1, y1)) {
          ages[_i2] = maxAge; // particle has escaped the game grid
        } else {
          particles[_j] = x1;
          particles[_j + 1] = y1; // width of wave

          var mag = Math.sqrt(dx * dx + dy * dy) / 2.5; // CONSIDER: would be nice to retain unscaled m...

          dx /= mag;
          dy /= mag; // Path from (x,y) to (xt,yt) is visible, so add this particle to the appropriate draw bucket.

          var si = colorStyles.indexFor(m * easeFactor[ages[_i2]]);
          var sj = 4 * sizes[si]++;
          var batch = batches[si];
          batch[sj] = x0 - dy;
          batch[sj + 1] = y0 + dx;
          batch[sj + 2] = x0 + dy;
          batch[sj + 3] = y0 - dx;
        }
      }
    }

    function evolveParticles() {
      var field = fieldAgent.value();

      for (var s = 0; s < sizes.length; s++) {
        sizes[s] = 0;
      }

      for (var _i3 = 0, _j2 = 0; _i3 < particleCount; _i3 += 1, _j2 += 5) {
        if (++ages[_i3] >= maxAge) {
          ages[_i3] = 0;
          randomize(_j2, field);
        }

        var x0 = particles[_j2]; // x

        var y0 = particles[_j2 + 1]; // y

        var x1 = x0 + particles[_j2 + 2]; // dx

        var y1 = y0 + particles[_j2 + 3]; // dy

        var m = particles[_j2 + 4]; // m

        if (x1 < 7e37) {
          field.move(x1, y1, particles, _j2);
          var dx = particles[_j2 + 2];

          if (dx < 7e37) {
            // Path from (x0,y0) to (x1,y1) is visible, so add this particle to the appropriate draw bucket.
            var si = colorStyles.indexFor(m);
            var sj = 4 * sizes[si]++;
            var batch = batches[si];
            batch[sj] = x0;
            batch[sj + 1] = y0;
            batch[sj + 2] = x1;
            batch[sj + 3] = y1;
          } else {
            ages[_i3] = maxAge; // particle has escaped the game grid
          }
        } else {
          ages[_i3] = maxAge; // particle has escaped the game grid
        }
      }
    }

    function draw() {
      // Fade existing trails.
      g.globalCompositeOperation = "destination-in";
      g.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
      g.globalCompositeOperation = "source-over"; // Draw new trails.

      for (var _i4 = 0; _i4 < batches.length; _i4++) {
        var batch = batches[_i4];
        var size = 4 * sizes[_i4];

        if (size > 0) {
          g.beginPath();
          g.strokeStyle = colorStyles[_i4];

          for (var _j3 = 0; _j3 < size; _j3 += 4) {
            g.moveTo(batch[_j3], batch[_j3 + 1]);
            g.lineTo(batch[_j3 + 2], batch[_j3 + 3]);
          }

          g.stroke();
        }
      }
    }

    function frame() {
      if (cancel.requested) {
        return false;
      }

      evolve();
      draw();
      setTimeout(frame, FRAME_RATE);
      return true;
    }

    frame();
    return {
      frame: frame
    };
  }

  function drawGridPoints(ctx, layer, globe) {
    if (!layer || !globe || !_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("showGridPoints")) return;
    ctx.fillStyle = "rgba(255, 255, 255, 0.75)";
    var width = view.width,
        height = view.height;
    var stream = globe.projection.stream({
      point: function point(x, y) {
        if (0 <= x && x < width && 0 <= y && y < height) {
          // fillRect is processed at the end of the event turn, but it alpha blends, as opposed to setting
          // the pixel directly.
          ctx.fillRect(Math.round(x), Math.round(y), 1, 1);
        }
      }
    });
    var cancel = this.cancel;
    var grid = layer.grid(),
        field = layer.field(),
        valueAt = field.valueAt;
    var i = 0; // Draw grid points in batches.

    (function work() {
      if (!cancel.requested) {
        var end = Date.now() + MAX_TASK_TIME / 4;
        i = grid.forEach(function (λ, φ, i) {
          var v = _micro__WEBPACK_IMPORTED_MODULE_6__["scalarize"](valueAt(i));

          if (v < 7e37) {
            λ = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floorMod"])(180 + λ, 360) - 180; // some projections don't clamp to [-180, 180)

            stream.point(λ, φ);
          }

          return Date.now() > end;
        }, i);

        if (i === i) {
          setTimeout(work, MIN_SLEEP_TIME);
        }
      }
    })();
  }

  function brighten(data, alpha) {
    for (var i = 3; i < data.length; i += 4) {
      if (data[i] !== 0) {
        data[i] = alpha;
      }
    }
  }

  function drawOverlay(field, overlayType, animate) {
    if (!field || !rendererAgent.value()) return;
    var ctx = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#overlay").node().getContext("2d"),
        grid = (gridAgent.value() || {}).overlayGrid;
    _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["clearContext"](ctx);
    _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["clearCanvas"](_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#scale").node());

    if (overlayType) {
      if (overlayType !== "off") {
        if (!animate) {
          // No animation, so brighten the overlay.
          brighten(field.overlay.data, grid.alpha.single);
        }

        ctx.putImageData(field.overlay, 0, 0);
      }

      overlayGridAgent.submit(drawGridPoints, ctx, grid, globeAgent.value());
    }

    if (grid) {
      var colorBar = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#scale"),
          c = colorBar.node(),
          g = c.getContext("2d"),
          barMax = c.width - 1;
      var colorScale = grid.scale,
          colors = colorScale.colors,
          colorMax = colors.length / 4 - 1;

      for (var i = 0; i < c.width; i++) {
        var j = Math.round(i / barMax * colorMax) * 4;
        g.fillStyle = "rgb(".concat(colors[j], ",").concat(colors[j + 1], ",").concat(colors[j + 2], ")");
        g.fillRect(i, 0, 1, c.height);
      } // Show tooltip on hover.


      colorBar.on("mousemove", function () {
        var x = Math.floor(_d3__WEBPACK_IMPORTED_MODULE_4__["mouse"](this)[0]);

        if (x < 0 || barMax < x) {
          return colorBar.attr("title", null);
        }

        var i = Math.round(x / barMax * colorMax);
        var value = colorScale.valueFor(i);
        var elementId = grid.type === "wind" ? "#location-wind-units" : "#location-value-units";
        var units = createUnitToggle(elementId, grid).value();
        colorBar.attr("title", _micro__WEBPACK_IMPORTED_MODULE_6__["formatScalar"](value, units) + " " + (units.tooltip || units.label));
      });
    }
  }
  /**
   * Get the grid date.
   */


  function validityDate(grids) {
    if (grids) {
      return grids.overlayGrid.date(); // Use grid date if we have it.
    } // Otherwise use date as described by the shared config.


    var date = _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("date");
    return date === "current" ? null : underscore__WEBPACK_IMPORTED_MODULE_2__.clone(date);
  }
  /**
   * Display the grid's validity date in the menu. Allow toggling between local and UTC time.
   */


  function showDate(grids) {
    var date = validityDate(grids),
        isLocal = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#data-date").classed("local");
    var formatted = "";

    if (date) {
      formatted = _utc__WEBPACK_IMPORTED_MODULE_7__["print"]((isLocal ? _utc__WEBPACK_IMPORTED_MODULE_7__["localParts"] : _utc__WEBPACK_IMPORTED_MODULE_7__["parts"])(_utc__WEBPACK_IMPORTED_MODULE_7__["date"](date)), "{yyyy}-{MM}-{dd} {hh}:{mm}");
    }

    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#data-date").text(formatted + " " + (isLocal ? "Local" : "UTC"));
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#toggle-zone").text("⇄ " + (isLocal ? "UTC" : "Local")); // TIME-LAPSE
    // const div = d3.select("#tara-stats");
    // div.classed("invisible", false).selectAll("*").remove();
    // div.append("p").text(utc.print(date, "{yyyy}-{MM}-{dd} {hh}:{mm}Z"));

    return date;
  }
  /**
   * Display the grids' types in the menu.
   */


  function showGridDetails(grids) {
    var date = showDate(grids);
    var descriptionHTML = "",
        sourceHTML = "";

    if (grids) {
      var langCode = _micro__WEBPACK_IMPORTED_MODULE_6__["siteLangCode"]();
      var pd = grids.primaryGrid.descriptionHTML(langCode),
          od = grids.overlayGrid.descriptionHTML(langCode);
      descriptionHTML = od.name + od.qualifier;

      if (grids.primaryGrid !== grids.overlayGrid) {
        // Combine both grid descriptions together with a " + " if their qualifiers are the same.
        descriptionHTML = (pd.qualifier === od.qualifier ? pd.name : pd.name + pd.qualifier) + " + " + descriptionHTML;
      }

      sourceHTML = grids.overlayGrid.sourceHTML || "";
    }

    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#data-layer").html(descriptionHTML);
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#data-center").html(sourceHTML);

    if (bridge.productChange) {
      bridge.productChange(_utc__WEBPACK_IMPORTED_MODULE_7__["date"](date).getTime(), descriptionHTML, sourceHTML);
    }
  }
  /**
   * Constructs a toggler for the specified product's units, storing the toggle state on the element having
   * the specified id. For example, given a product having units ["m/s", "mph"], the object returned by this
   * method sets the element's "data-index" attribute to 0 for m/s and 1 for mph. Calling value() returns the
   * currently active units object. Calling next() increments the index.
   */


  function createUnitToggle(id, product) {
    var units = product.units,
        type = product.type,
        size = units.length;

    function currentState() {
      return JSON.parse(_d3__WEBPACK_IMPORTED_MODULE_4__["select"](id).attr("data-index") || "{}");
    }

    function currentIndex(state) {
      return +state[type] || 0;
    }

    return {
      value: function value() {
        return units[currentIndex(currentState())];
      },
      next: function next() {
        var state = currentState();
        state[type] = (currentIndex(state) + 1) % size;
        _d3__WEBPACK_IMPORTED_MODULE_4__["select"](id).attr("data-index", JSON.stringify(state));
      }
    };
  }
  /**
   * Display the specified vector value. Allow toggling between the different types of wind units.
   */


  function showVectorAtLocation(wind, product) {
    var unitToggle = createUnitToggle("#location-wind-units", product),
        units = unitToggle.value();
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#location-wind").text(_micro__WEBPACK_IMPORTED_MODULE_6__["formatVector"](wind, units));
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#location-wind-units").html(units.label).on("click", function () {
      unitToggle.next();
      showVectorAtLocation(wind, product);
    });
  }
  /**
   * Display the specified overlay value. Allow toggling between the different types of supported units.
   */


  function showOverlayValueAtLocation(value, product) {
    var unitToggle = createUnitToggle("#location-value-units", product),
        units = unitToggle.value();
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#location-value").text(_micro__WEBPACK_IMPORTED_MODULE_6__["formatScalar"](value, units));
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#location-value-units").html(units.label).on("click", function () {
      unitToggle.next();
      showOverlayValueAtLocation(value, product);
    });
  }
  /**
   * Display a local data callout at the coordinates specified by the hash fragment "loc=lon,lat". The location may
   * not be valid, in which case no callout is displayed. Display location data for both the primary grid and overlay
   * grid, performing interpolation when necessary.
   */


  function updateLocation() {
    _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".location").text("");
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#location-close").classed("invisible", true);
    var coord = _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("loc") || [],
        λ = +coord[0],
        φ = +coord[1];

    if (λ !== λ || φ !== φ) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"](".location-mark").remove();

      if (bridge.showLocationDetails) {
        bridge.showLocationDetails("", "{}");
      }

      return;
    }

    var grids = gridAgent.value(),
        field = fieldAgent.value(),
        globe = globeAgent.value();
    if (!grids || !field || !globe) return;
    var primary = grids.primaryGrid,
        overlay = grids.overlayGrid,
        units = {};
    var coordString = _micro__WEBPACK_IMPORTED_MODULE_6__["formatCoordinates"](λ, φ); // Show coordinates.

    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#location-coord").text(coordString);
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#location-close").classed("invisible", false);

    function showVector(vector, layer) {
      if (vector[0] < 7e37) {
        showVectorAtLocation(vector, layer);
        units[layer.type] = underscore__WEBPACK_IMPORTED_MODULE_2__.object(layer.units.map(function (unit) {
          return [unit.label, _micro__WEBPACK_IMPORTED_MODULE_6__["formatVector"](vector, unit)];
        }));
      }
    }

    function showScalar(scalar, layer) {
      if (scalar < 7e37) {
        showOverlayValueAtLocation(scalar, layer);
        units[layer.type] = underscore__WEBPACK_IMPORTED_MODULE_2__.object(layer.units.map(function (unit) {
          return [unit.label, _micro__WEBPACK_IMPORTED_MODULE_6__["formatScalar"](scalar, unit)];
        }));
      }
    } // Show primary grid value.


    var primaryValue = primary.interpolate([λ, φ]);

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["isArrayLike"](primaryValue)) {
      showVector(primaryValue, primary);
    } else {
      showScalar(primaryValue, primary);
    } // Show overlay grid value.


    var overlayValue = overlay !== primary ? _micro__WEBPACK_IMPORTED_MODULE_6__["scalarize"](overlay.interpolate([λ, φ])) : 7e37;
    showScalar(overlayValue, overlay); // Draw location mark.

    var path = _d3__WEBPACK_IMPORTED_MODULE_4__["geoPath"]().projection(globe.projection).pointRadius(7);
    var mark = _d3__WEBPACK_IMPORTED_MODULE_4__["select"](".location-mark");

    if (!mark.node()) {
      mark = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#annotation").append("path").attr("class", "location-mark");
    }

    mark.datum({
      type: "Point",
      coordinates: [λ, φ]
    }).attr("d", path);

    if (bridge.showLocationDetails) {
      bridge.showLocationDetails(coordString, JSON.stringify(units));
    }
  }

  function saveLocation(point, coord) {
    var λ = +coord[0],
        φ = +coord[1],
        field = fieldAgent.value();

    if (point && field && !field.isInsideBoundary(point[0], point[1])) {
      return;
    }

    if (λ === λ && φ === φ) {
      _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
        loc: [λ, φ]
      });
    }
  }

  function removeLocation() {
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
      loc: null
    });
  }

  function stopCurrentAnimation(alsoClearCanvas) {
    if (animatorAgent.value()) {
      animatorAgent.submit(false);
    }

    if (alsoClearCanvas) {
      _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["clearCanvas"](_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#animation").node());
    }
  }

  function highlightWhen(elementId, highlightAttrList) {
    // CONSIDER: the reasons requiring highlightAttrList need to be rethought...
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change.?", function () {
      var attr = _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].getAll();
      var highlighted = false;
      highlightAttrList.forEach(function (expectedAttr) {
        highlighted |= underscore__WEBPACK_IMPORTED_MODULE_2__.isEqual(underscore__WEBPACK_IMPORTED_MODULE_2__.pick(attr, Object.keys(expectedAttr)), expectedAttr);
      });
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"](elementId).classed("highlighted", highlighted);
    });
  }
  /**
   * Registers a click event handler for the specified DOM element which modifies the configuration to have
   * the attributes represented by newAttr. An event listener is also registered for configuration change events,
   * so when a change occurs the button becomes highlighted (i.e., class ".highlighted" is assigned or removed) if
   * the configuration matches the attributes for this button. The set of attributes used for the matching is taken
   * from newAttr, unless a custom set of key+values is provided.
   */


  function bindButtonToConfiguration(elementId, newAttr, highlightAttrList) {
    highlightAttrList = highlightAttrList || [newAttr];
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"](elementId).on("click", function () {
      if (_d3__WEBPACK_IMPORTED_MODULE_4__["select"](elementId).classed("disabled")) return;
      _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save(newAttr);
    });
    highlightWhen(elementId, highlightAttrList);
  }

  function reportSponsorClick(type) {
    if (underscore__WEBPACK_IMPORTED_MODULE_2__.isFunction(window.ga)) {
      window.ga("send", "event", "sponsor", type);
    }
  }

  function fillScreen() {
    var ratio = window["devicePixelRatio"] || 1;
    _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".fill-screen").attr("width", view.width).attr("height", view.height);
    _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".max-screen").style("width", "".concat(view.width, "px")).style("height", "".concat(view.height, "px")).attr("width", view.width * ratio).attr("height", view.height * ratio).each(function () {
      this.getContext("2d").scale(ratio, ratio);
    });
  }

  function shouldPlayAnimation(nextMode) {
    var currentMode = _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("param");

    if (currentMode !== "space" && nextMode === "space") {
      return false;
    } else if (currentMode === "space" && nextMode !== "space") {
      return true;
    } else {
      return _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("animate"); // current setting
    }
  }
  /**
   * Registers all event handlers to bind components and page elements together. There must be a cleaner
   * way to accomplish this...
   */


  function init() {
    report.status("Initializing...");
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#sponsor-link").attr("target", _micro__WEBPACK_IMPORTED_MODULE_6__["isEmbeddedInIFrame"]() && _micro__WEBPACK_IMPORTED_MODULE_6__["siteInstance"]() !== "tara" ? "_new" : null).on("click", function () {
      return reportSponsorClick("click");
    }).on("contextmenu", function () {
      return reportSponsorClick("right-click");
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#sponsor-hide").on("click", function () {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#sponsor").classed("invisible", true);
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#notice-hide").on("click", function () {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#notice").classed("invisible", true);
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#settings-show").select(".text-button").on("click", function () {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#settings-wrap").classed("invisible", false);

      if (!_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#menu").classed("invisible")) {
        // hide menu if open
        earth.click("show-menu");
      }
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#settings-hide").on("click", function () {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#settings-wrap").classed("invisible", true);
    });
    !function () {
      // highlight active lang
      var lang = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("html").attr("lang");
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#settings").selectAll("a[lang='" + lang + "']").classed("highlighted", true); // show preferred lang

      var best = _lang__WEBPACK_IMPORTED_MODULE_12__["best"](window.navigator);

      if (best !== lang) {
        _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#settings-show").select("a[lang='" + best + "']").classed("invisible", false);
      } // const parsed = language.parse(language.preferred(window.navigator)[0]);
      // if (parsed.language === "ko") {
      //     d3.select("#notice").classed("invisible", false);
      // }

    }();
    fillScreen(); // Adjust size of the scale canvas to fill the width of the menu to the right of the label.

    var label = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#scale-label").node();
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#scale").attr("width", Math.round((_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#menu").node().offsetWidth - label.offsetWidth) * 0.95)).attr("height", Math.round(label.offsetHeight / 2));
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#show-menu").on("click", function () {
      if (_micro__WEBPACK_IMPORTED_MODULE_6__["isEmbeddedInIFrame"]() && !_micro__WEBPACK_IMPORTED_MODULE_6__["isKioskMode"]() && _micro__WEBPACK_IMPORTED_MODULE_6__["siteInstance"]() !== "tara") {
        window.open("https://earth.nullschool.net/" + window.location.hash, "_blank");
      } else {
        var opening = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#menu").classed("invisible");
        _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#menu").classed("invisible", !opening);

        if (opening && underscore__WEBPACK_IMPORTED_MODULE_2__.isFunction(window.ga)) {
          window.ga("send", "event", "menu", "open");
        }
      }
    }); // Tweak document to distinguish CSS styling between touch and non-touch environments. Hacky hack.

    if ("ontouchstart" in document.documentElement) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"](document).on("touchstart", function () {}); // this hack enables :active pseudoclass
    } else {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"](document.documentElement).classed("no-touch", true); // to filter styles problematic for touch
    }

    function updateLangLinks() {
      // Change all lang links to retain the current hash fragment so stuff stays the same when clicked.
      _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"]("a[lang]").attr("href", function () {
        var e = _d3__WEBPACK_IMPORTED_MODULE_4__["select"](this),
            link = e.attr("data-link");
        return link ? link + window.location.hash : e.attr("href");
      });
    }

    updateLangLinks(); // Bind lang links URL bar changes.

    _d3__WEBPACK_IMPORTED_MODULE_4__["select"](window).on("hashchange.affects-lang", function () {
      log.debug("hashchange");
      updateLangLinks();
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change.?", function () {
      report.reset();
      buttonStateNotifier.submit(function () {
        // use agent to delay notification until button modification is done
        var highlighted = [],
            disabled = [];
        _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".highlighted").each(function () {
          highlighted.push(this.id);
        });
        _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".disabled").each(function () {
          disabled.push(this.id);
        });

        if (bridge.buttonStateChange) {
          bridge.buttonStateChange(JSON.stringify(highlighted), JSON.stringify(disabled));
        }
      });
    });
    var first = true;
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change.?", function (changed) {
      if (!underscore__WEBPACK_IMPORTED_MODULE_2__.isFunction(window.ga) || first) return first = false;
      var attr = _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].getAll();

      if (underscore__WEBPACK_IMPORTED_MODULE_2__.has(changed, "projection")) {
        window.ga("send", "event", "projection", attr.projection);
      }

      if (underscore__WEBPACK_IMPORTED_MODULE_2__.has(changed, "overlayType")) {
        window.ga("send", "event", "overlay", attr.overlayType);
      }

      if (underscore__WEBPACK_IMPORTED_MODULE_2__.has(changed, "param") || underscore__WEBPACK_IMPORTED_MODULE_2__.has(changed, "surface") || underscore__WEBPACK_IMPORTED_MODULE_2__.has(changed, "level")) {
        window.ga("send", "event", "layer", [attr.param, attr.surface, attr.level].join("-"));
      }
    });
    _framework_sessionState__WEBPACK_IMPORTED_MODULE_16__["model"].on("change:topology.?", function (url) {
      meshAgent.submit(buildMesh, url);
    });
    _framework_sessionState__WEBPACK_IMPORTED_MODULE_16__["model"].on("change:hd.?", function () {
      gridAgent.submit(buildGrids, true);
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:projection.?", function (attr) {
      globeAgent.submit(buildGlobe, attr);
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change.?", function (delta) {
      var changed = Object.keys(delta);
      var rebuildRequired = false,
          isNewPrimaryGrid = false; // Build a new primary grid if any related attributes have changed.

      if (underscore__WEBPACK_IMPORTED_MODULE_2__.intersection(changed, ["date", "param", "surface", "level"]).length > 0) {
        rebuildRequired = true;
        isNewPrimaryGrid = true;
      } // Build a new overlay grid if the new overlay type is different from the current one.


      var overlayType = _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("overlayType") || "default";

      if (underscore__WEBPACK_IMPORTED_MODULE_2__.indexOf(changed, "overlayType") >= 0 && overlayType !== "off") {
        var grids = gridAgent.value() || {},
            primary = grids.primaryGrid,
            overlay = grids.overlayGrid;

        if (!overlay) {
          // Do a rebuild if we have no overlay grid.
          rebuildRequired = true;
        } else if (overlay.type !== overlayType && !(overlayType === "default" && primary === overlay)) {
          // Do a rebuild if the types are different.
          rebuildRequired = true;
        }
      }

      if (rebuildRequired) {
        gridAgent.submit(buildGrids, isNewPrimaryGrid);
      }
    }); //        gridAgent.on("submit.affects-grid", () => {
    //            showGridDetails(null);
    //        });

    gridAgent.on("update.affects-grid", function (grids) {
      showGridDetails(grids);
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#toggle-zone").on("click", function () {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#data-date").classed("local", !_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#data-date").classed("local"));
      showDate(gridAgent.cancel.requested ? null : gridAgent.value());
    });

    function startRendering() {
      rendererAgent.submit(buildRenderer, meshAgent.value(), globeAgent.value());
    }

    meshAgent.on("update.affects-renderer", startRendering);
    globeAgent.on("update.affects-renderer", startRendering);

    function startInterpolation() {
      fieldAgent.submit(interpolateField, globeAgent.value(), gridAgent.value());
    }

    function cancelInterpolation() {
      fieldAgent.cancel();
      overlayGridAgent.cancel();
    }

    gridAgent.on("update.affects-field", startInterpolation);
    rendererAgent.on("render.affects-field", startInterpolation);
    rendererAgent.on("start.affects-field redraw.affects-field", cancelInterpolation);
    /*
            globeAgent.on("update.affects-argo", () => {
               argoAgent.submit(addArgo);
            });
            rendererAgent.on("render.affects-argo", () => {
               argoAgent.submit(addArgo);
            });
            sharedConfig.on("change:argoFloat.?", () => {
               argoAgent.submit(addArgo);
            });
    */

    fieldAgent.on("update.affects-animator", function () {
      animatorAgent.submit(animate, globeAgent.value(), gridAgent.value());
    });
    rendererAgent.on("start.affects-animator", function () {
      return stopCurrentAnimation(true);
    });
    gridAgent.on("submit.affects-animator", function () {
      return stopCurrentAnimation(false);
    });
    fieldAgent.on("submit.affects-animator", function () {
      return stopCurrentAnimation(false);
    });
    fieldAgent.on("update.affects-overlay", function () {
      overlayAgent.submit(drawOverlay, fieldAgent.value(), _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("overlayType"), _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("animate"));
    });
    rendererAgent.on("start.affects-overlay", function () {
      // Immediately clear overlay. Chrome will wait until mouse pauses before agent is triggered. :(
      _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["clearCanvas"](_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#overlay").node());
      overlayAgent.submit(drawOverlay, fieldAgent.value(), null, null);
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change.?", function (delta) {
      var changed = Object.keys(delta); // if only overlay relevant flags have changed...

      if (underscore__WEBPACK_IMPORTED_MODULE_2__.intersection(changed, ["overlayType", "showGridPoints", "animate"]).length > 0) {
        overlayAgent.submit(drawOverlay, fieldAgent.value(), _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("overlayType"), _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("animate"));
      }
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:animate.?", function (enabled) {
      if (!enabled) {
        stopCurrentAnimation(true);
      } else {
        startInterpolation();
      }
    }); // Add event handlers for showing, updating, and removing location details.

    inputController.on("click.affects-location", saveLocation);
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#location-close").on("click", removeLocation);
    fieldAgent.on("update.affects-location", updateLocation);
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:loc.?", updateLocation); // Modify menu depending on what mode we're in.

    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:param.?", function (mode) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".ocean-mode").classed("invisible", mode !== "ocean");
      _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".wind-mode").classed("invisible", mode !== "wind").selectAll(".text-button").classed("disabled", mode !== "wind"); // hack: hot keys cannot change height

      _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".chem-mode").classed("invisible", mode !== "chem");
      _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".particulates-mode").classed("invisible", mode !== "particulates");
      _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".space-mode").classed("invisible", mode !== "space"); // d3.selectAll(".argo-mode").classed("invisible", mode !== "argo");
      // d3.select("#notice").classed("invisible", true);

      switch (mode) {
        case "chem":
        case "particulates": //d3.select("#notice").classed("invisible", false);
        // fall through

        case "wind":
          _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-backward-more").attr("title", "-1 Day");
          _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-backward").attr("title", "-3 Hours");
          _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-forward").attr("title", "+3 Hours");
          _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-forward-more").attr("title", "+1 Day");
          break;

        case "ocean":
          _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-backward-more").attr("title", "-1 Month");
          _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-backward").attr("title", "-5 Days");
          _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-forward").attr("title", "+5 Days");
          _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-forward-more").attr("title", "+1 Month");
          break;
      }
    }); // Add handlers for mode buttons.

    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#air-mode").on("click", function () {
      if (_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("param") !== "wind") {
        _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
          param: "wind",
          surface: "surface",
          level: "level",
          overlayType: "default",
          animate: shouldPlayAnimation("wind")
        });
      }
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:param.?", function (param) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#air-mode").classed("highlighted", param === "wind");
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#ocean-mode").on("click", function () {
      if (_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("param") !== "ocean") {
        // When switching between modes, there may be no associated data for the current date. So we need
        // find the closest available according to the catalog. This is not necessary if date is "current".
        // UNDONE: this code is annoying. should be easier to get date for closest ocean product.
        var ocean = {
          param: "ocean",
          surface: "primary",
          level: "waves",
          overlayType: "significant_wave_height",
          animate: shouldPlayAnimation("ocean")
        };
        var attr = _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].getAll();

        if (attr.date === "current") {
          _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save(ocean);
        } else {
          Promise.all(_products__WEBPACK_IMPORTED_MODULE_9__["products"].productsFor(_micro__WEBPACK_IMPORTED_MODULE_6__["assign"](attr, ocean))).then(function (_ref5) {
            var _ref6 = _slicedToArray(_ref5, 1),
                product = _ref6[0];

            if (product.date()) {
              _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save(_micro__WEBPACK_IMPORTED_MODULE_6__["assign"](ocean, _micro__WEBPACK_IMPORTED_MODULE_6__["dateToConfig"](product.date())));
            }
          }).catch(report.error);
        }
      }
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:param.?", function (param) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#ocean-mode").classed("highlighted", param === "ocean");
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#chem-mode").on("click", function () {
      if (_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("param") !== "chem") {
        _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
          param: "chem",
          surface: "surface",
          level: "level",
          overlayType: "cosc",
          animate: shouldPlayAnimation("chem")
        });
      }
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:param.?", function (param) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#chem-mode").classed("highlighted", param === "chem");
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#particulates-mode").on("click", function () {
      if (_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("param") !== "particulates") {
        _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
          param: "particulates",
          surface: "surface",
          level: "level",
          overlayType: "duexttau",
          animate: shouldPlayAnimation("particulates")
        });
      }
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:param.?", function (param) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#particulates-mode").classed("highlighted", param === "particulates");
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#space-mode").on("click", function () {
      if (_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("param") !== "space") {
        _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
          param: "space",
          surface: "surface",
          level: "level",
          overlayType: "aurora",
          animate: shouldPlayAnimation("space")
        });
      }
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:param.?", function (param) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#space-mode").classed("highlighted", param === "space");
    });
    /*
            d3.select("#argo-mode").on("click", function() {
                if (sharedConfig.get("param") !== "argo") {
                    sharedConfig.save({
                        param: "argo",
                        surface: "pressure",
                        level: "2p5",
                        overlayType: "argo_mean_temp",
                        animate: shouldPlayAnimation("argo"),
                    });
                }
            });
            sharedConfig.on("change:param.?", param => {
                d3.select("#argo-mode").classed("highlighted", param === "argo");
            });
    */
    // Add logic to disable buttons that are incompatible with each other.

    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:overlayType.?", function (ot) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".surface").classed("disabled", function () {
        if (_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("param") !== "wind") {
          return true;
        }

        return this.getAttribute("id") === "surface-level" ? ot === "wind_power_density" : ot === "misery_index";
      });
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:surface.?", function (s) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#wind_power_density").classed("disabled", s === "surface");
    }); // Add event handlers for the time navigation buttons.

    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-backward-more").on("click", function () {
      return navigate(-10);
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-forward-more").on("click", function () {
      return navigate(+10);
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-backward").on("click", function () {
      return navigate(-1);
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-forward").on("click", function () {
      return navigate(+1);
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#nav-now").on("click", function () {
      return _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
        date: "current"
      });
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#option-show-grid").on("click", function () {
      _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
        showGridPoints: !_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("showGridPoints")
      });
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:showGridPoints.?", function (showGridPoints) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#option-show-grid").classed("highlighted", showGridPoints);
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#animate-start").on("click", function () {
      _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
        animate: !_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("animate")
      });
    });
    _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:animate.?", function (animate) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#animate-start").classed("highlighted", animate);
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#hd").on("click", function () {
      _framework_sessionState__WEBPACK_IMPORTED_MODULE_16__["model"].save({
        hd: !_framework_sessionState__WEBPACK_IMPORTED_MODULE_16__["model"].get("hd")
      });
    });
    _framework_sessionState__WEBPACK_IMPORTED_MODULE_16__["model"].on("change:hd.?", function (hd) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#hd").classed("highlighted", hd);
    }); // Add handlers for all wind level buttons.

    _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".surface").each(function () {
      var id = this.id,
          parts = id.split("-");
      bindButtonToConfiguration("#" + id, {
        param: "wind",
        surface: parts[0],
        level: parts[1]
      });
    }); // Add handlers for ocean animation types.

    bindButtonToConfiguration("#animate-currents", {
      param: "ocean",
      surface: "surface",
      level: "currents",
      animate: true,
      overlayType: "default"
    }, [{
      param: "ocean",
      surface: "surface",
      level: "currents"
    }]);
    bindButtonToConfiguration("#animate-waves", {
      param: "ocean",
      surface: "primary",
      level: "waves",
      animate: true,
      overlayType: "default"
    }, [{
      param: "ocean",
      surface: "primary",
      level: "waves"
    }]);
    /*
            // Add handlers for all argo depth buttons.
            d3.selectAll(".argo-surface").each(function() {
                const id = this.id, parts = id.split("-");
                bindButtonToConfiguration("#" + id, {param: "argo", surface: "pressure", level: parts[1]});
            });
    */
    // Add handlers for all overlay buttons.

    _products__WEBPACK_IMPORTED_MODULE_9__["products"].overlayTypes().each(function (type) {
      var newAttr = {
        overlayType: type
      },
          highlightAttrList = [newAttr];

      if (type === "misery_index") {
        _micro__WEBPACK_IMPORTED_MODULE_6__["assign"](newAttr, {
          surface: "surface",
          level: "level"
        });
      } else if (type === "currents") {
        highlightAttrList.push({
          param: "ocean",
          surface: "surface",
          level: "currents",
          overlayType: "default"
        });
      } else if (type === "primary_waves") {
        highlightAttrList.push({
          param: "ocean",
          surface: "primary",
          level: "waves",
          overlayType: "default"
        });
      }

      bindButtonToConfiguration("#".concat(type.replace(".", "")), newAttr, highlightAttrList);
    });
    bindButtonToConfiguration("#wind", {
      param: "wind",
      overlayType: "default"
    });
    bindButtonToConfiguration("#no-overlay", {
      overlayType: "off"
    });
    /*
            bindButtonToConfiguration("#argo-2p5", {surface: "pressure", level: "2p5dbar"});
            bindButtonToConfiguration("#argo-400", {surface: "pressure", level: "400dbar"});
            bindButtonToConfiguration("#argo_temp_mean", {overlayType: "argo_temp_mean"});
            bindButtonToConfiguration("#argo_temp_anom", {overlayType: "argo_temp_anom"});
            bindButtonToConfiguration("#argo_salinity_mean", {overlayType: "argo_salinity_mean"});
            bindButtonToConfiguration("#argo_salinity_anom", {overlayType: "argo_salinity_anom"});
            bindButtonToConfiguration("#argo-planned", {argoFloat: "planned"});
            bindButtonToConfiguration("#argo-recent", {argoFloat: "recent"});
            bindButtonToConfiguration("#argo-operational", {argoFloat: "operational"});
            bindButtonToConfiguration("#argo-dead", {argoFloat: "dead"});
            bindButtonToConfiguration("#argo-none", {argoFloat: null});
    */
    // Add handlers for all projection buttons.

    Object.keys(_globes__WEBPACK_IMPORTED_MODULE_8__).forEach(function (p) {
      bindButtonToConfiguration("#" + p, {
        projection: p,
        orientation: ""
      }, [{
        projection: p
      }]);
    }); // When touch device changes between portrait and landscape, rebuild globe using the new view size.

    _d3__WEBPACK_IMPORTED_MODULE_4__["select"](window).on("orientationchange", function () {
      window.scrollTo(0, 0);
      view = _micro__WEBPACK_IMPORTED_MODULE_6__["view"]();
      fillScreen();

      if (fastoverlayAgent.value()) {
        _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#fastoverlay").style("width", "".concat(view.width, "px")).style("height", "".concat(view.height, "px"));
      }

      globeAgent.submit(buildGlobe, _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("projection"));
    });

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["isKioskMode"]()) {
      _d3__WEBPACK_IMPORTED_MODULE_4__["selectAll"](".kiosk").classed("invisible", true);
    } else {
      setTimeout(function () {
        _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#menu-ham").transition().style("opacity", "0").remove();
      }, 15 * 1000);
    }

    function setupWebGL() {
      // const msg = glReport.pass ? "ok" : JSON.stringify(glReport);
      // log.debug(`check gl: ${msg}`);
      // if (_.isFunction(window.ga)) {
      //     window.ga("send", "event", "gl", msg);
      // }
      // if (!glReport.pass) {
      //     return;
      // }
      var glReport = _gl_glTest__WEBPACK_IMPORTED_MODULE_13__["runTest"](_micro__WEBPACK_IMPORTED_MODULE_6__["isDebugMode"]());
      var msg = glReport.pass ? "ok" : JSON.stringify(glReport);
      log.debug("test gl: ".concat(msg));

      if (underscore__WEBPACK_IMPORTED_MODULE_2__.isFunction(window.ga)) {
        window.ga("send", "event", "gl", msg);
      }

      if (!glReport.pass) {
        return;
      }

      function ƒready() {
        return _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("overlayType") !== "off" && rendererAgent.value();
      }

      function ƒalpha() {
        var product = (gridAgent.value() || {}).overlayGrid;
        return (_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].get("animate") ? product.alpha.animated : product.alpha.single) / 255;
      }

      function ƒdisplay() {
        return {
          width: view.width,
          height: view.height,
          pixelRatio: _framework_sessionState__WEBPACK_IMPORTED_MODULE_16__["model"].get("hd") ? 1.0 : 0.5
        };
      }

      function ƒproduct() {
        return (gridAgent.value() || {}).overlayGrid || {};
      }

      function ƒprojection(glu) {
        var globe = globeAgent.value();
        var proj = globe && globe.optimizedProjection();
        return proj && proj.webgl && proj.webgl(glu);
      }

      function ƒgrid(glu) {
        var product = ƒproduct();
        var grid = product.grid && product.grid() || {};
        return grid.webgl && grid.webgl(glu);
      }

      function ƒfield(glu) {
        var product = ƒproduct();
        var field = product.field && product.field()["bilinear"] || {};
        return field.webgl && field.webgl(glu);
      }

      function ƒscale(glu) {
        var product = ƒproduct();
        var scale = product.scale || {};
        return scale.webgl && scale.webgl(glu);
      }
      /**
       * Get the webgl components that are currently renderable.
       *
       * @param glu
       * @returns {Object[]} an array of webgl components, empty if any component does not support webgl.
       */


      function ƒcomponents(glu) {
        if (!ƒready()) {
          return [];
        }

        var components = [ƒprojection(glu), ƒgrid(glu), ƒfield(glu), ƒscale(glu)].filter(function (e) {
          return !!e;
        });
        return components.length === 4 ? components : [];
      }

      var canvas = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#fastoverlay").style("width", "".concat(view.width, "px")).style("height", "".concat(view.height, "px")).node();
      var fastoverlay = Object(_gl_fastoverlay__WEBPACK_IMPORTED_MODULE_14__["default"])(canvas, _micro__WEBPACK_IMPORTED_MODULE_6__["isIOS"]() ? _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["createCanvas"]() : undefined, ƒalpha, ƒdisplay, ƒcomponents); // All of these events trigger a new frame.

      _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].on("change:overlayType.?", fastoverlay.draw);
      _framework_sessionState__WEBPACK_IMPORTED_MODULE_16__["model"].on("change:hd.?", fastoverlay.draw);
      globeAgent.on("update.affects-fastoverlay", fastoverlay.draw);
      gridAgent.on("update.affects-fastoverlay", fastoverlay.draw);
      rendererAgent.on("redraw.affects-fastoverlay", fastoverlay.draw);
      rendererAgent.on("render.affects-fastoverlay", fastoverlay.draw);
      animatorAgent.on("update.affects-fastoverlay", fastoverlay.draw);
      fastoverlayAgent.submit(fastoverlay);
    }

    setupWebGL();
    var pressure = ["surface-level", "isobaric-1000hPa", "isobaric-850hPa", "isobaric-700hPa", "isobaric-500hPa", "isobaric-250hPa", "isobaric-70hPa", "isobaric-10hPa"];

    function pressureLevel() {
      var attr = _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].getAll(),
          key = attr.surface + "-" + attr.level;
      return attr.param === "wind" ? underscore__WEBPACK_IMPORTED_MODULE_2__.indexOf(pressure, key) : -1;
    }

    function clearDialog() {
      if (!_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#settings-wrap").classed("invisible")) {
        earth.click("settings-hide");
        return true;
      }

      if (!_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#location-close").classed("invisible")) {
        earth.click("location-close");
        return true;
      }

      if (!_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#menu").classed("invisible")) {
        earth.click("show-menu");
        return true;
      }

      if (!_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#notice").classed("invisible")) {
        earth.click("notice-hide");
        return true;
      }

      if (!_d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#sponsor").classed("invisible")) {
        earth.click("sponsor-hide");
        return true;
      }
    }

    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("body").on("keydown", function () {
      var e = _d3__WEBPACK_IMPORTED_MODULE_4__["event"],
          key = _keyboard__WEBPACK_IMPORTED_MODULE_10__["key"](e);

      if (e.defaultPrevented || e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) {
        return;
      }

      switch (key) {
        case "Escape":
          if (!clearDialog()) return;
          break;

        default:
          return;
        // Never bind to keys used for search in various browsers:  /.',
      }

      e.preventDefault(); // stops FF from showing search bar
    });
    _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("body").on("keypress", function () {
      var e = _d3__WEBPACK_IMPORTED_MODULE_4__["event"],
          key = _keyboard__WEBPACK_IMPORTED_MODULE_10__["key"](e);

      if (e.defaultPrevented || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      switch (key) {
        case "e":
          earth.click("show-menu");
          break;

        case "I":
          earth.click(pressure[pressure.length - 1]);
          break;

        case "i":
          earth.click(pressure[pressureLevel() + 1]);
          break;

        case "m":
          earth.click(pressure[pressureLevel() - 1]);
          break;

        case "M":
          earth.click(pressure[0]);
          break;

        case "J":
          earth.click("nav-backward-more");
          break;

        case "j":
          earth.click("nav-backward");
          break;

        case "k":
          earth.click("nav-forward");
          break;

        case "K":
          earth.click("nav-forward-more");
          break;

        case "n":
          earth.click("nav-now");
          break;

        case "p":
          earth.click("animate-start");
          break;

        case "g":
          earth.click("option-show-grid");
          break;

        case "H":
          earth.click("hd");
          break;

        case "d":
          inputController.hotkey("zoom", 1.003);
          break;

        case "x":
          inputController.hotkey("zoom", 0.997);
          break;

        case "D":
          inputController.hotkey("zoom", 1.05);
          break;

        case "X":
          inputController.hotkey("zoom", 0.95);
          break;

        case "w":
          inputController.hotkey("up", 1);
          break;

        case "W":
          inputController.hotkey("up", 8);
          break;

        case "z":
          inputController.hotkey("down", 1);
          break;

        case "Z":
          inputController.hotkey("down", 8);
          break;

        case "a":
          inputController.hotkey("left", 1);
          break;

        case "A":
          inputController.hotkey("left", 8);
          break;

        case "s":
          inputController.hotkey("right", 1);
          break;

        case "S":
          inputController.hotkey("right", 8);
          break;

        default:
          return;
        // Never bind to keys used for search in various browsers:  /.',
        // Never bind to cursor keys (used for scrolling during zoom), or to Alt|Cmd|Ctrl chords.
        // Never bind to these keys: http://stackoverflow.com/questions/9612458/hot-keys-to-avoid
      }

      e.preventDefault(); // stops FF from showing search bar
    });
  }

  function start() {
    // Everything is now set up, so load state from the hash fragment and kick off change events.
    Object(_framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["attach"])();
    Object(_framework_sessionState__WEBPACK_IMPORTED_MODULE_16__["attach"])();
  }

  Promise.resolve().then(init).then(start).catch(report.error);

  function activeProduct() {
    return (gridAgent.value() || {}).overlayGrid;
  }

  _micro__WEBPACK_IMPORTED_MODULE_6__["assign"](earth, {
    url: function url() {
      return window.location.href.toString();
    },
    scale: {
      /**
       * @param {Number} pct percentage in the range [0, 100] (inclusive)
       * @returns {String} JSON encoded map of units to values, or "{}" if no product is active. For example:
       *     {
       *         "wind": {
       *             "m/s" : "100° @ 7.3",
       *             "kn"  : "100° @ 14",
       *             "mph" : "100° @ 16"
       *         }
       *     }
       */
      valueAt: function valueAt(pct) {
        var product = activeProduct(),
            result = {};

        if (product) {
          var group = {},
              value = _math__WEBPACK_IMPORTED_MODULE_1__["spread"].apply(void 0, [pct / 100].concat(_toConsumableArray(product.scale.bounds)));
          product.units.forEach(function (unit) {
            group[unit.label] = _micro__WEBPACK_IMPORTED_MODULE_6__["formatScalar"](value, unit);
          });
          result[product.type] = group;
        }

        return JSON.stringify(result);
      },

      /**
       * @returns {String} a JSON encoded array of colors, "[r0, g0, b0, a0, ..., rn-1, gn-1, bn-1, an-1]",
       *          where n is the size of the palette. The result is empty "{}" if no product is active, otherwise
       *          the length will be size*4.
       *          {
       *              "wind": [30, 20, 92, 255, ..., 193, 245, 223, 255]
       *          }
       */
      palette: function palette() {
        var product = activeProduct();
        return JSON.stringify(product ? _defineProperty({}, product.type, _micro__WEBPACK_IMPORTED_MODULE_6__["toArray"](product.scale.colors)) : {});
      }
    },

    /**
     * Navigate current product to the specified date. Return the expected date of that product as milliseconds,
     * or 0 if there is no product, or the specified date is not valid.
     *
     * @param {*} date milliseconds from unix epoch or string in format "yyyy-MM-ddThh:mm:ssZ".
     * @returns {Number} date of the product best matching the specified date as milliseconds from epoch,
     *                   or 0 if no product can be found.
     */
    navToDate: function navToDate(date) {
      var product = activeProduct();
      var target = new Date(date);
      if (!product || underscore__WEBPACK_IMPORTED_MODULE_2__.isNaN(target.getUTCFullYear())) return 0;
      target = product.navigateTo(_utc__WEBPACK_IMPORTED_MODULE_7__["parts"](target));
      if (!target) return 0;

      underscore__WEBPACK_IMPORTED_MODULE_2__.defer(function () {
        _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save(_micro__WEBPACK_IMPORTED_MODULE_6__["dateToConfig"](target)); // defer all side effects
      });

      return _utc__WEBPACK_IMPORTED_MODULE_7__["date"](target).getTime();
    },

    /**
     * Triggers a click event on the specified button.
     *
     * @param {String} id the button id.
     */
    click: function click(id) {
      // side effects means we need to defer
      underscore__WEBPACK_IMPORTED_MODULE_2__.defer(function () {
        var node = _d3__WEBPACK_IMPORTED_MODULE_4__["select"]("#" + id).node();
        return node !== null ? node.dispatchEvent(_micro__WEBPACK_IMPORTED_MODULE_6__["newClickEvent"]()) : undefined;
      });
    },

    /**
     * Shows location indicator at specified coordinates.
     *
     * @param {Number} lon
     * @param {Number} lat
     */
    locate: function locate(lon, lat) {
      // side effects means we need to defer
      underscore__WEBPACK_IMPORTED_MODULE_2__.defer(_locate, lon, lat);
    },
    orient: function orient(coord) {
      // HACK for now. What's the best way to do this?
      underscore__WEBPACK_IMPORTED_MODULE_2__.defer(function () {
        var globe = globeAgent.value();

        if (coord === undefined) {
          return globe.projection.rotate();
        }

        globe.projection.rotate(coord);
        _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
          orientation: globe.orientation()
        }); // triggers reorientation
      });
    },

    /**
     * Stop animation.
     */
    stop: function stop() {
      // side effects means we need to defer
      underscore__WEBPACK_IMPORTED_MODULE_2__.defer(function () {
        _framework_sharedState__WEBPACK_IMPORTED_MODULE_15__["model"].save({
          animate: false
        });
      });
    },

    /**
     * Forcefully ends the current move operation, if any.
     */
    cancelMove: function cancelMove() {
      inputController.cancelMove();
    }
  });
}

/***/ }),

/***/ "./src/framework/model.mjs":
/*!*********************************!*\
  !*** ./src/framework/model.mjs ***!
  \*********************************/
/*! exports provided: createModel */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createModel", function() { return createModel; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../d3 */ "./src/d3.mjs");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




/**
 * A Model is a map that emits events when its entries change. The set of allowable keys is fixed at creation time
 * using the specified initial state.
 *
 * const model = createModel({a: 1, b: 2});
 * model.on("change",   (delta, old, meta) => console.log(`change ${delta}, ${old}, ${meta}`));
 * model.on("change:b", (delta, old, meta) => console.log(`change:b ${delta}, ${old}, ${meta}`));
 *
 * model.get("a");             // 1
 * model.save({a: 2});         // "change {a: 2}, {a: 1}, undefined"
 * model.save({a: 3}, "foo");  // "change {a: 3}, {a: 2}, foo"
 * model.save({a: 4, b: 0});   // "change:b 0, 2, undefined" and "change {a: 4, b: 0}, {a: 3, b: 2}, undefined"
 *
 * Attribute changes are detected using _.isEqual deep comparison.
 *
 * UNDONE: Given all the constraints, probably best to build own implementation of dispatcher.
 *
 * @param {Object} initialState the fixed set of keys and their initial values.
 * @returns {Model}
 */

function createModel(initialState) {
  var keys = Object.keys(initialState);
  var dispatch = _d3__WEBPACK_IMPORTED_MODULE_2__["dispatch"].apply(undefined, ["change"].concat(keys.map(function (key) {
    return "change:".concat(key);
  })));
  var attributes = Object(_micro__WEBPACK_IMPORTED_MODULE_1__["ø"])(initialState);
  var seq = 0;

  function interpret(typenames) {
    return typenames.trim().split(/^|\s+/).map(function (t) {
      return t.replace("?", seq++);
    });
  }

  return new (
  /*#__PURE__*/
  function () {
    function Model() {
      _classCallCheck(this, Model);
    }

    _createClass(Model, [{
      key: "on",

      /**
       * Registers a callback for the specified typenames. Basically the same as D3 dispatch.on() except that this
       * method returns the array of parsed typenames when a callback is specified. The typename may contain the
       * character "?", which is replaced with an auto-incrementing number to ensure the name is unique. The unqiue
       * name is then returned by this method.
       *
       * There are two event patterns:
       *
       *     "change"        fired when any attribute changes
       *                     callback ƒ(delta, old, meta)
       *                         delta: map of changed attributes
       *                         old:   map of original attributes
       *                         meta:  the (optional) object specified on the call to save()
       *
       *     "change:<key>"  fired when attribute for <key> changes
       *                     callback ƒ(delta, old, meta)
       *                         delta: the new attribute value
       *                         old:   the old attribute value
       *                         meta:  the (optional) object specified on the call to save()
       *
       * model.on("change",     ƒ);  // adds handler for "change" event
       * model.on("change",     ƒ);  // replaces previous handler for "change" event
       * model.on("change.foo", ƒ);  // adds handler for "change" event with name "foo"
       * model.on("change.bar", ƒ);  // adds handler for "change" event with name "bar"
       * model.on("change.?",   ƒ);  // adds handler for "change" event with a unique name to ensure no previous
       *                             // handler is replaced, returning the actual name used, e.g.: ["change.5"]
       *
       * model.on("change:a change:b", ƒ);  // adds handler for both "change:a" and "change:b"
       *
       * model.on("change");        // returns handler for "change" event
       * model.on("change.foo");    // returns handler for "change" event for name "foo"
       * model.on("change", null);  // removes the handler for "change" event
       * model.on(".foo", null);    // removes all handlers for name "foo"
       *
       * @param {string} typenames
       * @param {Function} [callback] ƒ(delta, old, meta)
       * @returns {string[]|Function} the parsed typenames if callback specified, otherwise the callback registered
       *                              for the specified typename.
       */
      value: function on(typenames, callback) {
        var tn = interpret(typenames);
        var result = dispatch.on(tn.join(" "), callback);
        return arguments.length < 2 ? result : tn;
      }
      /** @param {string} key */

    }, {
      key: "get",
      value: function get(key) {
        return attributes[key];
      }
      /** @returns {Object} a shallow copy of this model's attributes */

    }, {
      key: "getAll",
      value: function getAll() {
        return Object(_micro__WEBPACK_IMPORTED_MODULE_1__["ø"])(attributes);
      }
      /**
       * Examples:
       *     model.save({a: 1});                      // raises "change" and "change:a" events
       *     model.save({a: 1, b: 2}, {foo: "bar"});  // raises "change", "change:a", and "change:b" events
       *
       * @param {Object} changes the entries to change on this model. Events are raised if changes from this model's
       *                 current state are found using _.isEqual deep comparison.
       * @param {*} [meta] optional value passed directly to any callbacks invoked by this change.
       */

    }, {
      key: "save",
      value: function save(changes, meta) {
        var delta = Object(_micro__WEBPACK_IMPORTED_MODULE_1__["ø"])();
        var old = Object(_micro__WEBPACK_IMPORTED_MODULE_1__["ø"])();
        Object.keys(changes).forEach(function (key) {
          if (!(key in attributes)) {
            throw new Error("unknown key: ".concat(key));
          }

          var value = changes[key];
          var oldValue = attributes[key];

          if (!underscore__WEBPACK_IMPORTED_MODULE_0__.isEqual(value, oldValue)) {
            delta[key] = value;
            old[key] = oldValue;
          }
        });
        var keys = Object.keys(delta);

        if (keys.length > 0) {
          keys.forEach(function (key) {
            return attributes[key] = delta[key];
          });
          keys.forEach(function (key) {
            return dispatch.call("change:".concat(key), null, delta[key], old[key], meta);
          });
          dispatch.call("change", null, delta, old, meta);
        }
      }
    }]);

    return Model;
  }())();
}

/***/ }),

/***/ "./src/framework/sessionState.mjs":
/*!****************************************!*\
  !*** ./src/framework/sessionState.mjs ***!
  \****************************************/
/*! exports provided: model, attach */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "model", function() { return model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attach", function() { return attach; });
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ "./src/framework/model.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");



function topologyFile() {
  return Object(_micro__WEBPACK_IMPORTED_MODULE_1__["isMobile"])() ? "/earth-topo-mobile.json?v3" : "/earth-topo.json?v3";
}

var model = Object(_model__WEBPACK_IMPORTED_MODULE_0__["createModel"])({
  hd: undefined,
  topology: undefined
});
function attach() {
  model.save({
    hd: false,
    topology: topologyFile()
  });
}

/***/ }),

/***/ "./src/framework/sharedState.mjs":
/*!***************************************!*\
  !*** ./src/framework/sharedState.mjs ***!
  \***************************************/
/*! exports provided: model, attach */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "model", function() { return model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attach", function() { return attach; });
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utc */ "./src/utc.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _globes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../globes */ "./src/globes.mjs");
/* harmony import */ var _products__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../products */ "./src/products.mjs");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./model */ "./src/framework/model.mjs");
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../d3 */ "./src/d3.mjs");







var overlayTypes = _products__WEBPACK_IMPORTED_MODULE_4__["products"].overlayTypes(); // const DEFAULT_CONFIG = "current/wind/surface/level/orthographic";

function defaultState() {
  return Object(_micro__WEBPACK_IMPORTED_MODULE_1__["ø"])({
    date: "current",
    param: "wind",
    surface: "surface",
    level: "level",
    projection: "orthographic",
    orientation: "",
    overlayType: "default",
    showGridPoints: false,
    animate: true,
    loc: null,
    argoFloat: null
  });
}

function initialState() {
  var empty = Object(_micro__WEBPACK_IMPORTED_MODULE_1__["ø"])();
  Object.keys(defaultState()).forEach(function (key) {
    return empty[key] = undefined;
  });
  return empty;
}

function fromHashFragment(hash) {
  var option; //                1        2        3          4          5            6      7      8    9

  var tokens = /^#(current|(\d{4})\/(\d{1,2})\/(\d{1,2})\/(\d{3,4})Z)\/(\w+)\/(\w+)\/(\w+)([\/].+)?/.exec(hash);

  if (!tokens) {
    return defaultState();
  }

  var date = tokens[1] === "current" ? "current" : {
    year: +tokens[2],
    month: +tokens[3],
    day: +tokens[4]
  };

  if (date !== "current") {
    var hour = (tokens[5].length === 3 ? "0" : "") + tokens[5];
    date.hour = +hour.substr(0, 2);
    date.minute = +hour.substr(2);
  }

  var result = defaultState();
  result.date = date;
  result.param = tokens[6];
  result.surface = tokens[7];
  result.level = tokens[8];
  Object(_micro__WEBPACK_IMPORTED_MODULE_1__["coalesce"])(tokens[9], "").split("/").forEach(function (segment) {
    if (option = /^(\w+)(=([\d\-.,]*))?$/.exec(segment)) {
      if (underscore__WEBPACK_IMPORTED_MODULE_2__.has(_globes__WEBPACK_IMPORTED_MODULE_3__, option[1])) {
        result.projection = option[1]; // non-empty alphanumeric _

        result.orientation = Object(_micro__WEBPACK_IMPORTED_MODULE_1__["coalesce"])(option[3], ""); // comma delimited string of numbers, or ""
      } else if (option[1] === "loc") {
        var parts = underscore__WEBPACK_IMPORTED_MODULE_2__.isString(option[3]) ? option[3].split(",") : [];
        var λ = +parts[0],
            φ = +parts[1];

        if (λ === λ && φ === φ) {
          result.loc = [λ, φ];
        }
      }
    } else if (option = /^overlay=([\w.]+)$/.exec(segment)) {
      if (overlayTypes.has(option[1]) || option[1] === "default") {
        result.overlayType = option[1];
      }
    } else if (option = /^grid=(\w+)$/.exec(segment)) {
      if (option[1] === "on") {
        result.showGridPoints = true;
      }
    } else if (option = /^anim=(\w+)$/.exec(segment)) {
      if (option[1] === "off") {
        result.animate = false;
      }
    } else if (option = /^argo=(\w+)$/.exec(segment)) {
      switch (option[1]) {
        case "planned":
        case "recent":
        case "operational":
        case "dead":
          result.argoFloat = option[1];
      }
    }
  });
  return result;
}

function toHashFragment(attr) {
  var date = attr.date,
      param = attr.param,
      surface = attr.surface,
      level = attr.level,
      projection = attr.projection,
      orientation = attr.orientation,
      overlayType = attr.overlayType,
      showGridPoints = attr.showGridPoints,
      animate = attr.animate,
      loc = attr.loc,
      argoFloat = attr.argoFloat;
  var dir = date === "current" ? "current" : _utc__WEBPACK_IMPORTED_MODULE_0__["print"](date, "{yyyy}/{MM}/{dd}/{hh}{mm}Z");
  var proj = [projection, orientation].filter(function (x) {
    return x;
  }).join("=");
  var ol = !overlayType || overlayType === "default" ? "" : "overlay=" + overlayType;
  var location = loc ? "loc=" + loc.map(function (e) {
    return e.toFixed(3);
  }).join(",") : "";
  var grid = showGridPoints ? "grid=on" : "";
  var anim = animate ? "" : "anim=off";
  var argo = argoFloat ? "argo=" + argoFloat : "";
  return "#" + [dir, param, surface, level, anim, ol, grid, argo, proj, location].filter(function (x) {
    return x;
  }).join("/");
}

var model = Object(_model__WEBPACK_IMPORTED_MODULE_5__["createModel"])(initialState());

function readHashFragment() {
  var hash = window.location.hash;
  var attributes = fromHashFragment(hash);
  model.save(attributes, {
    source: "hash"
  });
}

function writeHashFragment(delta, old) {
  var meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var attributes = model.getAll();
  var changed = toHashFragment(attributes); // change the hash fragment only when there's a difference, and only when the change wasn't itself triggered by
  // a hash change.

  if (window.location.hash !== changed && meta.source !== "hash") {
    window.location.hash = changed;
  }
}

function attach() {
  model.on("change.affects-hash", writeHashFragment);
  _d3__WEBPACK_IMPORTED_MODULE_6__["select"](window).on("hashchange.affects-config", readHashFragment);
  readHashFragment();
}

/***/ }),

/***/ "./src/gl/fastoverlay.mjs":
/*!********************************!*\
  !*** ./src/gl/fastoverlay.mjs ***!
  \********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _glu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glu */ "./src/gl/glu.mjs");
/* harmony import */ var _canvas_twod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../canvas/twod */ "./src/canvas/twod.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _header_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./header.frag */ "./src/gl/header.frag");
/* harmony import */ var _main_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./main.frag */ "./src/gl/main.frag");






/**
 * @param {HTMLCanvasElement} canvas
 * @param {HTMLCanvasElement} [intermediateCanvas]
 * @param ƒalpha ƒ() => number, in the range [0, 1] inclusive. The alpha to apply to the whole frame.
 * @param ƒdisplay ƒ() => {width: number, height: number, pixelRatio: number}. Function that returns the current
 *                 canvas's display size and desired pixel ratio. For example, a ratio of 2.0 would make the drawing
 *                 buffer twice the size in each dimension as the display size (and thus 4x the pixel count),
 *                 whereas a ratio of 0.5 halves the size.
 * @param ƒcomponents ƒ({GLUStick}) => array of "webgl" components/renderers, or empty array if the frame cannot or
 *                    should not be drawn.
 * @returns {*}
 */

/* harmony default export */ __webpack_exports__["default"] = (function (canvas, intermediateCanvas, ƒalpha, ƒdisplay, ƒcomponents) {
  // Draw webgl offscreen then copy to 2d canvas. Reduces jank, especially on iOS, during compositing of different
  // layers at the expense of some performance. Better way?
  var useIntermediateCanvas = intermediateCanvas !== undefined;
  var container = useIntermediateCanvas ? intermediateCanvas : canvas;
  var targetCtx = useIntermediateCanvas ? canvas.getContext("2d") : undefined;
  var gl = _glu__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGL(container);
  var glu = _glu__WEBPACK_IMPORTED_MODULE_1__["default"].attach(gl);
  gl.getExtension("OES_texture_float");
  gl.getExtension("OES_texture_float_linear");
  gl.disable(gl.DEPTH_TEST);
  gl.clearColor(0, 0, 0, 0);
  var vertexShader = glu.makeShader(gl.VERTEX_SHADER, _glu__WEBPACK_IMPORTED_MODULE_1__["default"].planeVertexShader());
  var textures = {}; // registry of textures used by webgl components, by name

  var units = underscore__WEBPACK_IMPORTED_MODULE_0__.range(8).map(function () {
    return null;
  }); // a[i] -> texture, where i is unit index. webgl 1.0 guarantees 8 units


  var currentUnit = 1; // next available texture unit

  var currentSources = []; // sources of current program

  var currentProgram = null; // program to run

  var currentUniforms = null; // uniform assigner

  var currentWidth = -1; // viewport width

  var currentHeight = -1; // viewport height

  /**
   * Compiles new shaders and sets up unit plane.
   * @param {string[]} newSources
   */

  function buildProgram(newSources) {
    var fragmentShaderSource = _header_frag__WEBPACK_IMPORTED_MODULE_4__ + newSources.join("") + _main_frag__WEBPACK_IMPORTED_MODULE_5__;
    var fragmentShader = glu.makeShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
    var newProgram = glu.makeProgram([vertexShader, fragmentShader]);
    glu.attribs(newProgram).set(_glu__WEBPACK_IMPORTED_MODULE_1__["default"].unitPlaneAttributes());
    currentSources = newSources;
    currentProgram = newProgram;
    currentUniforms = glu.uniforms(newProgram, textures);
    gl.useProgram(newProgram);
  }
  /**
   * Applies delta between existing texture settings and new settings.
   * @param def texture definition as specified in GLU
   * @param entry existing texture entry object: {def: {}, texture: WebGLTexture, unit: number}
   * @returns {Object} texture entry object, with reference to "data" removed to allow garbage collection.
   */


  function apply(def, entry) {
    if (entry) {
      // texture entry exists, so let's find what's different
      var existing = entry.def;

      if (def.hash === existing.hash) {
        // same data
        if (!glu.updateTexture2DParams(entry.texture, def, existing)) {
          return entry; // nothing to do because nothing is different
        }

        return {
          def: underscore__WEBPACK_IMPORTED_MODULE_0__.omit(def, "data"),
          texture: entry.texture
        };
      } // pixels are different


      if (def.width === existing.width && def.height === existing.height && def.format === existing.format && def.type === existing.type) {
        // but data is the same shape, so can reuse this texture
        glu.updateTexture2D(entry.texture, def);
        return {
          def: underscore__WEBPACK_IMPORTED_MODULE_0__.omit(def, "data"),
          texture: entry.texture
        };
      } // replace texture with a new one


      gl.deleteTexture(entry.texture);
    } // create new texture


    var texture = glu.makeTexture2D(def);
    return {
      def: underscore__WEBPACK_IMPORTED_MODULE_0__.omit(def, "data"),
      texture: texture
    };
  }
  /**
   * @param {Object} defs creates or updates texture entries for each specified texture definition
   * @returns {Object[]} the texture entries
   */


  function registerTextures(defs) {
    return Object.keys(defs).map(function (name) {
      return textures[name] = apply(defs[name], textures[name]);
    });
  }
  /**
   * Sequentially assigns and binds textures to texture units.
   * @param {Object[]} entries the texture entries to bind.
   */


  function bindTextures(entries) {
    entries.forEach(function (entry) {
      var texture = entry.texture; // check if already bound to the current unit

      if (units[currentUnit] !== texture) {
        units[currentUnit] = texture;
        gl.activeTexture(gl.TEXTURE0 + currentUnit);
        gl.bindTexture(gl.TEXTURE_2D, texture);
      }

      entry.unit = currentUnit++;
    });
  }
  /**
   * Adjust size of drawing buffer (i.e., viewport) to match display.
   * @param {{width: number, height: number, pixelRatio: number}} display the attributes of the display.
   */


  function resizeTo(display) {
    var newWidth = Math.round(display.width * display.pixelRatio);
    var newHeight = Math.round(display.height * display.pixelRatio);

    if (newWidth !== currentWidth || newHeight !== currentHeight) {
      canvas.width = container.width = newWidth;
      canvas.height = container.height = newHeight;
      gl.viewport(0, 0, newWidth, newHeight);
      currentWidth = newWidth;
      currentHeight = newHeight;
    }
  }

  function clear() {
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (targetCtx) {
      _canvas_twod__WEBPACK_IMPORTED_MODULE_2__["clearContext"](targetCtx);
    }
  }

  function check(tag) {
    var err = gl.getError();

    if (err !== 0) {
      throw new Error("".concat(err, ":").concat(tag));
    }
  }
  /**
   * Render a frame.
   *
   * @returns {boolean} true if current components support webgl, otherwise false (to then be handled by 2d).
   */


  function _draw() {
    var display = ƒdisplay();
    resizeTo(display);
    check("fast_resize");
    clear();
    check("fast_clear");
    var components = ƒcomponents(glu);

    if (components.length === 0) {
      // Either we aren't supposed to draw anything or some of the components do not support webgl.
      return false;
    } // Check if we should change the program.


    var newSources = underscore__WEBPACK_IMPORTED_MODULE_0__.flatten(components.map(function (c) {
      return c.shaderSource();
    }));

    if (!_micro__WEBPACK_IMPORTED_MODULE_3__["arraysEq"](currentSources, newSources)) {
      buildProgram(newSources);
    }

    check("fast_program"); // Bind textures needed for this frame to available units. Just sequentially assign from 1.

    currentUnit = 1;
    components.forEach(function (c) {
      return bindTextures(registerTextures(c.textures()));
    });

    while (currentUnit < units.length) {
      units[currentUnit++] = null; // clear out unused units to release their texture objects.
    }

    check("fast_textures"); // Ask each component to assign uniforms.

    components.forEach(function (c) {
      return currentUniforms.set(c.uniforms());
    });
    currentUniforms.set({
      u_Detail: display.pixelRatio,
      // HACK: set alpha based on current state of animating particles.
      //       should this instead by handled by the palette component?
      u_Alpha: ƒalpha()
    });
    check("fast_uniforms");
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    check("fast_draw");

    if (useIntermediateCanvas) {
      targetCtx.drawImage(container, 0, 0);
    }

    return true;
  }

  return {
    /**
     * Render a frame.
     *
     * @returns {{pass: boolean}} result object where pass: true means the draw succeeded and pass: false means
     *          the draw did not succeed (likely because components do not yet support webgl). An "err" attribute
     *          is present if the draw was attempted but failed.
     */
    draw: function draw() {
      try {
        var pass = _draw();

        check("fast_done");
        return {
          pass: pass
        };
      } catch (e) {
        return {
          pass: false,
          err: e.toString()
        };
      }
    }
  };
});

/***/ }),

/***/ "./src/gl/glTest.mjs":
/*!***************************!*\
  !*** ./src/gl/glTest.mjs ***!
  \***************************/
/*! exports provided: runTest */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runTest", function() { return runTest; });
/* harmony import */ var _projection_orthographic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../projection/orthographic */ "./src/projection/orthographic.mjs");
/* harmony import */ var _palette_palette__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../palette/palette */ "./src/palette/palette.mjs");
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grid/regular */ "./src/grid/regular.mjs");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interpolate/bilinear */ "./src/interpolate/bilinear.mjs");
/* harmony import */ var _fastoverlay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fastoverlay */ "./src/gl/fastoverlay.mjs");
/* harmony import */ var _canvas_twod__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../canvas/twod */ "./src/canvas/twod.mjs");
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../d3 */ "./src/d3.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _glu__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./glu */ "./src/gl/glu.mjs");









var width = 300,
    height = 300,
    pixelRatio = 1;
var proj = Object(_projection_orthographic__WEBPACK_IMPORTED_MODULE_0__["default"])(width / 2, 0, 0, width / 2, width / 2);
var grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_2__["default"])({
  "start": 0,
  "delta": 120,
  "size": 3
}, {
  "start": 60,
  "delta": -60,
  "size": 3
});
var data = new Float32Array([//  u  v     len
1, 0, // 1
2, 0, // 2
3, 0, // 3
4, 0, // 4
5, 0, // 5
8, 0, // 8
6, 0, // 6
8, 0, // 8
7e37, 7e37]);
var field = Object(_interpolate_bilinear__WEBPACK_IMPORTED_MODULE_3__["vector"])(grid, data);
var scale = Object(_palette_palette__WEBPACK_IMPORTED_MODULE_1__["buildScaleFromSegments"])([0, 7], [[0, [255, 255, 255]], [1, [0, 0, 255]], [2, [0, 255, 0]], [3, [0, 255, 255]], [4, [255, 0, 0]], [5, [255, 0, 255]], [6, [255, 255, 0]], [7, [255, 255, 255]]], 8);
function runTest(show) {
  console.time("glTest");
  var res = {
    pass: false
  };

  try {
    var sample = function sample(x, y) {
      var out = new Uint8Array(4);
      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, out);
      return out;
    };

    var canvas = _canvas_twod__WEBPACK_IMPORTED_MODULE_5__["createCanvas"](width, height);

    if (show) {
      _d3__WEBPACK_IMPORTED_MODULE_6__["select"](canvas).style("width", "".concat(width / pixelRatio, "px")).style("height", "".concat(height / pixelRatio, "px")).style("position", "absolute").style("top", "0").style("left", "0");
      _d3__WEBPACK_IMPORTED_MODULE_6__["select"]("#display").node().appendChild(canvas);
    }

    var gl = _glu__WEBPACK_IMPORTED_MODULE_8__["default"].getWebGL(canvas);

    if (!gl) {
      res.hasContext = false;
      return res;
    }

    var maxTexSize = +gl.getParameter(gl.MAX_TEXTURE_SIZE) || -1;

    if (maxTexSize < 4096) {
      res.maxTexSize = maxTexSize; // data layers up to this size are expected.

      return res;
    }

    var precision = +gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision || -1;

    if (precision < 23) {
      res.precision = precision; // not enough precision for expected data layers.

      return res;
    }

    res.scenario = 1;
    var drawResult = Object(_fastoverlay__WEBPACK_IMPORTED_MODULE_4__["default"])(canvas, undefined, function () {
      return 1;
    }, function () {
      return {
        width: width,
        height: height,
        pixelRatio: pixelRatio
      };
    }, function (glu) {
      return [proj.webgl(glu), grid.webgl(glu), field.webgl(glu), scale.webgl(glu)];
    }).draw();

    if (drawResult.err) {
      res.err = drawResult.err;
      return res;
    }

    var colorMatch = [Object(_micro__WEBPACK_IMPORTED_MODULE_7__["arraysEq"])(sample(195, 300 - 20), [0, 0, 255, 255]), Object(_micro__WEBPACK_IMPORTED_MODULE_7__["arraysEq"])(sample(195, 300 - 48), [0, 255, 0, 255]), Object(_micro__WEBPACK_IMPORTED_MODULE_7__["arraysEq"])(sample(195, 300 - 90), [0, 255, 255, 255]), Object(_micro__WEBPACK_IMPORTED_MODULE_7__["arraysEq"])(sample(195, 300 - 150), [255, 0, 0, 255]), Object(_micro__WEBPACK_IMPORTED_MODULE_7__["arraysEq"])(sample(195, 300 - 200), [255, 0, 255, 255]), Object(_micro__WEBPACK_IMPORTED_MODULE_7__["arraysEq"])(sample(195, 300 - 260), [255, 255, 0, 255]), Object(_micro__WEBPACK_IMPORTED_MODULE_7__["arraysEq"])(sample(195, 300 - 285), [255, 255, 255, 255]), Object(_micro__WEBPACK_IMPORTED_MODULE_7__["arraysEq"])(sample(145, 300 - 285), [0, 0, 0, 0])];

    if (colorMatch.some(function (e) {
      return e === false;
    })) {
      res.colorMatch = colorMatch; // the expected rendering is wrong so this webgl implementation is suspect.

      return res;
    }

    var err = gl.getError();

    if (err !== 0) {
      res.err = err;
    } else {
      res.pass = true;
    }
  } catch (e) {
    res.err = e.toString();
  } finally {
    console.timeEnd("glTest");
  }

  return res;
}

/***/ }),

/***/ "./src/gl/glu.mjs":
/*!************************!*\
  !*** ./src/gl/glu.mjs ***!
  \************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLU; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../log */ "./src/log.js");
/* harmony import */ var _plane_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plane.vert */ "./src/gl/plane.vert");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * glu: webgl helpers
 *
 * Copyright (c) 2018 Cameron Beccario
 */




var log = Object(_log__WEBPACK_IMPORTED_MODULE_2__["default"])(); // see http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
//     http://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html

function throwOnErr(msg) {
  throw new Error(msg);
}

var GLU =
/*#__PURE__*/
function () {
  function GLU() {
    _classCallCheck(this, GLU);
  }

  _createClass(GLU, null, [{
    key: "getWebGL",

    /**
     * @param {HTMLCanvasElement} canvas DOM element
     * @param {Object} [attributes] WebGL context attributes
     * @returns {WebGLRenderingContext} the context or undefined if not supported.
     */
    value: function getWebGL(canvas, attributes) {
      var gl;

      try {
        gl = canvas.getContext("webgl", attributes);
      } catch (ignore) {}

      if (!gl) {
        try {
          gl = canvas.getContext("experimental-webgl", attributes);
        } catch (ignore) {}
      }

      return gl || undefined;
    }
    /** @returns {string} */

  }, {
    key: "planeVertexShader",
    value: function planeVertexShader() {
      return _plane_vert__WEBPACK_IMPORTED_MODULE_3__;
    }
  }, {
    key: "unitPlaneAttributes",
    value: function unitPlaneAttributes() {
      return {
        a_Position: new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),
        a_TexCoord: new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1])
      };
    }
    /**
     * @param {WebGLRenderingContext} gl
     * @param {Function} [ƒerr] ƒ(err) invoked when an error occurs (default is to throw).
     * @returns {GLUStick}
     */

  }, {
    key: "attach",
    value: function attach(gl) {
      var ƒerr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : throwOnErr;
      var defaultPixelStore = {
        PACK_ALIGNMENT: 1,
        UNPACK_ALIGNMENT: 1,
        UNPACK_FLIP_Y_WEBGL: false,
        UNPACK_PREMULTIPLY_ALPHA_WEBGL: false,
        UNPACK_COLORSPACE_CONVERSION_WEBGL: gl.BROWSER_DEFAULT_WEBGL
      };
      var defaultPixelStoreKeys = Object.keys(defaultPixelStore);
      var defaultTexParams = {
        TEXTURE_MIN_FILTER: gl.NEAREST,
        TEXTURE_MAG_FILTER: gl.NEAREST,
        TEXTURE_WRAP_S: gl.CLAMP_TO_EDGE,
        TEXTURE_WRAP_T: gl.CLAMP_TO_EDGE
      };
      var defaultTexParamKeys = Object.keys(defaultTexParams);

      function check(tag) {
        var num = gl.getError();

        if (num) {
          ƒerr("".concat(num, ":").concat(tag));
        }
      }

      return new (
      /*#__PURE__*/
      function () {
        function GLUStick() {
          _classCallCheck(this, GLUStick);
        }

        _createClass(GLUStick, [{
          key: "makePlaneVertexShader",

          /** @returns {WebGLShader} */
          value: function makePlaneVertexShader() {
            return this.makeShader(gl.VERTEX_SHADER, _plane_vert__WEBPACK_IMPORTED_MODULE_3__);
          }
        }, {
          key: "unitPlaneAttributes",
          value: function unitPlaneAttributes() {
            return {
              a_Position: new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),
              a_TexCoord: new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1])
            };
          }
          /**
           * @param {number} type either VERTEX_SHADER or FRAGMENT_SHADER.
           * @param {string} source shader source code.
           * @returns {WebGLShader} the shader object, or null if the shader could not be compiled.
           */

        }, {
          key: "makeShader",
          value: function makeShader(type, source) {
            var shader = gl.createShader(type);
            check("createShader:".concat(type));
            gl.shaderSource(shader, source);
            check("shaderSource:".concat(type));
            gl.compileShader(shader);
            check("compileShader:".concat(type));
            var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            check("getShaderParameter:".concat(type));

            if (!status) {
              var message = gl.getShaderInfoLog(shader);
              check("getShaderInfoLog:".concat(type));
              gl.deleteShader(shader);
              check("deleteShader:".concat(type));
              ƒerr(message);
              return null;
            }

            return shader;
          }
          /**
           * @param {WebGLShader[]} shaders the compiled shaders.
           * @returns {WebGLProgram} the program, or null if the program could not be linked.
           */

        }, {
          key: "makeProgram",
          value: function makeProgram(shaders) {
            var program = gl.createProgram();
            check("createProgram");
            shaders.forEach(function (shader) {
              gl.attachShader(program, shader);
              check("attachShader");
            });
            gl.linkProgram(program);
            check("linkProgram");
            var status = gl.getProgramParameter(program, gl.LINK_STATUS);
            check("getProgramParameter");

            if (!status) {
              var message = gl.getProgramInfoLog(program);
              check("getProgramInfoLog");
              gl.deleteProgram(program);
              check("deleteProgram");
              ƒerr(message);
              return null;
            }

            return program;
          }
          /**
           * @param {WebGLTexture} texture 2d texture
           * @returns {WebGLFramebuffer} the framebuffer, or null if the framebuffer is not complete.
           */

        }, {
          key: "makeFramebufferTexture2D",
          value: function makeFramebufferTexture2D(texture) {
            var framebuffer = gl.createFramebuffer();
            check("createFramebuffer");
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            check("bindFramebuffer");
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            check("framebufferTexture2D");
            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            check("checkFramebufferStatus");

            if (status !== gl.FRAMEBUFFER_COMPLETE) {
              gl.deleteFramebuffer(framebuffer);
              check("deleteFramebuffer");
              callback("framebuffer: " + status);
              return null;
            }

            return framebuffer;
          }
          /**
           * @param {WebGLProgram} program
           * @param {Object} textures map from name to texture entry
           * @returns {GLUUniforms}
           */

        }, {
          key: "uniforms",
          value: function uniforms(program, textures) {
            var _decls = {};
            var count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
            check("getProgramParameter");

            underscore__WEBPACK_IMPORTED_MODULE_0__.range(count).map(function (i) {
              var x = gl.getActiveUniform(program, i);
              check("getActiveUniform:".concat(i));
              return x;
            }).filter(function (e) {
              return !!e;
            }).forEach(function (e) {
              var location = gl.getUniformLocation(program, e.name);
              check("getUniformLocation:".concat(e.name));
              _decls[e.name] = {
                name: e.name,
                type: e.type,
                size: e.size,
                location: location
              };
            });

            function assign(name, v) {
              var decl = _decls[name] || {},
                  loc = decl.location; // log.debug(`uniform ${name}: ${v}`);

              switch (decl.type) {
                case gl.FLOAT:
                  return _micro__WEBPACK_IMPORTED_MODULE_1__["isArrayLike"](v) ? gl.uniform1fv(loc, v) : gl.uniform1f(loc, v);

                case gl.FLOAT_VEC2:
                  return gl.uniform2fv(loc, v);

                case gl.FLOAT_VEC3:
                  return gl.uniform3fv(loc, v);

                case gl.FLOAT_VEC4:
                  return gl.uniform4fv(loc, v);

                case gl.INT:
                  return _micro__WEBPACK_IMPORTED_MODULE_1__["isArrayLike"](v) ? gl.uniform1iv(loc, v) : gl.uniform1i(loc, v);

                case gl.INT_VEC2:
                  return gl.uniform2iv(loc, v);

                case gl.INT_VEC3:
                  return gl.uniform3iv(loc, v);

                case gl.INT_VEC4:
                  return gl.uniform4iv(loc, v);

                case gl.SAMPLER_2D:
                  {
                    var entry = textures[v];

                    if (!entry) {
                      log.warn("uniform '".concat(name, "' refers to unknown texture '").concat(v, "'"));
                      return;
                    }

                    gl.uniform1i(loc, entry.unit);
                    return;
                  }

                default:
                  log.warn("uniform '".concat(name, "' has unsupported type: ").concat(JSON.stringify(decl)));
              }
            }

            return new (
            /*#__PURE__*/
            function () {
              function GLUUniforms() {
                _classCallCheck(this, GLUUniforms);
              }

              _createClass(GLUUniforms, [{
                key: "decls",
                value: function decls() {
                  return _decls;
                }
                /**
                 * @param values an object {name: value, ...} where value is a number, array, or an object
                 *        {unit: i, texture: t} for binding a texture to a unit and sampler2D.
                 * @returns {GLUUniforms} this
                 */

              }, {
                key: "set",
                value: function set(values) {
                  Object.keys(values).forEach(function (name) {
                    assign(name, values[name]);
                    check("assign-uniform:".concat(name));
                  });
                  return this;
                }
              }]);

              return GLUUniforms;
            }())();
          }
          /**
           * @param {WebGLProgram} program
           * @returns {GLUAttribs}
           */

        }, {
          key: "attribs",
          value: function attribs(program) {
            var _decls2 = {};
            var count = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
            check("getProgramParameter");

            underscore__WEBPACK_IMPORTED_MODULE_0__.range(count).map(function (i) {
              var x = gl.getActiveAttrib(program, i);
              check("getActiveAttrib:".concat(i));
              return x;
            }).filter(function (e) {
              return !!e;
            }).forEach(function (e) {
              var location = gl.getAttribLocation(program, e.name);
              check("getAttribLocation:".concat(e.name));
              _decls2[e.name] = {
                name: e.name,
                type: e.type,
                size: e.size,
                location: location
              };
            });

            function assign(name, data) {
              var decl = _decls2[name] || {},
                  loc = decl.location;

              switch (decl.type) {
                case gl.FLOAT_VEC2:
                  var buffer = gl.createBuffer();
                  check("createBuffer:".concat(name));
                  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                  check("bindBuffer:".concat(name));
                  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
                  check("bufferData:".concat(name));
                  gl.enableVertexAttribArray(loc);
                  check("enableVertexAttribArray:".concat(name));
                  return gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

                default:
                  log.warn("attribute '".concat(name, "' has unsupported type: ").concat(JSON.stringify(decl)));
              }
            }

            return new (
            /*#__PURE__*/
            function () {
              function GLUAttribs() {
                _classCallCheck(this, GLUAttribs);
              }

              _createClass(GLUAttribs, [{
                key: "decls",
                value: function decls() {
                  return _decls2;
                }
                /**
                 * @param values an object {name: value, ...} where value is an array.
                 * @returns {GLUAttribs} this
                 */

              }, {
                key: "set",
                value: function set(values) {
                  Object.keys(values).forEach(function (name) {
                    assign(name, values[name]);
                    check("assign-attrib:".concat(name));
                  });
                  return this;
                }
              }]);

              return GLUAttribs;
            }())();
          }
          /**
           * @param {Object} def texture definition
           * @returns {WebGLTexture}
           */

        }, {
          key: "makeTexture2D",
          value: function makeTexture2D(def) {
            var texture = gl.createTexture();
            check("createTexture");
            gl.activeTexture(gl.TEXTURE0);
            check("activeTexture");
            gl.bindTexture(gl.TEXTURE_2D, texture);
            check("bindTexture");
            var opt = _micro__WEBPACK_IMPORTED_MODULE_1__["assign"]({}, defaultPixelStore, defaultTexParams, def);
            var format = opt.format,
                type = opt.type,
                width = opt.width,
                height = opt.height,
                data = opt.data;
            defaultPixelStoreKeys.forEach(function (key) {
              gl.pixelStorei(gl[key], opt[key]);
              check("pixelStorei:".concat(key));
            });
            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, data);
            check("texImage2D");
            defaultTexParamKeys.forEach(function (key) {
              gl.texParameteri(gl.TEXTURE_2D, gl[key], opt[key]);
              check("texParameteri:".concat(key));
            });
            gl.bindTexture(gl.TEXTURE_2D, null);
            check("bindTexture");
            return texture;
          }
          /**
           * @param {WebGLTexture} texture
           * @param {Object} def texture definition
           */

        }, {
          key: "updateTexture2D",
          value: function updateTexture2D(texture, def) {
            gl.activeTexture(gl.TEXTURE0);
            check("activeTexture");
            gl.bindTexture(gl.TEXTURE_2D, texture);
            check("bindTexture");
            var opt = _micro__WEBPACK_IMPORTED_MODULE_1__["assign"]({}, defaultPixelStore, defaultTexParams, def);
            var format = opt.format,
                type = opt.type,
                width = opt.width,
                height = opt.height,
                data = opt.data;
            defaultPixelStoreKeys.forEach(function (key) {
              gl.pixelStorei(gl[key], opt[key]);
              check("pixelStorei:".concat(key));
            });
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, type, data);
            check("texSubImage2D");
            defaultTexParamKeys.forEach(function (key) {
              gl.texParameteri(gl.TEXTURE_2D, gl[key], opt[key]);
              check("texParameteri:".concat(key));
            });
            gl.bindTexture(gl.TEXTURE_2D, null);
            check("bindTexture");
            return texture;
          }
          /**
           * @param {WebGLTexture} texture
           * @param {Object} def texture definition
           * @param {Object} existing texture entry
           * @returns {boolean} true if a difference between def and existing was found and applied
           */

        }, {
          key: "updateTexture2DParams",
          value: function updateTexture2DParams(texture, def, existing) {
            var changed = false;

            for (var i = 0; i < defaultTexParamKeys.length; i++) {
              var key = defaultTexParamKeys[i];
              var defaultValue = defaultTexParams[key];
              var newValue = def[key] || defaultValue;
              var oldValue = existing[key] || defaultValue;

              if (newValue !== oldValue) {
                if (!changed) {
                  changed = true;
                  gl.activeTexture(gl.TEXTURE0);
                  check("activeTexture");
                  gl.bindTexture(gl.TEXTURE_2D, texture);
                  check("bindTexture");
                }

                gl.texParameteri(gl.TEXTURE_2D, gl[key], newValue);
                check("texParameteri:".concat(key));
              }
            }

            if (changed) {
              gl.bindTexture(gl.TEXTURE_2D, null);
              check("bindTexture");
            }

            return changed;
          }
        }, {
          key: "context",

          /** @returns {WebGLRenderingContext} */
          get: function get() {
            return gl;
          }
        }]);

        return GLUStick;
      }())();
    }
  }]);

  return GLU;
}();



/***/ }),

/***/ "./src/gl/header.frag":
/*!****************************!*\
  !*** ./src/gl/header.frag ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nprecision highp sampler2D;\n\nconst float TAU = 6.283185307179586;\nconst float PI = 3.141592653589793;\n"

/***/ }),

/***/ "./src/gl/main.frag":
/*!**************************!*\
  !*** ./src/gl/main.frag ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform float u_Detail;\n\nvoid main() {\n    vec2 coord = invert(gl_FragCoord.xy / u_Detail);\n    vec2 st = grid(coord);\n    float v = lookup(st);\n    lowp vec4 color = colorize(v);\n    gl_FragColor = color;\n}\n"

/***/ }),

/***/ "./src/gl/plane.vert":
/*!***************************!*\
  !*** ./src/gl/plane.vert ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nattribute vec2 a_Position;\nattribute vec2 a_TexCoord;\n\nvarying vec2 v_TexCoord;\n\nvoid main() {\n    gl_Position = vec4(a_Position, 0.0, 1.0);\n    v_TexCoord = a_TexCoord;\n}\n"

/***/ }),

/***/ "./src/globes.mjs":
/*!************************!*\
  !*** ./src/globes.mjs ***!
  \************************/
/*! exports provided: atlantis, conic_equidistant, equirectangular, orthographic, patterson, stereographic, waterman, winkel3 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atlantis", function() { return atlantis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conic_equidistant", function() { return conic_equidistant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equirectangular", function() { return equirectangular; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orthographic", function() { return orthographic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "patterson", function() { return patterson; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stereographic", function() { return stereographic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waterman", function() { return waterman; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "winkel3", function() { return winkel3; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts */ "./src/consts.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./d3 */ "./src/d3.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./src/math.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./micro */ "./src/micro.mjs");
/* harmony import */ var _projection_orthographic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./projection/orthographic */ "./src/projection/orthographic.mjs");
/* harmony import */ var _canvas_twod__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./canvas/twod */ "./src/canvas/twod.mjs");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * globes - a set of models of the earth, each having their own kind of projection and onscreen behavior.
 *
 * Copyright (c) 2018 Cameron Beccario
 *
 * For a free version of this project, see https://github.com/cambecc/earth
 */







/**
 * @returns {Array} rotation of globe to current position of the user. Aside from asking for geolocation,
 *          which user may reject, there is not much available except timezone. Better than nothing.
 */

function currentPosition() {
  var λ = Object(_math__WEBPACK_IMPORTED_MODULE_3__["floorMod"])(new Date().getTimezoneOffset() / 4, 360); // 24 hours * 60 min / 4 === 360 degrees

  return [λ, 0];
}

function ensureNumber(num, fallback) {
  return underscore__WEBPACK_IMPORTED_MODULE_1__.isFinite(num) || num === Infinity || num === -Infinity ? num : fallback;
}
/**
 * @param bounds the projection bounds: [[x0, y0], [x1, y1]]
 * @param view the view bounds {width:, height:}
 * @returns {Object} the projection bounds clamped to the specified view.
 */


function clampedBounds(bounds, view) {
  var upperLeft = bounds[0];
  var lowerRight = bounds[1];
  var x = Math.max(Math.floor(ensureNumber(upperLeft[0], 0)), 0);
  var y = Math.max(Math.floor(ensureNumber(upperLeft[1], 0)), 0);
  var xMax = Math.min(Math.ceil(ensureNumber(lowerRight[0], view.width)), view.width - 1);
  var yMax = Math.min(Math.ceil(ensureNumber(lowerRight[1], view.height)), view.height - 1);
  return {
    x: x,
    y: y,
    xMax: xMax,
    yMax: yMax,
    width: xMax - x + 1,
    height: yMax - y + 1
  };
}

function fitProjection(proj, view) {
  var bounds = _d3__WEBPACK_IMPORTED_MODULE_2__["geoPath"]().projection(proj).bounds({
    type: "Sphere"
  });
  var hScale = (bounds[1][0] - bounds[0][0]) / proj.scale();
  var vScale = (bounds[1][1] - bounds[0][1]) / proj.scale();
  var fit = Math.min(view.width / hScale, view.height / vScale) * 0.9;
  var center = [view.width / 2, view.height / 2];
  return proj.scale(fit).translate(center);
}
/**
 * Returns a globe object with standard behavior. At least the newProjection method must be overridden to
 * be functional.
 */


function standardGlobe() {
  return {
    /**
     * This globe's current D3 projection.
     */
    projection: null,

    /**
     * @param view the size of the view as {width:, height:}.
     * @returns {Object} a new D3 projection of this globe appropriate for the specified view port.
     */
    newProjection: function newProjection(view) {
      throw new Error("method must be overridden");
    },

    /**
     * Hand-optimized projection if available, otherwise the normal d3 projection.
     */
    optimizedProjection: function optimizedProjection() {
      return this.projection;
    },

    /**
     * @param view the size of the view as {width:, height:}.
     * @returns {{x: Number, y: Number, xMax: Number, yMax: Number, width: Number, height: Number}}
     *          the bounds of the current projection clamped to the specified view.
     */
    bounds: function bounds(view) {
      return clampedBounds(_d3__WEBPACK_IMPORTED_MODULE_2__["geoPath"]().projection(this.projection).bounds({
        type: "Sphere"
      }), view);
    },

    /**
     * @param view the size of the view as {width:, height:}.
     * @returns {Number} the projection scale at which the entire globe fits within the specified view.
     */
    fit: function fit(view) {
      if (_micro__WEBPACK_IMPORTED_MODULE_4__["isEmbeddedInIFrame"]() && _micro__WEBPACK_IMPORTED_MODULE_4__["siteInstance"]() === "tara") {
        return 700; // HACK: to get things the right size in the iframe.
      }

      return this.newProjection(view).scale();
    },

    /**
     * @param view the size of the view as {width:, height:}.
     * @returns {Array} the projection transform at which the globe is centered within the specified view.
     */
    center: function center(view) {
      return [view.width / 2, view.height / 2];
    },

    /**
     * @returns {Array} the range at which this globe can be zoomed.
     */
    scaleExtent: function scaleExtent() {
      return [25, 3000];
    },

    /**
     * Returns the current orientation of this globe as a string. If the arguments are specified,
     * mutates this globe to match the specified orientation string, usually in the form "lat,lon,scale".
     *
     * @param [o] the orientation string
     * @param [view] the size of the view as {width:, height:}.
     */
    orientation: function orientation(o, view) {
      var projection = this.projection,
          rotate = projection.rotate();

      if (view) {
        var parts = underscore__WEBPACK_IMPORTED_MODULE_1__.isString(o) ? o.split(",") : [];
        var λ = +parts[0],
            φ = +parts[1],
            scale = +parts[2];
        var extent = this.scaleExtent();
        projection.rotate(underscore__WEBPACK_IMPORTED_MODULE_1__.isFinite(λ) && underscore__WEBPACK_IMPORTED_MODULE_1__.isFinite(φ) ? [-λ, -φ, rotate[2]] : this.newProjection(view).rotate());
        projection.scale(underscore__WEBPACK_IMPORTED_MODULE_1__.isFinite(scale) ? Object(_math__WEBPACK_IMPORTED_MODULE_3__["clamp"])(scale, extent[0], extent[1]) : this.fit(view));
        projection.translate(this.center(view));
        return this;
      }

      return [(-rotate[0]).toFixed(2), (-rotate[1]).toFixed(2), Math.round(projection.scale())].join(",");
    },

    /**
     * Returns an object that mutates this globe's current projection during a drag/zoom operation.
     * Each drag/zoom event invokes the move() method, and when the move is complete, the end() method
     * is invoked.
     *
     * @param startMouse starting mouse position.
     * @param startScale starting scale.
     */
    manipulator: function manipulator(startMouse, startScale) {
      var projection = this.projection;
      var sensitivity = 60 / startScale; // seems to provide a good drag scaling factor

      var rotation = [projection.rotate()[0] / sensitivity, -projection.rotate()[1] / sensitivity];
      var original = projection.precision();
      projection.precision(original * 10);
      return {
        move: function move(mouse, scale) {
          if (mouse) {
            var xd = mouse[0] - startMouse[0] + rotation[0];
            var yd = mouse[1] - startMouse[1] + rotation[1];
            projection.rotate([xd * sensitivity, -yd * sensitivity, projection.rotate()[2]]);
          }

          projection.scale(scale);
        },
        end: function end() {
          projection.precision(original);
        }
      };
    },

    /**
     * @returns {Array} the transform to apply, if any, to orient this globe to the specified coordinates.
     */
    locate: function locate(coord) {
      return null;
    },

    /**
     * Draws a polygon on the specified context of this globe's boundary.
     * @param context a Canvas element's 2d context.
     * @returns the context
     */
    defineMask: function defineMask(context) {
      _d3__WEBPACK_IMPORTED_MODULE_2__["geoPath"]().projection(this.projection).context(context)({
        type: "Sphere"
      });
      return context;
    },
    backgroundRenderer: function backgroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {
          context.fillStyle = "#303030";
          context.beginPath();
          path({
            type: "Sphere"
          });
          context.fill();
        }
      };
    },
    graticuleRenderer: function graticuleRenderer() {
      var graticuleMesh = _d3__WEBPACK_IMPORTED_MODULE_2__["geoGraticule"]()();
      var hemisphereMesh = _d3__WEBPACK_IMPORTED_MODULE_2__["geoGraticule"]().extentMinor([[0, 0], [0, 0]]).stepMajor([0, 90])();
      var graticule = _canvas_twod__WEBPACK_IMPORTED_MODULE_6__["makeStrokeRenderer"](graticuleMesh, {
        strokeStyle: "#505050",
        lineWidth: 1
      });
      var hemisphere = _canvas_twod__WEBPACK_IMPORTED_MODULE_6__["makeStrokeRenderer"](hemisphereMesh, {
        strokeStyle: "#808080",
        lineWidth: 1
      });
      return {
        renderTo: function renderTo(context, path) {
          graticule.renderTo(context, path);
          hemisphere.renderTo(context, path);
        }
      };
    },
    foregroundRenderer: function foregroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {
          context.strokeStyle = "#000005";
          context.lineWidth = 4;
          context.beginPath();
          path({
            type: "Sphere"
          });
          context.stroke();
        }
      };
    }
  };
}

function newGlobe(source, view) {
  var result = _micro__WEBPACK_IMPORTED_MODULE_4__["assign"](standardGlobe(), source);
  result.projection = result.newProjection(view);
  return result;
} // ============================================================================================


function atlantis(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoMollweide"]().rotate([30, -45, 90]).precision(0.1), view);
    }
  }, view);
}
function conic_equidistant(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoConicEquidistant"]().rotate(currentPosition()).precision(0.1), view);
    }
  }, view);
}
function equirectangular(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoEquirectangular"]().rotate(currentPosition()).precision(0.1), view);
    }
  }, view);
}
function orthographic(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoOrthographic"]().rotate(currentPosition()).precision(0.1).clipAngle(90), view);
    },
    optimizedProjection: function optimizedProjection() {
      return _projection_orthographic__WEBPACK_IMPORTED_MODULE_5__["default"].fromD3(this.projection);
    },
    backgroundRenderer: function backgroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {
          var proj = path.projection(),
              _proj$translate = proj.translate(),
              _proj$translate2 = _slicedToArray(_proj$translate, 2),
              x = _proj$translate2[0],
              y = _proj$translate2[1],
              scale = proj.scale();

          var gradient = context.createRadialGradient(x, y, 0, x, y, scale);
          gradient.addColorStop(0.69, "#303030");
          gradient.addColorStop(0.91, "#202020");
          gradient.addColorStop(0.96, "#000005");
          context.fillStyle = gradient;
          context.fillRect(x - scale, y - scale, scale * 2, scale * 2);
        }
      };
    },
    foregroundRenderer: function foregroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {
          var proj = path.projection(),
              _proj$translate3 = proj.translate(),
              _proj$translate4 = _slicedToArray(_proj$translate3, 2),
              x = _proj$translate4[0],
              y = _proj$translate4[1],
              scale = proj.scale();

          context.fillStyle = "#000005";
          context.beginPath();
          context.arc(x, y, scale - 2, 0, _consts__WEBPACK_IMPORTED_MODULE_0__["τ"], true);
          context.arc(x, y, scale + 4, 0, _consts__WEBPACK_IMPORTED_MODULE_0__["τ"], true);
          context.fill("evenodd");
        }
      };
    },
    locate: function locate(coord) {
      return [-coord[0], -coord[1], this.projection.rotate()[2]];
    }
  }, view);
}
function patterson(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoPatterson"]().precision(0.1), view);
    }
  }, view);
}
function stereographic(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoStereographic"]().rotate([-43, -20]).precision(1.0).clipAngle(180 - 0.0001).clipExtent([[0, 0], [view.width, view.height]]), view);
    },
    foregroundRenderer: function foregroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {// no foreground because always fullscreen
        }
      };
    }
  }, view);
}
function waterman(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoPolyhedralWaterman"]().rotate([20, 0]).precision(0.1), view);
    },
    foregroundRenderer: function foregroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {
          var _context$canvas = context.canvas,
              width = _context$canvas.width,
              height = _context$canvas.height;
          context.fillStyle = context.strokeStyle = "#000005";
          context.lineWidth = 4;
          context.beginPath();
          path({
            type: "Sphere"
          });
          context.stroke();
          context.moveTo(0, 0);
          context.lineTo(width, 0);
          context.lineTo(width, height);
          context.lineTo(0, height);
          context.lineTo(0, 0);
          context.fill("evenodd");
        }
      };
    }
  }, view);
}
function winkel3(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoWinkel3"]().precision(0.1), view);
    }
  }, view);
}

/***/ }),

/***/ "./src/grid/regular.frag":
/*!*******************************!*\
  !*** ./src/grid/regular.frag ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform vec2 u_Low;\nuniform vec2 u_Size;\n\nvec2 grid(in vec2 coord) {\n    vec2 tex = (coord - u_Low) / u_Size;\n    float s = tex.s;\n    float t = tex.t;\n\n    if (t < 0.0 || 1.0 < t) discard;  // lat out of bounds, so nothing to draw\n\n    return vec2(fract(s), t);  // UNDONE: fract used here only because lon is circular.\n}\n"

/***/ }),

/***/ "./src/grid/regular.mjs":
/*!******************************!*\
  !*** ./src/grid/regular.mjs ***!
  \******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return regularGrid; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../consts */ "./src/consts.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./src/math.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _regular_frag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./regular.frag */ "./src/grid/regular.frag");
// https://en.wikipedia.org/wiki/Regular_grid




/**
 * Creates a regular geographic grid. Each axis defines the "start" value in degrees, "delta" degrees between
 * ticks, and the "size" (number of ticks from the origin, inclusive). Positive deltas move eastward/northward. This
 * example creates a full 1° x 1° grid covering the earth starting at the south pole:
 *
 *     λaxis: {start: 0, delta: 1, size: 360}    where λ in the range [0, 359]
 *     φaxis: {start: -90, delta: 1, size: 181}  where φ in the range [-90, 90]
 *
 * A grid maps from [λ, φ] coordinates to grid point indices.
 *
 * @param λaxis longitude axis
 * @param φaxis latitude axis
 * @returns {*}
 */

function regularGrid(λaxis, φaxis) {
  var nx = Math.floor(λaxis.size); // number of lon points

  var ny = Math.floor(φaxis.size); // number of lat points

  var np = nx * ny; // total number of points

  var Δλ = _micro__WEBPACK_IMPORTED_MODULE_2__["decimalize"](λaxis.delta); // distance between lon points

  var Δφ = _micro__WEBPACK_IMPORTED_MODULE_2__["decimalize"](φaxis.delta); // distance between lat points

  var λ0 = _micro__WEBPACK_IMPORTED_MODULE_2__["decimalize"](λaxis.start); // lon origin

  var φ0 = _micro__WEBPACK_IMPORTED_MODULE_2__["decimalize"](φaxis.start); // lat origin, expected to be on range [-90, 90]

  var λ1 = λ0 + Δλ * (nx - 1); // lon upper bound

  var φ1 = φ0 + Δφ * (ny - 1); // lat upper bound

  var λlow = (λ0 - Δλ / 2) * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
  var λhigh = (λ1 + Δλ / 2) * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
  var λsize = λhigh - λlow;
  var φlow = (φ0 - Δφ / 2) * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
  var φhigh = (φ1 + Δφ / 2) * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
  var φsize = φhigh - φlow;
  var low = [λlow, φlow];
  var size = [λsize, φsize];
  var isCylinder = Math.floor(nx * Δλ) >= 360; // true if the grid forms a cylinder
  //function iterator() {
  //    const i = 0;
  //    return {
  //        next: function() {
  //            if (i >= np) {
  //                return {done: true};
  //            }
  //            const x = i % nx;
  //            const y = Math.floor(i / nx);
  //            const λ = λ0 + x * Δλ;
  //            const φ = φ0 + y * Δφ;
  //            return {value: [λ, φ, i++], done: false};
  //        },
  //    };
  //}

  /** @returns {{width: number, height: number}} dimensions of this grid */

  function dimensions() {
    return {
      width: nx,
      height: ny
    };
  }
  /** @returns {boolean} true if the grid fully wraps around longitudinal axis */


  function isCylindrical() {
    return isCylinder;
  }
  /**
   * @param {Function} cb the callback ƒ(λ, φ, i), where a truthy return value terminates the iteration.
   * @param {number?} start the starting grid index.
   * @returns {number} the grid index of the next iteration, or NaN if iteration is finished.
   */


  function forEach(cb, start) {
    for (var i = start || 0; i < np; i++) {
      var x = i % nx;
      var y = Math.floor(i / nx);
      var λ = λ0 + x * Δλ;
      var φ = φ0 + y * Δφ;

      if (cb(λ, φ, i)) {
        return i + 1; // Terminate iteration and return next grid index.
      }
    }

    return NaN; // Iteration is finished.
  }
  /**
   * @param {number[]} coord [λ, φ] in degrees
   * @returns {number} index of closest grid point or NaN if further than Δλ/2 or Δφ/2 from the grid boundary.
   */


  function closest(coord) {
    var λ = coord[0];
    var φ = coord[1];

    if (λ === λ && φ === φ) {
      var x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floorMod"])(λ - λ0, 360) / Δλ;
      var y = (φ - φ0) / Δφ;
      var rx = Math.round(x);
      var ry = Math.round(y);

      if (0 <= ry && ry < ny && 0 <= rx && (rx < nx || rx === nx && isCylinder)) {
        var i = ry * nx + rx;
        return rx === nx ? i - nx : i;
      }
    }

    return NaN;
  }
  /**
   * Identifies the four points surrounding the specified coordinates. The result is a six-element array:
   *
   *     0-3: the indices of the four points, in increasing order.
   *     4,5: the fraction that λ,φ is away from the first point, normalized to the range [0, 1].
   *
   * Example:
   * <pre>
   *          1      2           After converting λ and φ to positions on the x and y grid axes, we find the
   *         fx  x   cx          four points that enclose point [x, y]. These points are at the four
   *          | =1.4 |           corners specified by the floor and ceiling of x and y. For example, given
   *       --i00-|--i10-- fy 8   x = 1.4 and y = 8.3, the four surrounding grid points are [1, 8], [2, 8],
   *     y ___|_ .   |           [1, 9] and [2, 9]. These points have index i00, i10, i01, i11, respectively,
   *   =8.3   |      |           and result of this function is an array [i00, i10, i01, i11, 0.4, 0.3].
   *       --i01----i11-- cy 9
   *          |      |
   * </pre>
   *
   * @param {number[]} coord [λ, φ] in degrees
   * @returns {number[]} the indices of the four grid points surrounding the coordinate pair and the (x,y) fraction,
   *          or [NaN, NaN, NaN, NaN, NaN, NaN] if all points are not found.
   */


  function closest4(coord) {
    var λ = coord[0];
    var φ = coord[1];

    if (λ === λ && φ === φ) {
      var x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floorMod"])(λ - λ0, 360) / Δλ;
      var y = (φ - φ0) / Δφ;
      var fx = Math.floor(x);
      var fy = Math.floor(y);
      var cx = fx + 1;
      var cy = fy + 1;
      var Δx = x - fx;
      var Δy = y - fy;

      if (0 <= fy && cy < ny && 0 <= fx && (cx < nx || cx === nx && isCylinder)) {
        var i00 = fy * nx + fx;
        var i10 = i00 + 1;
        var i01 = i00 + nx;
        var i11 = i01 + 1;

        if (cx === nx) {
          i10 -= nx;
          i11 -= nx;
        }

        return [i00, i10, i01, i11, Δx, Δy];
      }
    }

    return [NaN, NaN, NaN, NaN, NaN, NaN];
  }

  function webgl() {
    return {
      shaderSource: function shaderSource() {
        return _regular_frag__WEBPACK_IMPORTED_MODULE_3__;
      },
      textures: function textures() {
        return {};
      },
      uniforms: function uniforms() {
        return {
          u_Low: low,
          u_Size: size
        };
      }
    };
  }

  return {
    dimensions: dimensions,
    isCylindrical: isCylindrical,
    forEach: forEach,
    closest: closest,
    closest4: closest4,
    webgl: webgl
  };
}

/***/ }),

/***/ "./src/interpolate/bilinear.mjs":
/*!**************************************!*\
  !*** ./src/interpolate/bilinear.mjs ***!
  \**************************************/
/*! exports provided: scalar, vector */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return scalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vector", function() { return vector; });
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _lookup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lookup */ "./src/interpolate/lookup.mjs");
/*
 * bilinear: a bilinear interpolator for scalar and vector fields that also handles triangles (3 points).
 */

 // import glReport from "../gl/glCheck";

/**
 * @param grid a grid that supports the "closest4" function.
 * @param {Float32Array} data backing data, the same length as the grid.
 * @returns {Function} a bilinear interpolation function f([λ, φ]) -> v
 */

function scalar(grid, data) {
  var hash = _micro__WEBPACK_IMPORTED_MODULE_0__["arrayHashCode"](data, 1000);
  /**
   * @param {number[]} coord [λ, φ] in degrees.
   * @returns {number} the bilinear interpolated value or 7e37 if none.
   */

  function bilinear(coord) {
    var indices = grid.closest4(coord);
    var i00 = indices[0];

    if (i00 === i00) {
      var i10 = indices[1];
      var i01 = indices[2];
      var i11 = indices[3];
      var x = indices[4];
      var y = indices[5];
      var rx = 1 - x;
      var ry = 1 - y;
      var v00 = data[i00];
      var v10 = data[i10];
      var v01 = data[i01];
      var v11 = data[i11];

      if (v00 < 7e37) {
        if (v10 < 7e37 && v01 < 7e37 && v11 < 7e37) {
          var a = rx * ry,
              b = x * ry,
              c = rx * y,
              d = x * y;
          return v00 * a + v10 * b + v01 * c + v11 * d; // 4 points found.
        } else if (v11 < 7e37 && v10 < 7e37 && x >= y) {
          return v10 + rx * (v00 - v10) + y * (v11 - v10); // 3 points found, triangle interpolate.
        } else if (v01 < 7e37 && v11 < 7e37 && x < y) {
          return v01 + x * (v11 - v01) + ry * (v00 - v01); // 3 points found, triangle interpolate.
        } else if (v01 < 7e37 && v10 < 7e37 && x <= ry) {
          return v00 + x * (v10 - v00) + y * (v01 - v00); // 3 points found, triangle interpolate.
        }
      } else if (v11 < 7e37 && v01 < 7e37 && v10 < 7e37 && x > ry) {
        return v11 + rx * (v01 - v11) + ry * (v10 - v11); // 3 points found, triangle interpolate.
      }
    }

    return 7e37;
  }
  /**
   * @param {GLUStick} glu
   */


  bilinear.webgl = function (glu) {
    var gl = glu.context;
    var useNative = false; // glReport.floatTexLinear && !grid.isCylindrical();

    var look = Object(_lookup__WEBPACK_IMPORTED_MODULE_1__["lookup"])(glu, grid.dimensions());

    var _grid$dimensions = grid.dimensions(),
        width = _grid$dimensions.width,
        height = _grid$dimensions.height,
        textureSize = [width, height];

    return {
      shaderSource: function shaderSource() {
        return [look.scalarSource(), useNative ? look.shaderSourceTexture2D() : look.shaderSourceBilinearWrap()];
      },
      textures: function textures() {
        return {
          weather_data: look.scalarTexture(data, {
            hash: hash,
            TEXTURE_MIN_FILTER: useNative ? gl.LINEAR : gl.NEAREST,
            TEXTURE_MAG_FILTER: useNative ? gl.LINEAR : gl.NEAREST
          })
        };
      },
      uniforms: function uniforms() {
        var result = {
          u_Data: "weather_data"
        };

        if (!useNative) {
          result.u_TextureSize = textureSize;
        }

        return result;
      }
    };
  };

  return bilinear;
}
/**
 * @param grid a grid that supports the "closest4" function.
 * @param {Float32Array|number[]} data backing data in [u0, v0, u1, v1, ...] layout, double the grid size.
 * @returns {Function} a bilinear interpolation function f([λ, φ]) -> [u, v, m]
 */

function vector(grid, data) {
  var hash = _micro__WEBPACK_IMPORTED_MODULE_0__["arrayHashCode"](data, 1000);

  function triangleInterpolateVector(x, y, u0, v0, u1, v1, u2, v2) {
    var u = u0 + x * (u2 - u0) + y * (u1 - u0);
    var v = v0 + x * (v2 - v0) + y * (v1 - v0);
    return [u, v, Math.sqrt(u * u + v * v)];
  }
  /**
   * @param {number[]} coord [λ, φ] in degrees.
   * @returns {number[]} the bilinear interpolated value as a vector [u, v, m] or [7e37, 7e37, 7e37] if none.
   */


  function bilinear(coord) {
    var indices = grid.closest4(coord);
    var j00 = indices[0] * 2;

    if (j00 === j00) {
      var j10 = indices[1] * 2;
      var j01 = indices[2] * 2;
      var j11 = indices[3] * 2;
      var x = indices[4];
      var y = indices[5];
      var rx = 1 - x;
      var ry = 1 - y;
      var u00 = data[j00];
      var v00 = data[j00 + 1];
      var u10 = data[j10];
      var v10 = data[j10 + 1];
      var u01 = data[j01];
      var v01 = data[j01 + 1];
      var u11 = data[j11];
      var v11 = data[j11 + 1];

      if (v00 < 7e37) {
        if (v10 < 7e37 && v01 < 7e37 && v11 < 7e37) {
          var a = rx * ry,
              b = x * ry,
              c = rx * y,
              d = x * y;
          var u = u00 * a + u10 * b + u01 * c + u11 * d;
          var v = v00 * a + v10 * b + v01 * c + v11 * d;
          return [u, v, Math.sqrt(u * u + v * v)]; // 4 points found.
        } else if (v11 < 7e37 && v10 < 7e37 && x >= y) {
          return triangleInterpolateVector(rx, y, u10, v10, u11, v11, u00, v00);
        } else if (v01 < 7e37 && v11 < 7e37 && x < y) {
          return triangleInterpolateVector(x, ry, u01, v01, u00, v00, u11, v11);
        } else if (v01 < 7e37 && v10 < 7e37 && x <= ry) {
          return triangleInterpolateVector(x, y, u00, v00, u01, v01, u10, v10);
        }
      } else if (v11 < 7e37 && v01 < 7e37 && v10 < 7e37 && x > ry) {
        return triangleInterpolateVector(rx, ry, u11, v11, u10, v10, u01, v01);
      }
    }

    return [7e37, 7e37, 7e37];
  }
  /**
   * @param {GLUStick} glu
   */


  bilinear.webgl = function (glu) {
    var gl = glu.context;
    var useNative = false; // glReport.floatTexLinear && !grid.isCylindrical();

    var look = Object(_lookup__WEBPACK_IMPORTED_MODULE_1__["lookup"])(glu, grid.dimensions());

    var _grid$dimensions2 = grid.dimensions(),
        width = _grid$dimensions2.width,
        height = _grid$dimensions2.height,
        textureSize = [width, height];

    return {
      shaderSource: function shaderSource() {
        return [look.vectorSource(), useNative ? look.shaderSourceTexture2D() : look.shaderSourceBilinearWrap()];
      },
      textures: function textures() {
        return {
          weather_data: look.vectorTexture(data, {
            hash: hash,
            TEXTURE_MIN_FILTER: useNative ? gl.LINEAR : gl.NEAREST,
            TEXTURE_MAG_FILTER: useNative ? gl.LINEAR : gl.NEAREST
          })
        };
      },
      uniforms: function uniforms() {
        var result = {
          u_Data: "weather_data"
        };

        if (!useNative) {
          result.u_TextureSize = textureSize;
        }

        return result;
      }
    };
  };

  return bilinear;
}

/***/ }),

/***/ "./src/interpolate/bilinearWrap.frag":
/*!*******************************************!*\
  !*** ./src/interpolate/bilinearWrap.frag ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform sampler2D u_Data;\nuniform vec2 u_TextureSize;\n\nvec4 getSample(in vec2 st) {\n    // Use of fract below assumes cylindrical x axis (usually lon) and non-cylindrical y axis (usually lat).\n    return texture2D(u_Data, vec2(fract(st.s), st.t));\n}\n\nfloat lookup(in vec2 st) {\n    // adapted from http://www.iquilezles.org/www/articles/hwinterpolation/hwinterpolation.htm\n    vec2 uv = st * u_TextureSize - 0.5;\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    vec2 ruv = 1.0 - fuv;\n\n    vec4 a = getSample((iuv + vec2(0.5, 0.5)) / u_TextureSize);  // LL\n    vec4 b = getSample((iuv + vec2(1.5, 0.5)) / u_TextureSize);  // LR\n    vec4 c = getSample((iuv + vec2(0.5, 1.5)) / u_TextureSize);  // UL\n    vec4 d = getSample((iuv + vec2(1.5, 1.5)) / u_TextureSize);  // UR\n    vec4 h;\n\n    int tag = int(dot(step(7e37, vec4(a.x, b.x, c.x, d.x)), vec4(1.0, 2.0, 4.0, 8.0)));\n    if (tag == 0) {\n        // a b c d\n        h = mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n    } else if (tag == 1 && ruv.y < fuv.x) {\n        // d b c\n        h = d + ruv.x * (c - d) + ruv.y * (b - d);\n    } else if (tag == 2 && fuv.x < fuv.y) {\n        // c a d\n        h = c + fuv.x * (d - c) + ruv.y * (a - c);\n    } else if (tag == 4 && fuv.x >= fuv.y) {\n        // b a d\n        h = b + ruv.x * (a - b) + fuv.y * (d - b);\n    } else if (tag == 8 && fuv.x <= ruv.y) {\n        // a b c\n        h = a + fuv.x * (b - a) + fuv.y * (c - a);\n    } else {\n        // not enough points to interpolate\n        h = vec4(7e37);\n    }\n\n    return scalarize(h);\n}\n"

/***/ }),

/***/ "./src/interpolate/lookup.mjs":
/*!************************************!*\
  !*** ./src/interpolate/lookup.mjs ***!
  \************************************/
/*! exports provided: lookup */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookup", function() { return lookup; });
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _texture2D_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texture2D.frag */ "./src/interpolate/texture2D.frag");
/* harmony import */ var _bilinearWrap_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bilinearWrap.frag */ "./src/interpolate/bilinearWrap.frag");
/* harmony import */ var _scalar_frag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scalar.frag */ "./src/interpolate/scalar.frag");
/* harmony import */ var _vector_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vector.frag */ "./src/interpolate/vector.frag");





/**
 *
 * @param {GLUStick} glu
 * @param dims
 * @returns {*}
 */

function lookup(glu, dims) {
  var gl = glu.context;
  var width = dims.width,
      height = dims.height;
  return {
    shaderSourceTexture2D: function shaderSourceTexture2D() {
      return _texture2D_frag__WEBPACK_IMPORTED_MODULE_1__;
    },
    shaderSourceBilinearWrap: function shaderSourceBilinearWrap() {
      return _bilinearWrap_frag__WEBPACK_IMPORTED_MODULE_2__;
    },
    scalarSource: function scalarSource() {
      return _scalar_frag__WEBPACK_IMPORTED_MODULE_3__;
    },
    vectorSource: function vectorSource() {
      return _vector_frag__WEBPACK_IMPORTED_MODULE_4__;
    },
    scalarTexture: function scalarTexture(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _micro__WEBPACK_IMPORTED_MODULE_0__["assign"]({
        format: gl.LUMINANCE,
        type: gl.FLOAT,
        width: width,
        height: height,
        data: data
      }, options);
    },
    vectorTexture: function vectorTexture(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _micro__WEBPACK_IMPORTED_MODULE_0__["assign"]({
        format: gl.LUMINANCE_ALPHA,
        type: gl.FLOAT,
        width: width,
        height: height,
        data: data
      }, options);
    }
  };
}

/***/ }),

/***/ "./src/interpolate/nearest.mjs":
/*!*************************************!*\
  !*** ./src/interpolate/nearest.mjs ***!
  \*************************************/
/*! exports provided: scalar, vector */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return scalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vector", function() { return vector; });
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _lookup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lookup */ "./src/interpolate/lookup.mjs");
/*
 * nearest: a nearest-neighbor interpolator for scalar and vector fields.
 */


/**
 * @param grid a grid that supports the "closest" function.
 * @param {Float32Array} data backing data, the same length as the grid.
 * @returns {Function} a nearest neighbor interpolation function f([λ, φ]) -> v
 */

function scalar(grid, data) {
  var hash = _micro__WEBPACK_IMPORTED_MODULE_0__["arrayHashCode"](data, 1000);
  /**
   * @param {number[]} coord [λ, φ] in degrees.
   * @returns {number} the nearest neighbor value or 7e37 if none.
   */

  function nearest(coord) {
    var i = grid.closest(coord);
    return i === i ? data[i] : 7e37;
  }
  /**
   * @param {GLUStick} glu
   */


  nearest.webgl = function (glu) {
    var gl = glu.context;
    var look = Object(_lookup__WEBPACK_IMPORTED_MODULE_1__["lookup"])(glu, grid.dimensions());
    return {
      shaderSource: function shaderSource() {
        return [look.scalarSource(), look.shaderSourceTexture2D()];
      },
      textures: function textures() {
        return {
          weather_data: look.scalarTexture(data, {
            hash: hash,
            TEXTURE_MIN_FILTER: gl.NEAREST,
            TEXTURE_MAG_FILTER: gl.NEAREST
          })
        };
      },
      uniforms: function uniforms() {
        return {
          u_Data: "weather_data"
        };
      }
    };
  };

  return nearest;
}
/**
 * @param grid a grid that supports the "closest" function.
 * @param {Float32Array|number[]} data backing data in [u0, v0, u1, v1, ...] layout, double the grid size.
 * @returns {Function} a nearest neighbor interpolation function f([λ, φ]) -> [u, v, m]
 */

function vector(grid, data) {
  var hash = _micro__WEBPACK_IMPORTED_MODULE_0__["arrayHashCode"](data, 1000);
  /**
   * @param {number[]} coord [λ, φ] in degrees.
   * @returns {number[]} the nearest neighbor value as a vector [u, v, m] or [7e37, 7e37, 7e37] if none.
   */

  function nearest(coord) {
    var j = grid.closest(coord) * 2;

    if (j === j) {
      var u = data[j],
          v = data[j + 1];

      if (u < 7e37 && v < 7e37) {
        return [u, v, Math.sqrt(u * u + v * v)];
      }
    }

    return [7e37, 7e37, 7e37];
  }
  /**
   * @param {GLUStick} glu
   */


  nearest.webgl = function (glu) {
    var gl = glu.context;
    var look = Object(_lookup__WEBPACK_IMPORTED_MODULE_1__["lookup"])(glu, grid.dimensions());
    return {
      shaderSource: function shaderSource() {
        return [look.vectorSource(), look.shaderSourceTexture2D()];
      },
      textures: function textures() {
        return {
          weather_data: look.vectorTexture(data, {
            hash: hash,
            TEXTURE_MIN_FILTER: gl.NEAREST,
            TEXTURE_MAG_FILTER: gl.NEAREST
          })
        };
      },
      uniforms: function uniforms() {
        return {
          u_Data: "weather_data"
        };
      }
    };
  };

  return nearest;
}

/***/ }),

/***/ "./src/interpolate/scalar.frag":
/*!*************************************!*\
  !*** ./src/interpolate/scalar.frag ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat scalarize(in vec4 h) {\n    return h.x;\n}\n"

/***/ }),

/***/ "./src/interpolate/texture2D.frag":
/*!****************************************!*\
  !*** ./src/interpolate/texture2D.frag ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform sampler2D u_Data;\n\nfloat lookup(in vec2 st) {\n    vec4 h = texture2D(u_Data, st);\n    return scalarize(h);\n}\n"

/***/ }),

/***/ "./src/interpolate/vector.frag":
/*!*************************************!*\
  !*** ./src/interpolate/vector.frag ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat scalarize(in vec4 h) {\n    float isMissing = step(7e37, h.x);\n    return length((1.0 - isMissing) * h.xw) + isMissing * 7e37;\n}\n"

/***/ }),

/***/ "./src/keyboard.mjs":
/*!**************************!*\
  !*** ./src/keyboard.mjs ***!
  \**************************/
/*! exports provided: key */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "key", function() { return key; });
/**
 * @param {string} type event type
 * @param {string} key the key property
 * @param {number} which the browser-specific numeric key code
 * @param {string} str the string representation of the numeric key code
 * @returns {string} the normalized 'key' value.
 */
function normalize(type, key, which, str) {
  if (key) {
    switch (key) {
      case "Esc":
        return "Escape";
    }

    return key; // Use the key property if it exists.
  }

  switch (which) {
    case 27:
      return "Escape";
  }

  if (type === "keypress" && str) {
    return str; // The string representation is acceptable for keypress events. For keyup and keydown, it is not.
  }

  return "NYI";
}
/**
 * @param {KeyboardEvent} event the keyboard keyup, keypress, or keydown event.
 * @return {string} the 'key' property of the event (or equivalent if not yet supported by the browser), or "NYI"
 *         if I haven't bothered to investigate cross browser behavior for the specific key.
 */


function key(event) {
  var type = event.type,
      key = event.key,
      which = +event.which,
      str = String.fromCharCode(which); //console.log("type", type, "key", key, "which", which, "str", str, " => ", normalize(type, key, which, str));

  return normalize(type, key, which, str);
}

/***/ }),

/***/ "./src/lang.mjs":
/*!**********************!*\
  !*** ./src/lang.mjs ***!
  \**********************/
/*! exports provided: preferred, parse, match, best */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preferred", function() { return preferred; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "match", function() { return match; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "best", function() { return best; });
function preferred(navigator) {
  return navigator.languages || [navigator.language || navigator.userLanguage || "en"];
}
/**
 * Parses an IETF language tag into pieces.
 *
 * {language: "zh", script: "Hans", region: "CN"}
 * {language: "en", script: "", region: "US"}
 * {language: "en", script: "", region: ""}
 * {language: "", script: "", region: ""}
 *
 * @param {string} tag
 */

function parse(tag) {
  var result = {
    language: "",
    script: "",
    region: ""
  },
      parts = (tag || "").toLowerCase().split("-");

  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];

    if (part.length === 1) {
      // stop parsing when we hit an extension
      break;
    }

    if (i === 0) {
      result.language = part;
    } else if (/^[a-z]{4}$/.test(part)) {
      result.script = part.substring(0, 1).toUpperCase() + part.substring(1);
    } else if (/^([a-z]{2}|\d{3})$/.test(part)) {
      result.region = part.toUpperCase();
    }
  }

  return result;
}
/**
 * Returns the most appropriate match for the specified language tag, or "" if none can be found.
 *
 * @param struct a parsed IETF language tag
 * @returns {string}
 */

function match(struct) {
  // $LANG$
  switch (struct.language) {
    case "en":
      return "en";

    case "cs":
      return "cs";

    case "fr":
      return "fr";

    case "ja":
      return "ja";

    case "pt":
      return "pt";

    case "ru":
      return "ru";

    case "zh":
      switch (struct.script) {
        case "Hant":
          return "zh-TW";

        case "Hans":
          return "zh-CN";
      }

      switch (struct.region) {
        case "HK":
        case "MO":
        case "TW":
          return "zh-TW";

        case "SG":
        case "CN":
          return "zh-CN";
      }

  }

  return "";
}
function best(navigator) {
  var preference = preferred(navigator);

  for (var i = 0; i < preference.length; i++) {
    var parsed = parse(preference[i]);
    var matched = match(parsed);
    if (matched) return matched;
  }

  return "";
}

/***/ }),

/***/ "./src/log.js":
/*!********************!*\
  !*** ./src/log.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {
/**
 * @param {Object?} console the object to handle log operations [default: global console]
 * @returns {{debug: *, info: *, warn: *, error: *, time: *, timeEnd: *}} a log object
 */

/* harmony default export */ __webpack_exports__["default"] = (function (console) {
  function extract(ref, f) {
    return typeof f === "function" ? f.bind(ref) : function () {};
  }

  console = console || global.console || {};
  return {
    debug: extract(console, console.log),
    info: extract(console, console.info),
    warn: extract(console, console.warn),
    error: extract(console, console.error),
    time: extract(console, console.time),
    timeEnd: extract(console, console.timeEnd)
  };
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfills */ "./src/polyfills.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./d3 */ "./src/d3.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./micro */ "./src/micro.mjs");
/* harmony import */ var _blacklist__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./blacklist */ "./src/blacklist.mjs");
/* harmony import */ var _earth__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./earth */ "./src/earth.mjs");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./log */ "./src/log.js");








 // import bridge from "./bridge";
// work-around for iOS 10 bug: https://github.com/metafizzy/flickity/issues/457

window.addEventListener("touchmove", function () {}); //require("./clock").calibration({server: "/"}); /*calibration({fixed: "2015-11-24T00:00Z"});*/

global.earth = _earth__WEBPACK_IMPORTED_MODULE_5__["default"];

global.main = function (bridge) {
  bridge = bridge || {};
  var log = Object(_log__WEBPACK_IMPORTED_MODULE_6__["default"])(bridge.console);
  var app = {
    log: log,
    bridge: bridge
  };

  if (_micro__WEBPACK_IMPORTED_MODULE_3__["isDevMode"]()) {
    log.debug("dev mode enabled");
  }

  underscore__WEBPACK_IMPORTED_MODULE_1___default.a.defer(_earth__WEBPACK_IMPORTED_MODULE_5__["default"], app); // defer all side effects

};

if (_micro__WEBPACK_IMPORTED_MODULE_3__["isEmbeddedInIFrame"]() && underscore__WEBPACK_IMPORTED_MODULE_1___default.a.isFunction(window.ga)) {
  window.ga("send", "event", "iframe", document.referrer.split("/")[2] || document.referrer);
}

if (_micro__WEBPACK_IMPORTED_MODULE_3__["isEmbeddedInIFrame"]() && _blacklist__WEBPACK_IMPORTED_MODULE_4__["contains"](document.referrer)) {
  _blacklist__WEBPACK_IMPORTED_MODULE_4__["deny"]();
} else if (_micro__WEBPACK_IMPORTED_MODULE_3__["isAppMode"]()) {
  _d3__WEBPACK_IMPORTED_MODULE_2__["select"]("#details").classed("invisible", true);
} else {
  // global.main(bridge);
  global.main();
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/math.mjs":
/*!**********************!*\
  !*** ./src/math.mjs ***!
  \**********************/
/*! exports provided: floorMod, rint, rintToMultiple, clamp, proportion, spread, length, distance, toCardinalDegrees */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floorMod", function() { return floorMod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rint", function() { return rint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rintToMultiple", function() { return rintToMultiple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "proportion", function() { return proportion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spread", function() { return spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toCardinalDegrees", function() { return toCardinalDegrees; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts */ "./src/consts.mjs");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


/**
 * @param {number} a
 * @param {number} n
 * @returns {number} remainder of floored division, i.e., floor(a / n). Useful for consistent modulo of negative
 *          numbers. See http://en.wikipedia.org/wiki/Modulo_operation.
 */

function floorMod(a, n) {
  var f = a - n * Math.floor(a / n); // hack: when a is within an ulp of n, f can be equal to n (because the subtraction has no effect). But the
  // result should be in the range [0, n), so check for this case. Example: floorMod(-1e-16, 10)

  return f === n ? 0 : f;
}
/**
 * Round to closest whole number using banker's rounding. From Java's Math.rint method.
 * @param {number} v
 * @returns {number} the value rounded half even
 */

function rint(v) {
  var x = Math.abs(v);

  if (x < TWOP52) {
    x += TWOP52;
    x -= TWOP52;
  }

  return Math.sign(v) * x;
}
var TWOP52 = Math.pow(2, 52);
/**
 * Round to the closest multiple using banker's rounding.
 * @param {number} v
 * @param {number} m the multiple
 * @returns {number} the value rounded to the nearest increment of m.
 */

function rintToMultiple(v, m) {
  return rint(v / m) * m;
}
/**
 * @param {number} x
 * @param {number} low
 * @param {number} high
 * @returns {number} the value x clamped to the range [low, high].
 */

function clamp(x, low, high) {
  return Math.max(low, Math.min(x, high));
}
/**
 * @param {number} x
 * @param {number} low the range lower bound, inclusive
 * @param {number} high the range higher bound, inclusive
 * @returns {number} the value x rescaled, but not clamped, to the unit scale (the range [0, 1] inclusive).
 */

function proportion(x, low, high) {
  return (x - low) / (high - low);
}
/**
 * @param {number} p a value on the unit scale
 * @param {number} low the range lower bound, inclusive
 * @param {number} high the range higher bound, inclusive
 * @returns {number} the unit scale value p rescaled, but not clamped, to the range [low, high] inclusive
 */

function spread(p, low, high) {
  return p * (high - low) + low;
}
/**
 * @param {number[]} vec [x, y]
 * @returns {number} euclidean length of the 2-d vector
 */

function length(vec) {
  var _vec = _slicedToArray(vec, 2),
      x = _vec[0],
      y = _vec[1];

  return Math.sqrt(x * x + y * y);
}
/**
 * @param {number[]} a [ax, ay]
 * @param {number[]} b [bx, by]
 * @returns {number} euclidean distance between two 2-d points
 */

function distance(a, b) {
  return length([b[0] - a[0], b[1] - a[1]]);
}
/**
 * @param {number[]} vec [x, y]
 * @returns {number} the direction of the 2-d vector on the compass rose in degrees in the range [0, 360).
 */

function toCardinalDegrees(vec) {
  var deg = Math.atan2(vec[0], vec[1]) * _consts__WEBPACK_IMPORTED_MODULE_0__["DEG"];
  return (deg + 360) % 360; // map (-180, 180] to [0, 360)
}

/***/ }),

/***/ "./src/micro.mjs":
/*!***********************!*\
  !*** ./src/micro.mjs ***!
  \***********************/
/*! exports provided: isDevMode, siteLangCode, siteInstance, isTruthy, isValue, coalesce, decimalize, scalarize, capitalize, isFF, isIOS, isMobile, isEmbeddedInIFrame, bindup, view, removeChildren, newClickEvent, windIntensityColorScale, formatCoordinates, formatScalar, formatVector, loadJson, loadJsonOnce, loadEpak, distortion, parseQueryString, dateToConfig, isAppMode, isKioskMode, isFixedMode, isDebugMode, arraysEq, merge, toArray, arrayHashCode, isArrayLike, omit, assign, ø, flatten */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDevMode", function() { return isDevMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "siteLangCode", function() { return siteLangCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "siteInstance", function() { return siteInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTruthy", function() { return isTruthy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValue", function() { return isValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coalesce", function() { return coalesce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decimalize", function() { return decimalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalarize", function() { return scalarize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFF", function() { return isFF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIOS", function() { return isIOS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return isMobile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmbeddedInIFrame", function() { return isEmbeddedInIFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindup", function() { return bindup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "view", function() { return view; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeChildren", function() { return removeChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newClickEvent", function() { return newClickEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windIntensityColorScale", function() { return windIntensityColorScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatCoordinates", function() { return formatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatScalar", function() { return formatScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatVector", function() { return formatVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadJson", function() { return loadJson; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadJsonOnce", function() { return loadJsonOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadEpak", function() { return loadEpak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distortion", function() { return distortion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseQueryString", function() { return parseQueryString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dateToConfig", function() { return dateToConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAppMode", function() { return isAppMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isKioskMode", function() { return isKioskMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFixedMode", function() { return isFixedMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDebugMode", function() { return isDebugMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arraysEq", function() { return arraysEq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayHashCode", function() { return arrayHashCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayLike", function() { return isArrayLike; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "omit", function() { return omit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ø", function() { return ø; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts */ "./src/consts.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./d3 */ "./src/d3.mjs");
/* harmony import */ var _decoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./decoder */ "./src/decoder.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utc */ "./src/utc.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math */ "./src/math.mjs");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * micro - a grab bag of somewhat useful utility functions and other stuff that requires unit testing
 *
 * Copyright (c) 2018 Cameron Beccario
 *
 * For a free version of this project, see https://github.com/cambecc/earth
 */






function isDevMode() {
  return +window.location.port === 8081;
}
function siteLangCode() {
  return _d3__WEBPACK_IMPORTED_MODULE_2__["select"]("html").attr("lang") || "en";
}
function siteInstance() {
  // UNDONE: this may no longer be needed because Cloudflare responds with "consty: Origin" CORS header set.
  var match = window.location.hostname.match(/(.*)\.nullschool\.net$/) || [],
      name = match[1] || "earth";
  return name === "earth" ? "" : name;
}
/**
 * @returns {boolean} true if the specified value is truthy.
 */

function isTruthy(x) {
  return !!x;
}
/**
 * @returns {boolean} true if the specified value is not null and not undefined.
 */

function isValue(x) {
  return x !== null && x !== undefined;
}
/**
 * @returns the first argument if not null and not undefined, otherwise the second argument.
 */

function coalesce(a, b) {
  return isValue(a) ? a : b;
}
/**
 * Converts the argument to a number, including special cases for fractions:
 *     0.25  -> 0.25
 *     "1/4" -> 0.25
 *     [1,4] -> 0.25
 *     ".25" -> 0.25
 *
 * @param x any object. When an array, then interpreted as the fraction: a[0] / a[1]. When a string containing
 *        a slash, the value is first converted to an array by splitting on "/".
 * @returns {number} the specified argument converted to a number.
 */

function decimalize(x) {
  if (underscore__WEBPACK_IMPORTED_MODULE_1__.isString(x) && x.indexOf("/") >= 0) {
    x = x.split("/");
  }

  return isArrayLike(x) && x.length === 2 ? x[0] / x[1] : +x;
}
/**
 * @param {Array|*} x the value to convert to a scalar.
 * @returns {*} the magnitude if x is a vector (i.e., x[2]), otherwise x itself.
 */

function scalarize(x) {
  return isArrayLike(x) ? x[2] : x;
}
/**
 * @returns {string} the specified string with the first letter capitalized.
 */

function capitalize(s) {
  return s.length === 0 ? s : s.charAt(0).toUpperCase() + s.substr(1);
}
/**
 * @returns {boolean} true if agent is probably firefox. Don't really care if this is accurate.
 */

function isFF() {
  return /firefox/i.test(navigator.userAgent);
}
/***
 * @returns {boolean} true if agent is probably iOS. Don't really care if this is accurate.
 */

function isIOS() {
  return /ipad|iphone|ipod/i.test(navigator.userAgent);
}
/**
 * @returns {boolean} true if agent is probably a mobile device. Don't really care if this is accurate.
 */

function isMobile() {
  return /android|blackberry|iemobile|ipad|iphone|ipod|opera mini|webos/i.test(navigator.userAgent);
}
function isEmbeddedInIFrame() {
  return self !== top;
}
/**
 * Finds the method having the specified name on the object thisArg, and returns it as a function bound
 * to thisArg. If no method can be found, or thisArg is not a value, then returns null.
 *
 * @param thisArg the object
 * @param methodName the method name to bind to the object
 * @returns {Function} the method bound to the object, if it exists.
 */

function bindup(thisArg, methodName) {
  return isValue(thisArg) && thisArg[methodName] ? thisArg[methodName].bind(thisArg) : null;
}
/**
 * @returns {{width: number, height: number}} an object that describes the size of the browser's current view.
 */

function view() {
  var w = window;
  var d = document && document.documentElement;
  var b = document && document.getElementsByTagName("body")[0];
  var x = w.innerWidth || d.clientWidth || b.clientWidth;
  var y = w.innerHeight || d.clientHeight || b.clientHeight;
  return {
    width: Math.ceil(x),
    height: Math.ceil(y)
  };
}
/**
 * Removes all children of the specified DOM element.
 */

function removeChildren(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}
/**
 * @returns {*} a new mouse click event instance
 */

function newClickEvent() {
  try {
    return new MouseEvent("click", {
      view: window,
      bubbles: true,
      cancelable: true
    });
  } catch (e) {
    // Chrome mobile supports only the old fashioned, deprecated way of constructing events. :(
    var event = document.createEvent("MouseEvents");
    event.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
    return event;
  }
}
/**
 * @returns {Array} of wind colors and a method, indexFor, that maps wind magnitude to an index on the color scale.
 */

function windIntensityColorScale(step, maxWind) {
  var result = [];

  for (var j = 85; j <= 255; j += step) {
    result.push("rgb(".concat(j, ",").concat(j, ",").concat(j, ")"));
  }

  result.indexFor = function (m) {
    // map wind speed to a style
    return Math.floor(Math.min(m, maxWind) / maxWind * (result.length - 1));
  };

  return result;
}
/**
 * Returns a human readable string for the provided coordinates.
 */

function formatCoordinates(λ, φ) {
  return Math.abs(φ).toFixed(2) + "° " + (φ >= 0 ? "N" : "S") + ", " + Math.abs(λ).toFixed(2) + "° " + (λ >= 0 ? "E" : "W");
}
/**
 * Returns a human readable string for the provided scalar in the given units.
 */

function formatScalar(value, units) {
  return units.conversion(value).toFixed(units.precision);
}
/**
 * Returns a human readable string for the provided vector in the given units. The vector has the parts [u, v].
 * See http://mst.nerc.ac.uk/wind_vect_convs.html.
 */

function formatVector(vec, units) {
  vec = units.convention === "into" ? [-vec[0], -vec[1]] : vec; // invert direction by convention, if necessary

  var deg = Object(_math__WEBPACK_IMPORTED_MODULE_5__["rintToMultiple"])(Object(_math__WEBPACK_IMPORTED_MODULE_5__["toCardinalDegrees"])(vec), 5); // round to nearest 5 degrees on the compass rose

  return "".concat(deg.toFixed(0), "\xB0 @ ").concat(formatScalar(Object(_math__WEBPACK_IMPORTED_MODULE_5__["length"])(vec), units));
}
/**
 * @param {string} resource
 * @param {Function} resolve
 * @param {Function} reject
 * @param {ProgressEvent} err
 * @param {*} result
 * @returns {*}
 */

function xhrResolver(resource, resolve, reject, err, result) {
  var _ref = err || {},
      target = _ref.target;

  return target ? target.status ? reject({
    status: target.status,
    message: target.statusText,
    resource: resource,
    error: err
  }) : reject({
    status: -1,
    message: "Cannot load ".concat(resource, ": ").concat(err),
    resource: resource,
    error: err
  }) : resolve(result);
}
/**
 * Returns a promise for a JSON resource (URL) fetched via XHR. If the load fails, the promise rejects with an
 * object describing the reason: {status: http-status-code, message: http-status-text, resource:}.
 * @returns {Promise}
 */


function loadJson(resource) {
  return new Promise(function (resolve, reject) {
    _d3__WEBPACK_IMPORTED_MODULE_2__["json"](resource, function (err, result) {
      return xhrResolver(resource, resolve, reject, err, result);
    });
  });
}
/**
 * Same as loadJson but returns a singleton promise for each URL.
 */

var loadJsonOnce = underscore__WEBPACK_IMPORTED_MODULE_1__.memoize(loadJson);
/**
 * Parses headers string into a map.
 *
 * "Content-Type: Foo\r\nContent-Length: 1234"  ->  {"content-type": ["foo"], "content-length": ["1234"]}
 *
 * @param {string} s unparsed headers string.
 * @returns {Object} map of header name to array of values (usually just one element, but possibly more).
 */

function parseHeaders(s) {
  var result = Object.create(null);
  (s || "").split("\n").forEach(function (line) {
    var i = line.indexOf(":");
    if (i < 0) return;
    var key = line.substr(0, i).trim().toLowerCase();
    var value = line.substr(i + 1).trim();
    result[key] = (result[key] || []).concat(value);
  });
  return result;
}
/**
 * @param {ProgressEvent} e
 * @returns {number}
 */


function computeProgress(e) {
  var total = e.total;

  if (!e.lengthComputable) {
    var headers = parseHeaders(e.target.getAllResponseHeaders());
    total = (headers["x-amz-meta-uncompressed-size"] || [])[0];
  }

  return total ? Object(_math__WEBPACK_IMPORTED_MODULE_5__["clamp"])(e.loaded / total, 0, 1) : NaN;
}
/**
 * Returns a promise for an EPAK resource (URL) fetched via XHR. If the load fails, the promise rejects
 * with an object describing the reason: {status: http-status-code, message: http-status-text, resource:}.
 * @returns {Promise}
 */


function loadEpak(resource) {
  return new Promise(function (resolve, reject) {
    _d3__WEBPACK_IMPORTED_MODULE_2__["request"](resource).responseType("arraybuffer").response(function (req) {
      return _decoder__WEBPACK_IMPORTED_MODULE_3__["decodeEpak"](req.response);
    }) // UNDONE: promise swallows decoding exceptions
    // .on("progress", /** @type {ProgressEvent} */ e => {
    //     const pct = computeProgress(e);
    //     if (pct) {
    //         console.log(resource, Math.round(pct * 100));
    //     } else {
    //         console.log(resource, e.loaded);
    //     }
    // })
    .get(function (err, res) {
      return xhrResolver(resource, resolve, reject, err, res);
    });
  });
}
/**
 * Returns the distortion introduced by the specified projection at the given point.
 *
 * This method uses finite difference estimates to calculate warping by adding a very small amount (h) to
 * both the longitude and latitude to create two lines. These lines are then projected to pixel space, where
 * they become diagonals of triangles that represent how much the projection warps longitude and latitude at
 * that location.
 *
 * <pre>
 *        (λ, φ+h)                  (xλ, yλ)
 *           .                         .
 *           |               ==>        \
 *           |                           \   __. (xφ, yφ)
 *    (λ, φ) .____. (λ+h, φ)       (x, y) .--
 * </pre>
 *
 * See:
 *     Map Projections: A Working Manual, Snyder, John P: pubs.er.usgs.gov/publication/pp1395
 *     gis.stackexchange.com/questions/5068/how-to-create-an-accurate-tissot-indicatrix
 *     www.jasondavies.com/maps/tissot
 *
 * @returns {Array} array of scaled derivatives [dx/dλ, dy/dλ, dx/dφ, dy/dφ]
 */

function distortion(projection, λ, φ, x, y) {
  var hλ = λ < 0 ? H : -H;
  var hφ = φ < 0 ? H : -H;
  var pλ = projection([λ + hλ, φ]);
  var pφ = projection([λ, φ + hφ]); // Meridian scale factor (see Snyder, equation 4-3), where R = 1. This handles issue where length of 1° λ
  // changes depending on φ. Without this, there is a pinching effect at the poles.

  var k = Math.cos(φ * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"]);
  var hλk = hλ * k;
  return [(pλ[0] - x) / hλk, // dx/dλ
  (pλ[1] - y) / hλk, // dy/dλ
  (pφ[0] - x) / hφ, // dx/dφ
  (pφ[1] - y) / hφ // dy/dφ
  ];
}
var H = 0.0000360; // 0.0000360°φ ~= 4m

/**
 * @param query URL search query string, e.g., "?a=1&b=2&c=&d"
 * @returns {Object} an object of terms, e.g., {a: "1", b: "2", c: "", d: null}
 */

function parseQueryString(query) {
  return underscore__WEBPACK_IMPORTED_MODULE_1__.object(query.split(/[?&]/).filter(isTruthy).map(function (term) {
    return term.split("=").map(decodeURIComponent).concat([null]); // use null for 2nd element when undefined
  }));
}
function dateToConfig(date) {
  return {
    date: _utc__WEBPACK_IMPORTED_MODULE_4__["normalize"](date)
  };
}
function isAppMode() {
  return underscore__WEBPACK_IMPORTED_MODULE_1__.has(parseQueryString(window.location.search), "app");
}
function isKioskMode() {
  var host = document.referrer.split("/")[2] || "";
  var override = /dailymail/i.test(host);
  return underscore__WEBPACK_IMPORTED_MODULE_1__.has(parseQueryString(window.location.search), "kiosk") && !override;
}
/** @returns {boolean} true if globe rotation and zoom should be disabled. UNDONE: no one uses this. rip out? */

function isFixedMode() {
  return underscore__WEBPACK_IMPORTED_MODULE_1__.has(parseQueryString(window.location.search), "fixed");
}
function isDebugMode() {
  return underscore__WEBPACK_IMPORTED_MODULE_1__.has(parseQueryString(window.location.search), "debug");
}
/**
 * @param {Array|Uint8Array|Float32Array} a any array-like object
 * @param {Array|Uint8Array|Float32Array} b any array-like object
 * @returns {boolean} true if both arrays are strictly equal (using ===) while recursing down nested arrays.
 */

function arraysEq(a, b) {
  for (var i = 0; i < a.length; i++) {
    var s = a[i],
        t = b[i];

    if (s === t) {
      continue; // exactly equal
    }

    if (s !== s && t !== t) {
      continue; // both are NaN
    }

    if (isArrayLike(s) && arraysEq(s, t)) {
      continue; // nested arrays are equal
    }

    return false;
  }

  return a.length === b.length;
}
/**
 * @param {Float32Array} a [a0, a1, a2, ...]
 * @param {Float32Array} b [b0, b1, b2, ...]
 * @returns {Float32Array} [a0, b0, a1, b1, a2, b2, ...]
 */

function merge(a, b) {
  var result = new Float32Array(a.length * 2);

  for (var i = 0; i < a.length; i++) {
    var j = i * 2;
    result[j] = a[i];
    result[j + 1] = b[i];
  }

  return result;
}
/**
 * @param {*|Uint8Array} src any array-like object
 * @returns {Array} a new Array containing the same elements.
 */

function toArray(src) {
  return Array.prototype.slice.call(src); // Replace with Array.from() in the future.
}
/**
 * @param {Int8Array|Int16Array|Int32Array} array any TypedArray
 * @param {Number} samples the number of samples to compute the hash code
 * @returns {Number} the hash code
 */

function _arrayHashCode(array, samples) {
  var result = new Int32Array([array.byteLength]);
  var step = Math.max(array.length / samples, 1);

  for (var i = 0; i < array.length; i += step) {
    result[0] = 31 * result[0] + array[Math.floor(i)];
  }

  return result[0];
}
/**
 * Constructs a hash code from _some_ elements of an array. Trades collision avoidance for performance.
 * @param {Float32Array|Uint8Array} array any TypedArray
 * @param {Number} [samples] the number of samples to compute the hash code with. (default: all)
 * @returns {Number} the hash code
 */


function arrayHashCode(array) {
  var samples = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  var data;

  switch (array.byteLength % 4) {
    case 0:
      data = new Int32Array(array.buffer);
      break;

    case 2:
      data = new Int16Array(array.buffer);
      break;

    default:
      data = new Int8Array(array.buffer);
      break;
  }

  return _arrayHashCode(data, samples);
}
function isArrayLike(obj) {
  if (Array.isArray(obj)) return true;
  if (_typeof(obj) !== "object" || !obj) return false;
  var length = obj.length;
  return typeof length === "number" && length >= 0;
}
function omit(obj) {
  for (var _len = arguments.length, discard = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    discard[_key - 1] = arguments[_key];
  }

  var result = {};
  Object.keys(obj).forEach(function (key) {
    if (discard.indexOf(key) < 0) {
      result[key] = obj[key];
    }
  });
  return result;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;

function _assign(target, source) {
  // UNDONE: replace with Object.assign when IE11 no longer supported.
  if (source !== undefined && source !== null) {
    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
}
/**
 * @param {Object} target the destination object.
 * @param {...Object} [sources] the source objects.
 * @returns {Object} Returns `target`.
 */


function assign(target, sources) {
  for (var i = 1; i < arguments.length; i++) {
    _assign(target, arguments[i]);
  }

  return target;
}
/**
 * @param {...Object} [sources] the source objects.
 * @returns {Object} returns a new object, with no prototype, containing properties from the sources.
 */

function ø(sources) {
  var result = Object.create(null);

  for (var i = 0; i < arguments.length; i++) {
    _assign(result, arguments[i]);
  }

  return result;
}

function _flatten(array, target) {
  for (var i = 0; i < array.length; i++) {
    var e = array[i];

    if (isArrayLike(e)) {
      _flatten(e, target);
    } else {
      target.push(e);
    }
  }

  return target;
}

function flatten(array) {
  return isArrayLike(array) ? _flatten(array, []) : undefined;
}

/***/ }),

/***/ "./src/palette/airdens.mjs":
/*!*********************************!*\
  !*** ./src/palette/airdens.mjs ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
  var bounds = [0, 1.5]; // units: kg/m3

  var segments = [[0, [0, 0, 0]], [1.5, [255, 255, 255]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/aurora.mjs":
/*!********************************!*\
  !*** ./src/palette/aurora.mjs ***!
  \********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 100];
  var stops = [{
    color: [0, 0, 0],
    mode: "lab",
    p: bounds[0]
  }, {
    color: [4, 8, 34],
    mode: "lab",
    p: 5
  }, {
    color: [78, 255, 103],
    mode: "lab",
    p: 40
  }, {
    color: [252, 255, 57],
    mode: "lab",
    p: 60
  }, {
    color: [219, 75, 255],
    mode: "lab",
    p: bounds[1]
  }];
  var interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["interpolatorsFrom"](stops);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 1, [35, 45]);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 3, [55, 65]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromInterpolators"](bounds, interpolators, resolution);
});

/***/ }),

/***/ "./src/palette/cape.mjs":
/*!******************************!*\
  !*** ./src/palette/cape.mjs ***!
  \******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 5000]; // units: J/kg

  var segments = [// Diverging 11-class RdBu, from colorbrewer2.org
  [0, [5, 48, 97]], // weak
  [500, [33, 102, 172]], // weak
  [1000, [67, 147, 195]], // weak
  [1500, [146, 197, 222]], // moderate
  [2000, [209, 229, 240]], // moderate
  [2500, [247, 247, 247]], // moderate
  [3000, [253, 219, 199]], // strong
  [3500, [244, 165, 130]], // strong
  [4000, [214, 96, 77]], // strong
  [4500, [178, 24, 43]], // extreme
  [5000, [103, 0, 31]] // extreme
  ];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/co2.mjs":
/*!*****************************!*\
  !*** ./src/palette/co2.mjs ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0.0003578, 0.0003770]; // units: CO2 Bulk Mixing Ratio (Column Mass/ps) -- or CO2 column load??

  var stops = [{
    color: [0, 0, 0],
    mode: "hcl",
    p: bounds[0]
  }, {
    color: [100, 0, 0],
    mode: "hcl",
    p: 0.0003650
  }, {
    color: [164, 36, 0],
    mode: "hcl",
    p: 0.0003675
  }, {
    color: [255, 220, 140],
    mode: "hcl",
    p: 0.0003710
  }, {
    color: [255, 255, 255],
    mode: "hcl",
    p: bounds[1]
  }];
  var interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["interpolatorsFrom"](stops);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 2, [0.0003700, 0.0003720]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromInterpolators"](bounds, interpolators, resolution);
});

/***/ }),

/***/ "./src/palette/co2sc.mjs":
/*!*******************************!*\
  !*** ./src/palette/co2sc.mjs ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function (Δ) {
  var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
  var bounds = [360 + Δ, 470 + Δ]; // units: CO2 Surface Concentration ppmv

  var stops = [{
    color: [0, 0, 0],
    mode: "hcl",
    p: bounds[0]
  }, {
    color: [100, 0, 0],
    mode: "hcl",
    p: 400 + Δ
  }, {
    color: [164, 36, 0],
    mode: "hcl",
    p: 405 + Δ
  }, {
    color: [255, 220, 140],
    mode: "hcl",
    p: 420 + Δ
  }, {
    color: [255, 255, 255],
    mode: "hcl",
    p: 450 + Δ
  }, {
    color: [0, 210, 255],
    mode: "hcl",
    p: bounds[1]
  }];
  var x = stops[3].p,
      y = stops[4].p,
      z = stops[1].p;
  var interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["interpolatorsFrom"](stops);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 0, [z - 2, z + 2]);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 3, [x - 2, x + 2]);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 5, [y - 2, y + 2]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromInterpolators"](bounds, interpolators, resolution);
});

/***/ }),

/***/ "./src/palette/cosc.mjs":
/*!******************************!*\
  !*** ./src/palette/cosc.mjs ***!
  \******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2000;
  var bounds = [40, 2500]; // units: ppb

  var stops = [{
    color: [0, 38, 40],
    mode: "lab",
    p: bounds[0]
  }, {
    color: [255, 255, 224],
    mode: "hcl",
    p: 400
  }, // background is ~100 ppb https://en.wikipedia.org/wiki/MOPITT
  {
    color: [0, 0, 154],
    mode: "lab",
    p: 1800
  }, {
    color: [0, 0, 0],
    mode: "lab",
    p: bounds[1]
  }];
  var interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["interpolatorsFrom"](stops);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 0, [340, 460]);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 2, [1500, 2100]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromInterpolators"](bounds, interpolators, resolution);
});

/***/ }),

/***/ "./src/palette/currents.mjs":
/*!**********************************!*\
  !*** ./src/palette/currents.mjs ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 1.5]; // units: m/s

  var segments = [[0, [10, 25, 68]], [0.15, [10, 25, 250]], [0.4, [24, 255, 93]], [0.65, [255, 233, 102]], [1.0, [255, 233, 15]], [1.5, [255, 15, 15]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/duexttau.mjs":
/*!**********************************!*\
  !*** ./src/palette/duexttau.mjs ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");
/* harmony import */ var _kindlmann__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./kindlmann */ "./src/palette/kindlmann.mjs");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  var bounds = [0.0001, 3.0000]; // units: τ

  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScale"](bounds, _kindlmann__WEBPACK_IMPORTED_MODULE_1__["default"], Math.log, Math.exp);
});

/***/ }),

/***/ "./src/palette/htsgw.mjs":
/*!*******************************!*\
  !*** ./src/palette/htsgw.mjs ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 15]; // units: m

  var segments = [[0, [8, 29, 88]], [1, [37, 52, 148]], [2, [34, 94, 168]], [3, [29, 145, 192]], [4, [65, 182, 196]], [5, [127, 205, 187]], [6, [199, 233, 180]], [7, [237, 248, 177]], [8, [254, 204, 92]], [10, [253, 141, 60]], [12, [240, 59, 32]], [14, [189, 0, 38]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/kindlmann.mjs":
/*!***********************************!*\
  !*** ./src/palette/kindlmann.mjs ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Kindlmann Linear Luminance palette
 *
 * Kindlmann, G. Reinhard, E. and Creem, S., 2002, Face-based Luminance Matching for Perceptual Colormap Generation,
 *     IEEE – Proceedings of the conference on Visualization ’02
 *
 * Prepared by Matteo Niccoli:
 *     https://mycarta.wordpress.com/2012/12/06/the-rainbow-is-deadlong-live-the-rainbow-part-5-cie-lab-linear-l-rainbow/
 */
function generate(data) {
  var result = new Uint8Array(data.length / 3 * 4);

  for (var i = 0, j = 0; i < data.length; i += 3, j += 4) {
    result[j] = data[i];
    result[j + 1] = data[i + 1];
    result[j + 2] = data[i + 2];
    result[j + 3] = 255;
  }

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (generate([4, 4, 4, 10, 3, 8, 13, 4, 11, 16, 5, 14, 18, 5, 16, 21, 6, 18, 22, 7, 19, 24, 8, 21, 26, 8, 22, 27, 9, 24, 28, 10, 25, 30, 11, 26, 31, 12, 27, 32, 12, 28, 33, 13, 29, 35, 14, 31, 36, 14, 32, 37, 15, 32, 38, 15, 33, 39, 16, 34, 40, 17, 35, 41, 17, 36, 42, 18, 38, 43, 19, 38, 44, 19, 39, 46, 20, 41, 46, 20, 45, 46, 21, 50, 45, 21, 55, 45, 21, 60, 45, 22, 64, 45, 23, 67, 45, 23, 71, 45, 24, 75, 45, 24, 77, 45, 25, 81, 45, 25, 84, 44, 26, 87, 44, 27, 90, 45, 27, 92, 45, 28, 95, 44, 29, 98, 44, 29, 100, 44, 30, 103, 44, 31, 106, 44, 31, 109, 44, 32, 110, 44, 33, 113, 44, 34, 116, 43, 34, 118, 42, 35, 121, 40, 38, 120, 38, 40, 119, 36, 42, 120, 34, 44, 120, 33, 46, 120, 32, 47, 120, 31, 49, 121, 30, 50, 122, 30, 51, 123, 29, 52, 123, 29, 53, 125, 28, 55, 125, 28, 56, 126, 27, 57, 127, 28, 58, 128, 28, 59, 129, 27, 60, 129, 27, 61, 131, 27, 62, 132, 27, 63, 133, 28, 64, 134, 27, 65, 135, 27, 66, 136, 27, 68, 137, 27, 69, 138, 25, 71, 136, 22, 73, 134, 21, 74, 133, 20, 76, 131, 17, 78, 129, 16, 79, 128, 15, 81, 126, 14, 82, 125, 10, 84, 123, 10, 85, 122, 9, 87, 120, 8, 88, 119, 7, 89, 118, 6, 91, 117, 4, 92, 115, 4, 94, 114, 4, 95, 114, 3, 96, 112, 1, 98, 111, 1, 99, 110, 0, 100, 109, 0, 101, 108, 0, 103, 107, 0, 104, 106, 0, 105, 105, 0, 107, 104, 0, 108, 101, 0, 110, 100, 0, 111, 99, 0, 112, 98, 0, 114, 96, 0, 115, 95, 0, 116, 93, 0, 118, 92, 0, 119, 90, 0, 120, 89, 0, 121, 88, 0, 123, 86, 0, 124, 85, 0, 125, 83, 0, 127, 82, 0, 128, 80, 0, 129, 79, 0, 131, 77, 0, 132, 75, 0, 133, 73, 0, 134, 72, 0, 136, 70, 0, 137, 68, 0, 138, 66, 0, 139, 65, 0, 141, 64, 0, 142, 63, 0, 143, 61, 0, 145, 60, 0, 146, 60, 0, 147, 58, 0, 149, 57, 0, 150, 56, 0, 151, 55, 0, 153, 53, 0, 154, 52, 0, 155, 51, 0, 157, 50, 0, 158, 48, 0, 159, 47, 0, 160, 45, 0, 162, 44, 0, 163, 42, 0, 164, 41, 0, 165, 39, 0, 167, 36, 0, 168, 34, 0, 169, 31, 0, 170, 23, 0, 169, 8, 9, 170, 0, 20, 171, 0, 29, 172, 0, 35, 173, 0, 40, 174, 0, 45, 175, 0, 48, 176, 0, 52, 177, 0, 55, 178, 0, 59, 179, 0, 61, 180, 0, 64, 181, 0, 66, 182, 0, 68, 183, 0, 71, 184, 0, 73, 185, 0, 76, 186, 0, 78, 187, 0, 79, 188, 0, 81, 189, 0, 83, 190, 0, 85, 191, 0, 87, 192, 0, 92, 193, 0, 99, 193, 0, 106, 193, 0, 114, 193, 0, 119, 194, 0, 125, 194, 0, 130, 194, 0, 135, 195, 0, 140, 195, 0, 145, 195, 0, 149, 196, 0, 153, 196, 0, 157, 197, 0, 161, 197, 0, 165, 197, 0, 169, 198, 0, 172, 198, 0, 176, 199, 0, 180, 199, 0, 184, 199, 0, 186, 200, 0, 190, 201, 0, 193, 201, 0, 197, 201, 0, 200, 202, 0, 201, 201, 24, 203, 202, 51, 206, 202, 65, 207, 203, 77, 209, 203, 87, 212, 203, 95, 213, 204, 103, 215, 205, 109, 218, 205, 116, 219, 206, 121, 221, 207, 127, 223, 207, 132, 226, 207, 138, 227, 208, 143, 229, 209, 147, 231, 209, 151, 232, 210, 155, 235, 211, 159, 237, 211, 164, 238, 212, 168, 240, 212, 172, 243, 213, 175, 243, 214, 179, 245, 214, 183, 248, 215, 186, 248, 216, 189, 248, 218, 193, 247, 219, 195, 247, 220, 198, 247, 222, 201, 248, 223, 204, 247, 224, 206, 247, 226, 209, 247, 227, 211, 247, 229, 214, 247, 230, 216, 247, 231, 218, 247, 232, 220, 248, 234, 224, 247, 235, 225, 247, 236, 229, 247, 238, 231, 247, 239, 232, 248, 240, 235, 248, 242, 237, 247, 243, 239, 248, 244, 241, 248, 246, 244, 248, 247, 246, 248, 248, 248, 249, 249, 249, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255, 255, 255]));

/***/ }),

/***/ "./src/palette/linear.frag":
/*!*********************************!*\
  !*** ./src/palette/linear.frag ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat fmap(in float v) {\n    return v;\n}\n"

/***/ }),

/***/ "./src/palette/log.frag":
/*!******************************!*\
  !*** ./src/palette/log.frag ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat fmap(in float v) {\n    return log(v);\n}\n"

/***/ }),

/***/ "./src/palette/misery.mjs":
/*!********************************!*\
  !*** ./src/palette/misery.mjs ***!
  \********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [236, 332]; // units: kelvin

  var segments = [[241, [255, 255, 255]], // -32 C, -25 F extreme frostbite
  [245.5, [6, 82, 255]], [250, [6, 82, 255]], // -23 C, -10 F frostbite
  [258, [46, 131, 255]], [266, [46, 131, 255]], // -7 C, 20 F hypothermia
  [280, [0, 0, 0]], // 7 C, 45 F begin suckage (cold)
  [300, [0, 0, 0]], // 27 C, 80 F begin caution (heat)
  [305, [247, 20, 35]], // 32 C, 90 F extreme caution
  [309.5, [247, 20, 35]], [314, [245, 210, 5]], // 41 C, 105 F danger
  [320.5, [245, 210, 5]], [327, [255, 255, 255]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/mslp.mjs":
/*!******************************!*\
  !*** ./src/palette/mslp.mjs ***!
  \******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [92000, 105000]; // units: Pa

  var segments = [[92000, [40, 0, 0]], [95000, [187, 60, 31]], [96500, [137, 32, 30]], [98000, [16, 1, 43]], [100500, [36, 1, 93]], [101300, [241, 254, 18]], [103000, [228, 246, 223]], [105000, [255, 255, 255]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/palette.frag":
/*!**********************************!*\
  !*** ./src/palette/palette.frag ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform vec2 u_Range;  // [min, size]\nuniform lowp sampler2D u_Palette;\nuniform lowp float u_Alpha;\n\nlowp vec4 colorize(in float v) {\n    vec2 st = vec2((fmap(v) - u_Range.x) / u_Range.y, 0.5);\n    lowp vec4 color = texture2D(u_Palette, st);\n    lowp float alpha = (1.0 - step(7e37, v)) * u_Alpha;\n    return vec4(color.rgb * alpha, alpha);  // premultiply alpha\n}\n"

/***/ }),

/***/ "./src/palette/palette.mjs":
/*!*********************************!*\
  !*** ./src/palette/palette.mjs ***!
  \*********************************/
/*! exports provided: interpolateCubehelix, sinebowColor, extendedSinebowColor, segmentedColorScale, interpolatorsFrom, smooth, fillRange, quantize, buildScaleFromInterpolators, buildScaleFromSegments, buildScale */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return interpolateCubehelix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinebowColor", function() { return sinebowColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendedSinebowColor", function() { return extendedSinebowColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "segmentedColorScale", function() { return segmentedColorScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolatorsFrom", function() { return interpolatorsFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smooth", function() { return smooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillRange", function() { return fillRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return quantize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildScaleFromInterpolators", function() { return buildScaleFromInterpolators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildScaleFromSegments", function() { return buildScaleFromSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildScale", function() { return buildScale; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../consts */ "./src/consts.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./src/math.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../d3 */ "./src/d3.mjs");
/* harmony import */ var _log_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./log.frag */ "./src/palette/log.frag");
/* harmony import */ var _linear_frag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./linear.frag */ "./src/palette/linear.frag");
/* harmony import */ var _palette_frag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./palette.frag */ "./src/palette/palette.frag");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }









function normalizeColor(format) {
  if (Array.isArray(format)) {
    var _format = _slicedToArray(format, 4),
        r = _format[0],
        g = _format[1],
        b = _format[2],
        a = _format[3];

    return _d3__WEBPACK_IMPORTED_MODULE_3__["rgb"](r, g, b, a);
  }

  return _d3__WEBPACK_IMPORTED_MODULE_3__["color"](format);
}

function colorInterpolator(start, end) {
  var _start = _slicedToArray(start, 3),
      r = _start[0],
      g = _start[1],
      b = _start[2];

  var Δr = end[0] - r,
      Δg = end[1] - g,
      Δb = end[2] - b;
  return function (t) {
    return [Math.floor(r + t * Δr), Math.floor(g + t * Δg), Math.floor(b + t * Δb)].map(function (e) {
      return Object(_math__WEBPACK_IMPORTED_MODULE_1__["clamp"])(e, 0, 255);
    });
  };
}

function interpolateLabBasis(colors, range) {
  var l = [],
      a = [],
      b = [];

  for (var i = 0; i < colors.length; i++) {
    var color = _d3__WEBPACK_IMPORTED_MODULE_3__["lab"](colors[i]);
    l[i] = color.l;
    a[i] = color.a;
    b[i] = color.b;
  }

  var lBasis = _d3__WEBPACK_IMPORTED_MODULE_3__["interpolateBasis"](l);
  var aBasis = _d3__WEBPACK_IMPORTED_MODULE_3__["interpolateBasis"](a);
  var bBasis = _d3__WEBPACK_IMPORTED_MODULE_3__["interpolateBasis"](b);

  var result = function result(t) {
    return _d3__WEBPACK_IMPORTED_MODULE_3__["lab"](lBasis(t), aBasis(t), bBasis(t)) + "";
  };

  result.domain = function () {
    return range;
  };

  result.mode = function () {
    return "lab";
  };

  return result;
}

function instantiate(mode, a, b) {
  switch (mode) {
    case "rgb":
      return _d3__WEBPACK_IMPORTED_MODULE_3__["interpolateRgb"](a, b);

    case "lab":
      return _d3__WEBPACK_IMPORTED_MODULE_3__["interpolateLab"](a, b);

    case "hcl":
      return _d3__WEBPACK_IMPORTED_MODULE_3__["interpolateHcl"](a, b);

    case "hsl":
      return _d3__WEBPACK_IMPORTED_MODULE_3__["interpolateHsl"](a, b);

    default:
      throw new Error("unsupported color space: ".concat(mode));
  }
}

function newInterpolator(stopA, stopB) {
  var interpolator = instantiate(stopA.mode, normalizeColor(stopA.color), normalizeColor(stopB.color)); // UNDONE HACK: stash some additional info on the interpolator function.

  interpolator.domain = function () {
    return [stopA.p, stopB.p];
  };

  interpolator.mode = function () {
    return stopA.mode;
  };

  return interpolator;
}

function interpolateCubehelix(domain) {
  var interpolator = function interpolator(t) {
    return _d3__WEBPACK_IMPORTED_MODULE_3__["interpolateCubehelixDefault"](t);
  };

  interpolator.domain = function () {
    return domain;
  };

  interpolator.mode = function () {
    return "cubehelix";
  };

  return interpolator;
}
/**
 * Produces a color style in a rainbow-like trefoil color space. Not quite HSV, but produces a nice
 * spectrum. See http://krazydad.com/tutorials/makecolors.php.
 *
 * @param hue the hue rotation in the range [0, 1]
 * @returns {Array} [r, g, b]
 */

function sinebowColor(hue) {
  // Map hue [0, 1] to radians [0, 5/6τ]. Don't allow a full rotation because that keeps hue == 0 and
  // hue == 1 from mapping to the same color.
  var rad = hue * _consts__WEBPACK_IMPORTED_MODULE_0__["τ"] * 5 / 6;
  rad *= 0.75; // increase frequency to 2/3 cycle per rad

  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var r = Math.floor(Math.max(0, -c) * 255);
  var g = Math.floor(Math.max(s, 0) * 255);
  var b = Math.floor(Math.max(c, 0, -s) * 255);
  return [r, g, b];
}
var BOUNDARY = 0.45;
var fadeToWhite = colorInterpolator(sinebowColor(1), [255, 255, 255]);
/**
 * Interpolates a sinebow color where 0 <= t <= j, then fades to white where j < t <= 1.
 *
 * @param t number in the range [0, 1] inclusive
 * @returns {Array} [r, g, b]
 */

function extendedSinebowColor(t) {
  return t <= BOUNDARY ? sinebowColor(t / BOUNDARY) : fadeToWhite((t - BOUNDARY) / (1 - BOUNDARY));
}
/**
 * Creates a color scale composed of the specified segments. Segments is an array of two-element arrays of the
 * form [value, color], where value is the point along the scale and color is the [r, g, b] color at that point.
 * For example, the following creates a scale that smoothly transitions from red to green to blue along the
 * points 0.5, 1.0, and 3.5:
 *
 *     [ [ 0.5, [255,   0,   0] ],
 *       [ 1.0, [  0, 255,   0] ],
 *       [ 3.5, [  0,   0, 255] ] ]
 *
 * @param segments array of color segments
 * @returns {Function} a function(v) that returns the color [r, g, b] for the given value.
 */

function segmentedColorScale(segments) {
  var points = [],
      interpolators = [],
      ranges = [];

  for (var i = 0; i < segments.length - 1; i++) {
    points.push(segments[i + 1][0]);
    interpolators.push(colorInterpolator(segments[i][1], segments[i + 1][1]));
    ranges.push([segments[i][0], segments[i + 1][0]]);
  }

  return function (v) {
    var i;

    for (i = 0; i < points.length - 1; i++) {
      if (v <= points[i]) {
        break;
      }
    }

    var t = _math__WEBPACK_IMPORTED_MODULE_1__["proportion"].apply(void 0, [v].concat(_toConsumableArray(ranges[i])));
    return interpolators[i](t);
  };
}
/**
 * Converts an array of N color stops into N-1 D3 interpolators:
 *
 *    {color: "black", mode: "hcl", p: 10},
 *    {color: "grey",  mode: "lab", p: 20},
 *    {color: "white",              p: 30}
 *
 * Result:
 *    scale 0 [black, grey] over domain [10, 20] in lch color space
 *    scale 1 [grey, white] over domain [20, 30] in lab color space
 *
 * @param {Array} stops an array of colors stops to convert into scales.
 * @returns {Array} an array of D3 interpolator functions.
 */

function interpolatorsFrom(stops) {
  var interpolators = [];

  for (var i = 0; i < stops.length - 1; i++) {
    interpolators.push(newInterpolator(stops[i], stops[i + 1]));
  }

  return interpolators;
}
/**
 * Given a range [a, b] and two adjoining color scales L (i) and R (i+1) sharing domain point p, insert a new
 * basis spline interpolated scale M over the points [a, p, b].
 *
 * @param {Array} interpolators
 * @param {Number} i
 * @param {Array} range
 * @returns {Array}
 */

function smooth(interpolators, i, range) {
  //         p                  p
  //        / \              M _-_
  //       /   \      =>      /   \
  //      /     \            a     b
  //   L /       \ R      K /       \ S
  //    Lx       Ry        Lx       Ry
  var L = interpolators[i],
      R = interpolators[i + 1];
  var a = _math__WEBPACK_IMPORTED_MODULE_1__["proportion"].apply(void 0, [range[0]].concat(_toConsumableArray(L.domain())));
  var b = _math__WEBPACK_IMPORTED_MODULE_1__["proportion"].apply(void 0, [range[1]].concat(_toConsumableArray(R.domain())));
  var K = newInterpolator({
    color: _d3__WEBPACK_IMPORTED_MODULE_3__["color"](L(0)),
    mode: L.mode(),
    p: L.domain()[0]
  }, {
    color: _d3__WEBPACK_IMPORTED_MODULE_3__["color"](L(a)),
    mode: L.mode(),
    p: range[0]
  });
  var M = interpolateLabBasis([L(a), L(1), R(b)], range);
  var S = newInterpolator({
    color: _d3__WEBPACK_IMPORTED_MODULE_3__["color"](R(b)),
    mode: R.mode(),
    p: range[1]
  }, {
    color: _d3__WEBPACK_IMPORTED_MODULE_3__["color"](R(1)),
    mode: R.mode(),
    p: R.domain()[1]
  });
  return [].concat(interpolators.slice(0, i), [K, M, S], interpolators.slice(i + 2));
}
/**
 * Use array A of length n to define a linear scale over domain [x, y] such that [x, y] is mapped onto indices
 * [0, n-1]. The range [a, b] is then mapped to indices [i, j] using this scale, and the elements A[i] to A[j] are
 * filled with the results of f(v) where v iterates over [a, b].
 *
 * @param {Uint8Array} array the destination array to fill as rgba quadlets: [r0, g0, b0, a0, ...]
 * @param {Number[]} domain the values [x, y], inclusive.
 * @param {Number[]} range the values [a, b], inclusive.
 * @param {Function} ƒcolor the value function f(v) that returns [r, g, b] or [r, g, b, opacity] for v.
 */

function fillRange(array, domain, range, ƒcolor) {
  //    |-----------domain------------|
  //    |        |---range---|        |
  //    x        a           b        y
  //    0        p           q       n-1
  // A [0, ..., f(a), ..., f(b), ..., 0] n
  var _domain = _slicedToArray(domain, 2),
      x = _domain[0],
      y = _domain[1];

  var _range = _slicedToArray(range, 2),
      a = _range[0],
      b = _range[1];

  var n = Math.floor(array.length / 4);
  var Δ = (y - x) / (n - 1);
  var p = Object(_math__WEBPACK_IMPORTED_MODULE_1__["rint"])((a - x) / Δ);

  for (var i = Math.max(p, 0); i < n; i++) {
    var value = a + (i - p) * Δ;

    if (value > b) {
      break;
    }

    var c = ƒcolor(value);
    var j = i * 4;
    array[j] = c[0];
    array[j + 1] = c[1];
    array[j + 2] = c[2];
    array[j + 3] = c.length > 3 ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["clamp"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["spread"])(c[3], 0, 255), 0, 255) : 255;
  }
}
/**
 * Convert a set of D3 interpolators into an accessor function over a computed array of rgba colors.
 *
 * @param {Number[]} bounds the values [x, y], inclusive.
 * @param {Array} interpolators the set of interpolator functions.
 * @param {Number} resolution the number of elements of the computed color array.
 * @returns {Uint8Array} sequence of rgba quadlets: [r0, g0, b0, a0, r1, g1, b1, a1, ...]
 */

function quantize(bounds, interpolators, resolution) {
  var array = new Uint8Array(resolution * 4);
  interpolators.forEach(function (interpolator) {
    var domain = interpolator.domain();
    fillRange(array, bounds, domain, function (v) {
      var c = _d3__WEBPACK_IMPORTED_MODULE_3__["color"](interpolator(_math__WEBPACK_IMPORTED_MODULE_1__["proportion"].apply(void 0, [v].concat(_toConsumableArray(domain)))));
      return [c.r, c.g, c.b, c.opacity];
    });
  });
  return array;
}
function buildScaleFromInterpolators(bounds, interpolators, resolution) {
  var colors = quantize(bounds, interpolators, resolution);
  return buildScale(bounds, colors);
}
function buildScaleFromSegments(bounds, segments, resolution) {
  var gradient = segmentedColorScale(segments);
  var array = new Uint8Array(resolution * 4);
  fillRange(array, bounds, bounds, gradient);
  return buildScale(bounds, array);
}
/**
 * @param {Number[]} bounds [low, high] values. Assumes bounds are _center_ aligned color stops.
 * @param {Uint8Array} colors sequence of rgba quadlets: [r0, g0, b0, a0, r1, g1, b1, a1, ...]
 * @param {Function} [ƒmap] the scale function, like Math.log (default is linear).
 * @param {Function} [ƒinv] the inverse scale function, like Math.exp (default is linear).
 * @returns {Scale}
 */

function buildScale(bounds, colors) {
  var ƒmap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (v) {
    return v;
  };
  var ƒinv = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (v) {
    return v;
  };

  /*
   Two types of scale representations:
   0        10        20        30        40        50   <= Split range [0, 50] (inclusive) over 5 buckets.
  |         |         |         |         |         |      Stops are aligned with _edges_ of buckets.
  +---------+---------+---------+---------+---------+
  | 0 black | 1 blue  | 2 green | 3  red  | 4 white |   array.length == n == 5
  +---------+---------+---------+---------+---------+
       |         |         |         |         |
       5        15        25        35        45        <= Color stops define _centers_, where distance between
                                                           stops is bucket size. Range here is [5, 45].
   These two scales are equivalent but use different formulas to map value -> index for array access, and
  value -> texcoord on range [0, 1].
   For edge aligned stops:
      texcoord s = (value - edgeLow) / (edgeHigh - edgeLow)
      index    i = s * n - 0.5
   For center aligned stops:
      index    i = (value - centerLow) / (centerHigh - centerLow) * (n - 1)
      texcoord s = (i + 0.5) / n
   To convert between the two different scale types, expand/contract the bounds based on bucket count:
      [centerLow, centerHigh] == [edgeLow + ε, edgeHigh - ε]  where ε = (edgeHigh - edgeLow) / 2n
      [edgeLow, edgeHigh] == [centerLow - ε, centerHigh + ε]  where ε = (centerHigh - centerLow) / 2(n-1)
    */
  var lo = ƒmap(bounds[0]),
      hi = ƒmap(bounds[1]);
  var iMax = colors.length / 4 - 1,
      scale = iMax / (hi - lo);
  var hash = _micro__WEBPACK_IMPORTED_MODULE_2__["arrayHashCode"](colors, 1000);
  var ε = (hi - lo) / (2 * iMax);
  var edgeLo = lo - ε,
      edgeHi = hi + ε,
      edgeRange = [edgeLo, edgeHi - edgeLo];
  return new (
  /*#__PURE__*/
  function () {
    function Scale() {
      _classCallCheck(this, Scale);
    }

    _createClass(Scale, [{
      key: "indexOf",

      /**
       * @param {Number} value the scale value
       * @returns {Number} the rgba quadlet index; multiply by 4 for the true index in the colors array.
       */
      value: function indexOf(value) {
        var i = Math.round((ƒmap(value) - lo) * scale);
        return Object(_math__WEBPACK_IMPORTED_MODULE_1__["clamp"])(i, 0, iMax);
      }
      /**
       * @param index the rgba quadlet index
       * @returns {Number} the associated scale value
       */

    }, {
      key: "valueFor",
      value: function valueFor(index) {
        return ƒinv(index / scale + lo);
      }
      /**
       * @param {Number} value the scale value
       * @returns {Number[]} rgba quadlet for the specified value
       */

    }, {
      key: "rgba",
      value: function rgba(value) {
        var j = this.indexOf(value) * 4;
        return [colors[j], colors[j + 1], colors[j + 2], colors[j + 3]];
      }
      /**
       * @param {GLUStick} glu
       */

    }, {
      key: "webgl",
      value: function webgl(glu) {
        var gl = glu.context;
        return {
          shaderSource: function shaderSource() {
            var mapper = ƒmap === Math.log ? _log_frag__WEBPACK_IMPORTED_MODULE_4__ : _linear_frag__WEBPACK_IMPORTED_MODULE_5__;
            return [mapper, _palette_frag__WEBPACK_IMPORTED_MODULE_6__];
          },
          textures: function textures() {
            return {
              color_scale: {
                format: gl.RGBA,
                type: gl.UNSIGNED_BYTE,
                width: colors.length / 4,
                height: 1,
                data: colors,
                hash: hash
              }
            };
          },
          uniforms: function uniforms() {
            return {
              u_Range: edgeRange,
              u_Palette: "color_scale",
              u_Alpha: 1.0
            };
          }
        };
      }
    }, {
      key: "colors",

      /**
       * @returns {Uint8Array} [r0, g0, b0, a0, r1, g1, b1, a1, ...]
       */
      get: function get() {
        return colors;
      }
      /**
       * @returns {Number[]} [low, high] bounds of this scale.
       */

    }, {
      key: "bounds",
      get: function get() {
        return bounds;
      }
    }]);

    return Scale;
  }())();
}

/***/ }),

/***/ "./src/palette/palettes.mjs":
/*!**********************************!*\
  !*** ./src/palette/palettes.mjs ***!
  \**********************************/
/*! exports provided: airdens, aurora, cape, co2, co2sc, cosc, currents, duexttau, htsgw, misery, mslp, pmx, precip, primaryWaves, rh, so2smass, sst, ssta, suexttau, tcw, temp, tpw, wind, wpd */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "airdens", function() { return airdens; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "aurora", function() { return aurora; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cape", function() { return cape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "co2", function() { return co2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "co2sc", function() { return co2sc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosc", function() { return cosc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "currents", function() { return currents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "duexttau", function() { return duexttau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "htsgw", function() { return htsgw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "misery", function() { return misery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mslp", function() { return mslp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pmx", function() { return pmx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "precip", function() { return precip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "primaryWaves", function() { return primaryWaves; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rh", function() { return rh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "so2smass", function() { return so2smass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sst", function() { return sst; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssta", function() { return ssta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "suexttau", function() { return suexttau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tcw", function() { return tcw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "temp", function() { return temp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tpw", function() { return tpw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wind", function() { return wind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wpd", function() { return wpd; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _airdens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./airdens */ "./src/palette/airdens.mjs");
/* harmony import */ var _aurora__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./aurora */ "./src/palette/aurora.mjs");
/* harmony import */ var _co2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./co2 */ "./src/palette/co2.mjs");
/* harmony import */ var _co2sc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./co2sc */ "./src/palette/co2sc.mjs");
/* harmony import */ var _cosc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cosc */ "./src/palette/cosc.mjs");
/* harmony import */ var _cape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cape */ "./src/palette/cape.mjs");
/* harmony import */ var _currents__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./currents */ "./src/palette/currents.mjs");
/* harmony import */ var _duexttau__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./duexttau */ "./src/palette/duexttau.mjs");
/* harmony import */ var _htsgw__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./htsgw */ "./src/palette/htsgw.mjs");
/* harmony import */ var _mslp__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./mslp */ "./src/palette/mslp.mjs");
/* harmony import */ var _misery__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./misery */ "./src/palette/misery.mjs");
/* harmony import */ var _pmx__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pmx */ "./src/palette/pmx.mjs");
/* harmony import */ var _precip__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./precip */ "./src/palette/precip.mjs");
/* harmony import */ var _primaryWaves__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./primaryWaves */ "./src/palette/primaryWaves.mjs");
/* harmony import */ var _rh__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./rh */ "./src/palette/rh.mjs");
/* harmony import */ var _so2smass__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./so2smass */ "./src/palette/so2smass.mjs");
/* harmony import */ var _ssta__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./ssta */ "./src/palette/ssta.mjs");
/* harmony import */ var _sst__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./sst */ "./src/palette/sst.mjs");
/* harmony import */ var _suexttau__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./suexttau */ "./src/palette/suexttau.mjs");
/* harmony import */ var _tcw__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./tcw */ "./src/palette/tcw.mjs");
/* harmony import */ var _tpw__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./tpw */ "./src/palette/tpw.mjs");
/* harmony import */ var _temp__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./temp */ "./src/palette/temp.mjs");
/* harmony import */ var _wpd__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./wpd */ "./src/palette/wpd.mjs");
/* harmony import */ var _wind__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./wind */ "./src/palette/wind.mjs");

























var airdens = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_airdens__WEBPACK_IMPORTED_MODULE_1__["default"]);
var aurora = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_aurora__WEBPACK_IMPORTED_MODULE_2__["default"]);
var cape = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_cape__WEBPACK_IMPORTED_MODULE_6__["default"]);
var co2 = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_co2__WEBPACK_IMPORTED_MODULE_3__["default"]);
var co2sc = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_co2sc__WEBPACK_IMPORTED_MODULE_4__["default"]);
var cosc = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_cosc__WEBPACK_IMPORTED_MODULE_5__["default"]);
var currents = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_currents__WEBPACK_IMPORTED_MODULE_7__["default"]);
var duexttau = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_duexttau__WEBPACK_IMPORTED_MODULE_8__["default"]);
var htsgw = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_htsgw__WEBPACK_IMPORTED_MODULE_9__["default"]);
var misery = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_misery__WEBPACK_IMPORTED_MODULE_11__["default"]);
var mslp = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_mslp__WEBPACK_IMPORTED_MODULE_10__["default"]);
var pmx = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_pmx__WEBPACK_IMPORTED_MODULE_12__["default"]);
var precip = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_precip__WEBPACK_IMPORTED_MODULE_13__["default"]);
var primaryWaves = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_primaryWaves__WEBPACK_IMPORTED_MODULE_14__["default"]);
var rh = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_rh__WEBPACK_IMPORTED_MODULE_15__["default"]);
var so2smass = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_so2smass__WEBPACK_IMPORTED_MODULE_16__["default"]);
var sst = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_sst__WEBPACK_IMPORTED_MODULE_18__["default"]);
var ssta = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_ssta__WEBPACK_IMPORTED_MODULE_17__["default"]);
var suexttau = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_suexttau__WEBPACK_IMPORTED_MODULE_19__["default"]);
var tcw = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_tcw__WEBPACK_IMPORTED_MODULE_20__["default"]);
var temp = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_temp__WEBPACK_IMPORTED_MODULE_22__["default"]);
var tpw = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_tpw__WEBPACK_IMPORTED_MODULE_21__["default"]);
var wind = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_wind__WEBPACK_IMPORTED_MODULE_24__["default"]);
var wpd = underscore__WEBPACK_IMPORTED_MODULE_0__.memoize(_wpd__WEBPACK_IMPORTED_MODULE_23__["default"]);

/***/ }),

/***/ "./src/palette/pmx.mjs":
/*!*****************************!*\
  !*** ./src/palette/pmx.mjs ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [1e-9, 1000e-9]; // units: µg/m3

  var logBounds = bounds.map(Math.log); // combination of colorbrewer YlGnBu and YlOrRd

  var stops = [{
    color: [8, 29, 88],
    mode: "hcl",
    p: logBounds[0]
  }, {
    color: [37, 52, 148],
    mode: "hcl",
    p: Math.log(4e-9)
  }, {
    color: [34, 94, 168],
    mode: "hcl",
    p: Math.log(6e-9)
  }, {
    color: [29, 145, 192],
    mode: "hcl",
    p: Math.log(8e-9)
  }, {
    color: [65, 182, 196],
    mode: "hcl",
    p: Math.log(10e-9)
  }, {
    color: [127, 205, 187],
    mode: "hcl",
    p: Math.log(16e-9)
  }, {
    color: [199, 233, 180],
    mode: "hcl",
    p: Math.log(24e-9)
  }, {
    color: [237, 248, 177],
    mode: "hcl",
    p: Math.log(28e-9)
  }, {
    color: [255, 255, 210],
    mode: "hcl",
    p: Math.log(32e-9)
  }, {
    color: [255, 237, 160],
    mode: "hcl",
    p: Math.log(42e-9)
  }, {
    color: [254, 217, 118],
    mode: "hcl",
    p: Math.log(47e-9)
  }, {
    color: [254, 178, 76],
    mode: "hcl",
    p: Math.log(57e-9)
  }, {
    color: [253, 141, 60],
    mode: "hcl",
    p: Math.log(67e-9)
  }, {
    color: [252, 78, 42],
    mode: "hcl",
    p: Math.log(110e-9)
  }, {
    color: [227, 26, 28],
    mode: "hcl",
    p: Math.log(250e-9)
  }, {
    color: [189, 0, 38],
    mode: "hcl",
    p: Math.log(500e-9)
  }, {
    color: [128, 0, 38],
    mode: "hcl",
    p: logBounds[1]
  }];
  var interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["interpolatorsFrom"](stops);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 7, [Math.log(30e-9), Math.log(35e-9)]);
  var colors = _palette__WEBPACK_IMPORTED_MODULE_0__["quantize"](logBounds, interpolators, resolution);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScale"](bounds, colors, Math.log, Math.exp);
});

/***/ }),

/***/ "./src/palette/precip.mjs":
/*!********************************!*\
  !*** ./src/palette/precip.mjs ***!
  \********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2000;
  var bounds = [0, 150]; // units: kg/m3 == mm

  var stops = [{
    color: [37, 79, 92],
    mode: "hcl",
    p: bounds[0]
  }, {
    color: "aliceblue",
    mode: "hcl",
    p: 2
  }, {
    color: [51, 26, 155],
    mode: "hcl",
    p: 15
  }, {
    color: "gold",
    mode: "hcl",
    p: 100
  }, {
    color: "white",
    mode: "hcl",
    p: bounds[1]
  }];
  var interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["interpolatorsFrom"](stops);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 0, [0.6, 3.4]);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 2, [12, 18]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromInterpolators"](bounds, interpolators, resolution);
});
/*
https://en.wikipedia.org/wiki/Rain#Intensity

Light rain — when the precipitation rate is < 2.5 mm (0.098 in) per hour
Moderate rain — when the precipitation rate is between 2.5 mm (0.098 in) - 7.6 mm (0.30 in) or 10 mm (0.39 in) per hour
Heavy rain — when the precipitation rate is > 7.6 mm (0.30 in) per hour, or between 10 mm (0.39 in) and 50 mm (2.0 in) per hour
Violent rain — when the precipitation rate is > 50 mm (2.0 in) per hour
*/

/***/ }),

/***/ "./src/palette/primaryWaves.mjs":
/*!**************************************!*\
  !*** ./src/palette/primaryWaves.mjs ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 25]; // units: seconds (period)

  var segments = [[0, [0, 0, 0]], [25, [21, 255, 255]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/rh.mjs":
/*!****************************!*\
  !*** ./src/palette/rh.mjs ***!
  \****************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 100]; // units: percent

  var segments = [[0, [230, 165, 30]], [25, [120, 100, 95]], [60, [40, 44, 92]], [75, [21, 13, 193]], [90, [75, 63, 235]], [100, [25, 255, 255]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/so2smass.mjs":
/*!**********************************!*\
  !*** ./src/palette/so2smass.mjs ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 400;
  //      v*1e-14
  //             1
  //         3,000  boat trail start
  //        20,000
  //       115,000  boat trail peak
  //       262,000     1 ppb
  //    19,650,000    75 ppb, EPA 1hr std limit
  //    65,500,000   250 ppb, Amer Conf of Gvt Indus Hygen short term exposure limit
  //   163,226,000   623 ppb, largest seen in 2 weeks of geos-driver
  //   484,962,000  1851 ppb, top of log scale
  // 1,310,000,000  5000 ppb, OSHA PEL
  var bounds = [10e-14, 88800000e-14]; // units: kg/m3

  var logBounds = bounds.map(Math.log);
  var stops = [{
    color: [134, 134, 107],
    mode: "hcl",
    p: logBounds[0]
  }, {
    color: [144, 144, 117],
    mode: "hcl",
    p: Math.log(100e-14)
  }, {
    color: [255, 255, 224],
    mode: "hcl",
    p: Math.log(7000e-14)
  }, {
    color: [0, 0, 128],
    mode: "lab",
    p: Math.log(19000000e-14)
  }, {
    color: [23, 20, 18],
    mode: "lab",
    p: logBounds[1]
  }];
  var interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["interpolatorsFrom"](stops);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 1, [Math.log(5000e-14), Math.log(9000e-14)]);
  interpolators = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](interpolators, 3, [Math.log(8000000e-14), Math.log(40000000e-14)]);
  var colors = _palette__WEBPACK_IMPORTED_MODULE_0__["quantize"](logBounds, interpolators, resolution);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScale"](bounds, colors, Math.log, Math.exp);
});

/***/ }),

/***/ "./src/palette/sst.mjs":
/*!*****************************!*\
  !*** ./src/palette/sst.mjs ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [270, 304.65]; // units: Kelvin

  var segments = [[270, [255, 255, 255]], [271.25, [255, 255, 255]], // -1.9 C sea water freeze
  [271.30, [15, 4, 168]], [273.15, [15, 54, 208]], // 0 C fresh water freeze
  [273.25, [15, 54, 188]], [275.65, [15, 4, 168]], // lower boundary for cool currents
  [281.65, [24, 132, 14]], // upper boundary for cool currents
  [291.15, [247, 251, 59]], // lower boundary for warm currents
  [295, [235, 167, 0]], [299.65, [245, 0, 39]], // minimum needed for tropical cyclone formation
  [303, [87, 17, 0]], [304.65, [238, 0, 242]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/ssta.mjs":
/*!******************************!*\
  !*** ./src/palette/ssta.mjs ***!
  \******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [-6, 6]; // units: Kelvin

  var segments = [[-6.0, [255, 255, 255]], [-3, [7, 252, 254]], [-1.5, [66, 42, 253]], [-0.75, [34, 55, 134]], [0, [0, 0, 6]], [0.75, [134, 55, 34]], [1.5, [253, 14, 16]], [3.0, [254, 252, 0]], [6.0, [255, 255, 255]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/suexttau.mjs":
/*!**********************************!*\
  !*** ./src/palette/suexttau.mjs ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;
  var bounds = [0.002, 2.500]; // units: τ

  var logBounds = bounds.map(Math.log);
  var interpolator = _palette__WEBPACK_IMPORTED_MODULE_0__["interpolateCubehelix"](logBounds);
  var colors = _palette__WEBPACK_IMPORTED_MODULE_0__["quantize"](logBounds, [interpolator], resolution);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScale"](bounds, colors, Math.log, Math.exp);
});

/***/ }),

/***/ "./src/palette/tcw.mjs":
/*!*****************************!*\
  !*** ./src/palette/tcw.mjs ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 1]; // units: kg/m2

  var segments = [[0.0, [5, 5, 89]], [0.2, [170, 170, 230]], [1.0, [255, 255, 255]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/temp.mjs":
/*!******************************!*\
  !*** ./src/palette/temp.mjs ***!
  \******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2000;
  var bounds = [193, 328]; // units: kelvins

  var segments = [[193, [37, 4, 42]], [206, [41, 10, 130]], [219, [81, 40, 40]], [233.15, [192, 37, 149]], // -40 C/F
  [255.372, [70, 215, 215]], // 0 F
  [273.15, [21, 84, 187]], // 0 C
  [275.15, [24, 132, 14]], // just above 0 C
  [291, [247, 251, 59]], [298, [235, 167, 21]], [311, [230, 71, 39]], [328, [88, 27, 67]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/tpw.mjs":
/*!*****************************!*\
  !*** ./src/palette/tpw.mjs ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 70]; // units: kg/m2

  var segments = [[0, [230, 165, 30]], [10, [120, 100, 95]], [20, [40, 44, 92]], [30, [21, 13, 193]], [40, [75, 63, 235]], [60, [25, 255, 255]], [70, [150, 255, 255]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/palette/wind.mjs":
/*!******************************!*\
  !*** ./src/palette/wind.mjs ***!
  \******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 100]; // units: m/s

  var array = new Uint8Array(resolution * 4);
  _palette__WEBPACK_IMPORTED_MODULE_0__["fillRange"](array, [0, 1], [0, 1], _palette__WEBPACK_IMPORTED_MODULE_0__["extendedSinebowColor"]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScale"](bounds, array);
});

/***/ }),

/***/ "./src/palette/wpd.mjs":
/*!*****************************!*\
  !*** ./src/palette/wpd.mjs ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./src/palette/palette.mjs");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10000;
  var bounds = [0, 80000]; // units: W/m2. CONSIDER: convert to log scale

  var segments = [[0, [15, 4, 96]], [250, [30, 8, 180]], [1000, [121, 102, 2]], [2000, [118, 161, 66]], [4000, [50, 102, 219]], [8000, [19, 131, 193]], [16000, [59, 204, 227]], [64000, [241, 1, 45]], [80000, [243, 0, 241]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./src/polyfills.mjs":
/*!***************************!*\
  !*** ./src/polyfills.mjs ***!
  \***************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var setimmediate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
/* harmony import */ var promise_polyfill_src_polyfill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! promise-polyfill/src/polyfill */ "./node_modules/promise-polyfill/src/polyfill.js");
/*
 * polyfills: polyfill global object with missing ES6+ features.
 */



if (!Math.sign) {
  // Needed for IE11.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
  Math.sign = function (x) {
    // If x is NaN, the result is NaN.
    // If x is -0, the result is -0.
    // If x is +0, the result is +0.
    // If x is negative and not -0, the result is -1.
    // If x is positive and not +0, the result is +1.
    return (x > 0) - (x < 0) || +x;
  };
}

/***/ }),

/***/ "./src/product/flatProduct.mjs":
/*!*************************************!*\
  !*** ./src/product/flatProduct.mjs ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./src/math.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./src/utc.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../grid/regular */ "./src/grid/regular.mjs");
/* harmony import */ var _interpolate_nearest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interpolate/nearest */ "./src/interpolate/nearest.mjs");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interpolate/bilinear */ "./src/interpolate/bilinear.mjs");
/* harmony import */ var _decoder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../decoder */ "./src/decoder.mjs");
/**
 * Processes a bundle using earth.nullschool.net/flat-1.0 conventions.
 */







/*
Example:

{
  "Conventions": "earth.nullschool.net/flat-1.0",
  "title": "Probability of Visible Aurora",
  "institution": "SWPC / NCEP / NWS / NOAA",
  "source": "OVATION Aurora Short Term Forecast",
  "references": "http://www.swpc.noaa.gov/products/aurora-30-minute-forecast",
  "units": "%",
  "date": "2018-01-29T14:10Z",
  "init": "2018-01-29T13:40Z",
  "lon": {
    "start": -180,
    "delta": 0.3515625,
    "size": 1024
  },
  "lat": {
    "start": -89.82421875,
    "delta": 0.3515625,
    "size": 512
  },
  "encoding": {"type": "packed_delta_rle"},
  "data": [
    [[0,1024]]
  ]
}

*/

/* harmony default export */ __webpack_exports__["default"] = (function (bundle) {
  var conventions = bundle.Conventions,
      title = bundle.title,
      institution = bundle.institution,
      source = bundle.source,
      references = bundle.references,
      units = bundle.units,
      _date = bundle.date,
      init = bundle.init,
      encoding = bundle.encoding;

  if (conventions !== "earth.nullschool.net/flat-1.0") {
    throw new Error("Unsupported data conventions: ".concat(underscore__WEBPACK_IMPORTED_MODULE_2__.escape(conventions)));
  } // Protect against malicious values.


  var lon = {
    start: +bundle.lon.start,
    delta: +bundle.lon.delta,
    size: Object(_math__WEBPACK_IMPORTED_MODULE_0__["clamp"])(+bundle.lon.size, 0, 8192)
  };
  var lat = {
    start: +bundle.lat.start,
    delta: +bundle.lat.delta,
    size: Object(_math__WEBPACK_IMPORTED_MODULE_0__["clamp"])(+bundle.lat.size, 0, 8192)
  };
  var rows = Array.isArray(bundle.data) ? bundle.data : [];

  var decodeRow = function decodeRow(row) {
    return row;
  };

  if (encoding) {
    switch (encoding.type) {
      case "packed_delta_rle":
        var _encoding$scale_facto = encoding.scale_factor,
            scale_factor = _encoding$scale_facto === void 0 ? 1 : _encoding$scale_facto,
            _encoding$add_offset = encoding.add_offset,
            add_offset = _encoding$add_offset === void 0 ? 0 : _encoding$add_offset;

        decodeRow = function decodeRow(row) {
          return _decoder__WEBPACK_IMPORTED_MODULE_6__["decodePackedDeltaRle"](row, +scale_factor, +add_offset, lon.size);
        };

        break;

      default:
        throw new Error("Unsupported encoding: ".concat(underscore__WEBPACK_IMPORTED_MODULE_2__.escape(encoding.type)));
    }
  }

  var data = new Float32Array(lon.size * lat.size);
  var i = 0;
  rows.filter(Array.isArray).forEach(function (row) {
    var decoded = decodeRow(row);
    data.set(decoded, i);
    i += decoded.length;
  });

  var _grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_3__["default"])(lon, lat);

  var interpolators = {
    type: "scalar",
    valueAt: function valueAt(i) {
      return data[i];
    },
    nearest: _interpolate_nearest__WEBPACK_IMPORTED_MODULE_4__["scalar"](_grid, data),
    bilinear: _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_5__["scalar"](_grid, data)
  };
  return {
    sourceHTML: underscore__WEBPACK_IMPORTED_MODULE_2__.escape(source),
    date: function date() {
      return _utc__WEBPACK_IMPORTED_MODULE_1__["parts"](_date);
    },
    grid: function grid() {
      return _grid;
    },
    field: function field() {
      return interpolators;
    },
    interpolate: function interpolate(coord) {
      return interpolators.bilinear(coord);
    }
  };
});

/***/ }),

/***/ "./src/product/gfs-wind.mjs":
/*!**********************************!*\
  !*** ./src/product/gfs-wind.mjs ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./src/utc.mjs");
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grid/regular */ "./src/grid/regular.mjs");
/* harmony import */ var _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interpolate/nearest */ "./src/interpolate/nearest.mjs");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interpolate/bilinear */ "./src/interpolate/bilinear.mjs");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./src/product/util.mjs");
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./strings */ "./src/product/strings.mjs");







/* harmony default export */ __webpack_exports__["default"] = (function (file) {
  if (Array.isArray(file)) {
    file = _util__WEBPACK_IMPORTED_MODULE_5__["munge"](file, ["u", "v"], ["time", "level", "lat", "lon"]);
  }

  var epak = file,
      header = epak.header,
      vars = header.variables;
  var u = vars["U"] || vars["u"] || vars["u-component_of_wind_isobaric"] || vars["u-component_of_wind_height_above_ground"];
  var v = vars["V"] || vars["v"] || vars["v-component_of_wind_isobaric"] || vars["v-component_of_wind_height_above_ground"]; // dims are: time,level,lat,lon

  var time = vars[u.dimensions[0]];
  var lat = vars[u.dimensions[2]];
  var lon = vars[u.dimensions[3]];
  var data = _micro__WEBPACK_IMPORTED_MODULE_0__["merge"](epak.blocks[u.data.block], epak.blocks[v.data.block]);

  var _grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_2__["default"])(lon.sequence, lat.sequence);

  var defaultInterpolator = _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data);
  return {
    sourceHTML: _strings__WEBPACK_IMPORTED_MODULE_6__["gfs"],
    date: function date() {
      return _utc__WEBPACK_IMPORTED_MODULE_1__["parts"](time.data[0]);
    },
    grid: function grid() {
      return _grid;
    },
    field: function field() {
      return {
        type: "vector",
        valueAt: function valueAt(i) {
          var j = i * 2;
          var u = data[j];
          var v = data[j + 1];
          return [u, v, Math.sqrt(u * u + v * v)];
        },
        nearest: _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__["vector"](_grid, data),
        bilinear: _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data)
      };
    },
    interpolate: function interpolate(coord) {
      return defaultInterpolator(coord);
    }
  };
});

/***/ }),

/***/ "./src/product/gfs-wpd.mjs":
/*!*********************************!*\
  !*** ./src/product/gfs-wpd.mjs ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _gfs_wind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gfs-wind */ "./src/product/gfs-wind.mjs");
/* harmony import */ var _scalarProduct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalarProduct */ "./src/product/scalarProduct.mjs");
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strings */ "./src/product/strings.mjs");




/* harmony default export */ __webpack_exports__["default"] = (function (windFile, airdensFile) {
  var windGrid = Object(_gfs_wind__WEBPACK_IMPORTED_MODULE_1__["default"])(windFile);
  var airdensGrid = Object(_scalarProduct__WEBPACK_IMPORTED_MODULE_2__["default"])(airdensFile, /air_density/, _strings__WEBPACK_IMPORTED_MODULE_3__["gfs"], ["air_density"]);
  var windValueAt = windGrid.field().valueAt;
  var windNearest = windGrid.field().nearest;
  var windBilinear = windGrid.field().bilinear;
  var airdensValueAt = airdensGrid.field().valueAt;
  var airdensNearest = airdensGrid.field().nearest;
  var airdensBilinear = airdensGrid.field().bilinear;

  function wpd(wind, ρ) {
    var m = wind[2];
    return 0.5 * ρ * m * m * m;
  }

  function valueAt(i) {
    return wpd(windValueAt(i), airdensValueAt(i));
  }

  function nearest(coord) {
    return wpd(windNearest(coord), airdensNearest(coord));
  }

  function bilinear(coord) {
    return wpd(windBilinear(coord), airdensBilinear(coord));
  }

  return _micro__WEBPACK_IMPORTED_MODULE_0__["assign"](airdensGrid, {
    field: function field() {
      return {
        type: "scalar",
        valueAt: valueAt,
        nearest: nearest,
        bilinear: bilinear
      };
    },
    interpolate: function interpolate(coord) {
      return bilinear(coord);
    }
  });
});

/***/ }),

/***/ "./src/product/oscar.mjs":
/*!*******************************!*\
  !*** ./src/product/oscar.mjs ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./src/utc.mjs");
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grid/regular */ "./src/grid/regular.mjs");
/* harmony import */ var _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interpolate/nearest */ "./src/interpolate/nearest.mjs");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interpolate/bilinear */ "./src/interpolate/bilinear.mjs");
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./strings */ "./src/product/strings.mjs");






/* harmony default export */ __webpack_exports__["default"] = (function (file) {
  var epak = file,
      header = epak.header,
      vars = header.variables;
  var u = vars["u"];
  var v = vars["v"]; // dims are: time,depth,lat,lon

  var time = vars[u.dimensions[0]];
  var lat = vars[u.dimensions[2]];
  var lon = vars[u.dimensions[3]];
  var data = _micro__WEBPACK_IMPORTED_MODULE_0__["merge"](epak.blocks[u.data.block], epak.blocks[v.data.block]);

  var _grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_2__["default"])(lon.sequence, lat.sequence);

  var defaultInterpolator = _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data);
  return {
    sourceHTML: _strings__WEBPACK_IMPORTED_MODULE_5__["oscar"],
    date: function date() {
      return _utc__WEBPACK_IMPORTED_MODULE_1__["parts"](time.data[0]);
    },
    grid: function grid() {
      return _grid;
    },
    field: function field() {
      return {
        type: "vector",
        valueAt: function valueAt(i) {
          var j = i * 2;
          var u = data[j];
          var v = data[j + 1];
          return [u, v, Math.sqrt(u * u + v * v)];
        },
        nearest: _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__["vector"](_grid, data),
        bilinear: _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data)
      };
    },
    interpolate: function interpolate(coord) {
      return defaultInterpolator(coord);
    }
  };
});

/***/ }),

/***/ "./src/product/scalarProduct.mjs":
/*!***************************************!*\
  !*** ./src/product/scalarProduct.mjs ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./src/utc.mjs");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/product/util.mjs");
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../grid/regular */ "./src/grid/regular.mjs");
/* harmony import */ var _interpolate_nearest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interpolate/nearest */ "./src/interpolate/nearest.mjs");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interpolate/bilinear */ "./src/interpolate/bilinear.mjs");






/* harmony default export */ __webpack_exports__["default"] = (function (bundle, selector, centerName, keys, transform) {
  // Assumes dimension structure of: [time, ..., lat, lon]
  if (Array.isArray(bundle)) {
    bundle = _util__WEBPACK_IMPORTED_MODULE_2__["munge"](bundle, keys);
  }

  if (!bundle.blocks) {
    bundle = _util__WEBPACK_IMPORTED_MODULE_2__["blockify"](bundle, selector);
  }

  var epak = bundle,
      header = epak.header,
      vars = header.variables;

  var x = underscore__WEBPACK_IMPORTED_MODULE_0__.find(Object.keys(vars), function (e) {
    return selector.test(e);
  });

  var target = vars[x];
  var dims = target.dimensions;
  var time = vars[dims[0]];

  var lat = vars[underscore__WEBPACK_IMPORTED_MODULE_0__.last(dims, 2)[0]];

  var lon = vars[underscore__WEBPACK_IMPORTED_MODULE_0__.last(dims, 2)[1]];

  var data = epak.blocks[target.data.block];

  if (underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction(transform)) {
    transform(data);
  }

  var _grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_3__["default"])(lon.sequence, lat.sequence);

  var interpolators = {
    type: "scalar",
    valueAt: function valueAt(i) {
      return data[i];
    },
    nearest: _interpolate_nearest__WEBPACK_IMPORTED_MODULE_4__["scalar"](_grid, data),
    bilinear: _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_5__["scalar"](_grid, data)
  };
  return {
    sourceHTML: centerName,
    date: function date() {
      return _utc__WEBPACK_IMPORTED_MODULE_1__["parts"](time.data[0]);
    },
    grid: function grid() {
      return _grid;
    },
    field: function field() {
      return interpolators;
    },
    interpolate: function interpolate(coord) {
      return interpolators.bilinear(coord);
    }
  };
});

/***/ }),

/***/ "./src/product/strings.mjs":
/*!*********************************!*\
  !*** ./src/product/strings.mjs ***!
  \*********************************/
/*! exports provided: argo, cams, geos, geosAdjustedCO2, gfs, hrrr, oscar, ovation, rtgsst, ww3 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argo", function() { return argo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cams", function() { return cams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geos", function() { return geos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geosAdjustedCO2", function() { return geosAdjustedCO2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gfs", function() { return gfs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hrrr", function() { return hrrr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oscar", function() { return oscar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ovation", function() { return ovation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rtgsst", function() { return rtgsst; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ww3", function() { return ww3; });
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./src/micro.mjs");

var co2Link = _micro__WEBPACK_IMPORTED_MODULE_0__["isKioskMode"]() ? "" : " [<a href='about.html#co2' class='internal-link'>important note</a>]";
var argo = "Argo";
var cams = "CAMS / Copernicus / EC + ECMWF";
var geos = "GEOS-5 / GMAO / NASA";
var geosAdjustedCO2 = "GEOS-5 / GMAO / NASA" + co2Link;
var gfs = "GFS / NCEP / US National Weather Service";
var hrrr = "HRRR / NCEP / US National Weather Service";
var oscar = "OSCAR / Earth & Space Research";
var ovation = "OVATION / SWPC / NCEP / NWS / NOAA";
var rtgsst = "RTG-SST / NCEP / US National Weather Service";
var ww3 = "WAVEWATCH III / NCEP / NWS";

/***/ }),

/***/ "./src/product/util.mjs":
/*!******************************!*\
  !*** ./src/product/util.mjs ***!
  \******************************/
/*! exports provided: munge, blockify */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "munge", function() { return munge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blockify", function() { return blockify; });
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utc */ "./src/utc.mjs");

/**
 * Makes an old-style grib2json file look like an epak file
 *
 * @param {Array} records the grib2json payload.
 * @param {string[]} varNames the variable names associated with the grib2json records.
 * @param {string[]?} dimensions the dimensions to inject the header, or ["time", "lat", "lon"] by default.
 * @returns {Object} an epak-like structure.
 */

function munge(records, varNames, dimensions) {
  var header = records[0].header;
  var validTime = _utc__WEBPACK_IMPORTED_MODULE_0__["add"](_utc__WEBPACK_IMPORTED_MODULE_0__["parts"](header.refTime), {
    hour: header.forecastTime
  });
  var variables = {
    time: {
      data: [_utc__WEBPACK_IMPORTED_MODULE_0__["printISO"](validTime)]
    },
    lat: {
      sequence: {
        start: header.la1,
        delta: -header.dy,
        size: header.ny
      }
    },
    lon: {
      sequence: {
        start: header.lo1,
        delta: header.dx,
        size: header.nx
      }
    }
  };
  var blocks = [];
  varNames.forEach(function (key, i) {
    variables[key] = {
      dimensions: dimensions || ["time", "lat", "lon"],
      data: {
        block: i
      }
    };
    blocks[i] = new Float32Array(records[i].data);
  });
  return {
    header: {
      variables: variables
    },
    blocks: blocks
  };
}
/**
 * Some early epaks did not use binary blocks, so convert them into the expected form.
 */

function blockify(epak, selector) {
  var variables = epak.variables;
  var blocks = [];
  Object.keys(variables).forEach(function (key) {
    if (selector.test(key)) {
      var v = variables[key];
      blocks.push(new Float32Array(v.data));
      v.data = {
        block: blocks.length - 1
      };
    }
  });
  return {
    header: epak,
    blocks: blocks
  };
}

/***/ }),

/***/ "./src/product/ww3-primary.mjs":
/*!*************************************!*\
  !*** ./src/product/ww3-primary.mjs ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../consts */ "./src/consts.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./src/utc.mjs");
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grid/regular */ "./src/grid/regular.mjs");
/* harmony import */ var _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interpolate/nearest */ "./src/interpolate/nearest.mjs");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interpolate/bilinear */ "./src/interpolate/bilinear.mjs");
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./strings */ "./src/product/strings.mjs");






/* harmony default export */ __webpack_exports__["default"] = (function (file) {
  var epak = file,
      header = epak.header,
      vars = header.variables;
  var direction = vars["Primary_wave_direction_surface"];
  var period = vars["Primary_wave_mean_period_surface"]; // dims are: time,lat,lon

  var time = vars[direction.dimensions[0]];
  var lat = vars[direction.dimensions[1]];
  var lon = vars[direction.dimensions[2]];
  var dirData = epak.blocks[direction.data.block];
  var perData = epak.blocks[period.data.block];
  var data = new Float32Array(dirData.length * 2);

  for (var i = 0; i < dirData.length; i++) {
    var j = i * 2;
    var φ = dirData[i] * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"]; // wave direction in radians

    var m = perData[i]; // wave period (treated as velocity)

    if (φ < 7e37 && m < 7e37) {
      data[j] = -m * Math.sin(φ);
      data[j + 1] = -m * Math.cos(φ);
    } else {
      data[j] = data[j + 1] = 7e37;
    }
  }

  var _grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_2__["default"])(lon.sequence, lat.sequence);

  var defaultInterpolator = _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data);
  return {
    sourceHTML: _strings__WEBPACK_IMPORTED_MODULE_5__["ww3"],
    date: function date() {
      return _utc__WEBPACK_IMPORTED_MODULE_1__["parts"](time.data[0]);
    },
    grid: function grid() {
      return _grid;
    },
    field: function field() {
      return {
        type: "vector",
        valueAt: function valueAt(i) {
          var j = i * 2;
          var u = data[j];
          var v = data[j + 1];
          return [u, v, Math.sqrt(u * u + v * v)];
        },
        nearest: _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__["vector"](_grid, data),
        bilinear: _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data)
      };
    },
    interpolate: function interpolate(coord) {
      return defaultInterpolator(coord);
    }
  };
});

/***/ }),

/***/ "./src/products.mjs":
/*!**************************!*\
  !*** ./src/products.mjs ***!
  \**************************/
/*! exports provided: products */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "products", function() { return products; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./d3 */ "./src/d3.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./micro */ "./src/micro.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utc */ "./src/utc.mjs");
/* harmony import */ var _clock__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./clock */ "./src/clock.mjs");
/* harmony import */ var _product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./product/scalarProduct */ "./src/product/scalarProduct.mjs");
/* harmony import */ var _product_flatProduct__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./product/flatProduct */ "./src/product/flatProduct.mjs");
/* harmony import */ var _product_strings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./product/strings */ "./src/product/strings.mjs");
/* harmony import */ var _product_oscar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./product/oscar */ "./src/product/oscar.mjs");
/* harmony import */ var _product_ww3_primary__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./product/ww3-primary */ "./src/product/ww3-primary.mjs");
/* harmony import */ var _product_gfs_wind__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./product/gfs-wind */ "./src/product/gfs-wind.mjs");
/* harmony import */ var _product_gfs_wpd__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./product/gfs-wpd */ "./src/product/gfs-wpd.mjs");
/* harmony import */ var _palette_palettes__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./palette/palettes */ "./src/palette/palettes.mjs");
/**
 * products - defines the behavior of weather data grids, including grid construction, interpolation, and color scales.
 *
 * Copyright (c) 2018 Cameron Beccario
 *
 * For a free version of this project, see https://github.com/cambecc/earth
 */













var products = {};
!function () {
  var CUTOFF = new Date("2016-02-20");

  function gaia(path) {
    var host = _micro__WEBPACK_IMPORTED_MODULE_2__["isDevMode"]() ? "" : "http://localhost:3000",
        url = host + path,
        instance = _micro__WEBPACK_IMPORTED_MODULE_2__["siteInstance"]();
    return instance ? url + "?" + instance : url;
  }

  function old(path) {
    return "https://earth.nullschool.net" + path;
  }

  products.gaia = gaia;

  function geosUrl(path, date) {
    return date < CUTOFF ? old("/data/geos/" + path) : gaia("/data/geos/" + path);
  }

  function gfsUrl(path, date) {
    return date < CUTOFF ? old("/data/weather/" + path) : gaia("/data/gfs/" + path);
  }

  function oscarUrl(path) {
    return gaia("/data/oscar/" + path);
  }

  function rtgsstUrl(path, date) {
    return date < CUTOFF ? old("/data/ocean/" + path) : gaia("/data/rtgsst/" + path);
  }

  function ww3Url(path, date) {
    return date < CUTOFF ? old("/data/ocean/" + path) : gaia("/data/ww3/" + path);
  }

  function argoUrl(path) {
    return gaia("/data/argo/" + path);
  }

  var aotLink = _micro__WEBPACK_IMPORTED_MODULE_2__["isKioskMode"]() ? "" : "(<a href='about.html#aot' class='internal-link'>AOT</a>)";

  function buildProduct(overrides) {
    return _micro__WEBPACK_IMPORTED_MODULE_2__["assign"]({
      descriptionHTML: "",
      paths: [],

      /** @returns {Object} the product's date parts. */
      date: function date() {
        return null;
      },

      /**
       * @param {number} step the number of steps away: ±1 or ±10
       * @returns {Object} the date parts for the specified number of steps away from this product's date.
       */
      navigate: function navigate(step) {
        return gfsStep(this.date(), step);
      },

      /**
       * @param {Object} date the desired date parts or the string "current".
       * @returns {Object} the actual date parts.
       */
      navigateTo: function navigateTo(date) {
        return gfsDate(date);
      },
      loader: function loader(path) {
        return /\.epak([/?#]|$)/.test(path) ? _micro__WEBPACK_IMPORTED_MODULE_2__["loadEpak"](path) : _micro__WEBPACK_IMPORTED_MODULE_2__["loadJson"](path);
      },
      load: function load(cancel) {
        var me = this;
        return Promise.all(this.paths.map(this.loader)).then(function (files) {
          return cancel.requested ? null : _micro__WEBPACK_IMPORTED_MODULE_2__["assign"](me, me.builder.apply(me, files));
        });
      },
      alpha: {
        single: 160,
        animated: 112
      }
    }, overrides);
  }
  /**
   * @param {Object} date either the date parts or the string "current"
   * @param {Object?} offset the time offset from the normal GFS time (e.g., {minute: 90} for 3hr time avg)
   * @returns {Object} the best matching date parts.
   */


  function gfsDate(date, offset) {
    var parts = date === "current" ? underscore__WEBPACK_IMPORTED_MODULE_0__.pick(_utc__WEBPACK_IMPORTED_MODULE_3__["parts"](_clock__WEBPACK_IMPORTED_MODULE_4__["now"]()), "year", "month", "day", "hour") : // use current time
    underscore__WEBPACK_IMPORTED_MODULE_0__.clone(date); // round down to the nearest three-hour block

    parts.hour = Math.floor(parts.hour / 3) * 3;
    parts.minute = 0;

    if (offset) {
      parts = _utc__WEBPACK_IMPORTED_MODULE_3__["normalize"](_utc__WEBPACK_IMPORTED_MODULE_3__["add"](parts, offset));
    }

    return parts;
  }
  /**
   * Returns date parts for the chronologically next or previous GFS data layer. How far forward or backward in time
   * to jump is determined by the step. Steps of ±1 move in 3-hour jumps, and steps of ±10 move in 24-hour jumps.
   *
   * @param {Object} date the starting date parts.
   * @param {number} step the number of steps.
   * @returns {Object} the resulting date parts.
   */


  function gfsStep(date, step) {
    var offset = (step > 1 ? 8 : step < -1 ? -8 : step) * 3;
    return _utc__WEBPACK_IMPORTED_MODULE_3__["add"](date, {
      hour: offset
    });
  }

  function gfsPathParts(attr, offset) {
    if (attr.date === "current") {
      return {
        dir: "current",
        stamp: "current",
        date: gfsDate(attr.date, offset)
      };
    }

    var date = gfsDate(attr.date, offset);
    return {
      dir: _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{yyyy}/{MM}/{dd}"),
      stamp: _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{hh}{mm}"),
      date: date
    };
  }
  /**
   * @param attr
   * @param {String} type
   * @param {String?} surface
   * @param {String?} level
   * @returns {String}
   */


  function gfsPath(attr, type, surface, level) {
    var parts = gfsPathParts(attr),
        date = _utc__WEBPACK_IMPORTED_MODULE_3__["date"](parts.date);
    var format = date >= new Date("2014/11/24") ? ".epak" : ".json";
    var res = "0.5";

    if (date < new Date("2015/03/11") || _micro__WEBPACK_IMPORTED_MODULE_2__["isEmbeddedInIFrame"]() && !_micro__WEBPACK_IMPORTED_MODULE_2__["isKioskMode"]()) {
      res = "1.0";
    } else if (date > new Date("2016/06/22") && attr.hd) {
      res = "0.25";
    }

    var file = [parts.stamp, type, surface, level, "gfs", res].filter(_micro__WEBPACK_IMPORTED_MODULE_2__["isValue"]).join("-") + format;
    return gfsUrl(parts.dir + "/" + file, date);
  }
  /*
      function hrrrDate(date, offset) {
          const parts = date === "current" ?
              _.pick(utc.parts(clock.now()), "year", "month", "day", "hour") :  // use current time
              _.clone(date);
          // round down to the nearest 15-minute block
          parts.hour = Math.floor(parts.hour);
          parts.minute = Math.floor((parts.minute | 0) / 15) * 15;
          console.log("hrrrDate", parts);
          if (offset) {
              parts = utc.normalize(utc.add(parts, offset));
          }
          return parts;
      }
  
      function hrrrStep(date, step) {
          const offset = (step > 1 ? 8 : step < -1 ? -8 : step) * 15;
          console.log(date, offset, utc.add(date, {minute: offset}));
  
          return utc.add(date, {minute: offset});
      }
  
      function hrrrPath(attr, type, surface, level) {
          const date = hrrrDate(attr.date), isCurrent = attr.date === "current";
          const dir = isCurrent ? "current" : utc.print(date, "{yyyy}/{MM}/{dd}");
          const stamp = isCurrent ? "current" : utc.print(date, "{hh}{mm}");
          const file = [stamp, type, surface, level, "hrrr"].filter(e=>e).join("-");
          return gaia(`/data/hrrr/${dir}/${file}.epak`);
      }
  */


  function geosPath(attr, type, offset) {
    var parts = gfsPathParts(attr, offset),
        date = _utc__WEBPACK_IMPORTED_MODULE_3__["date"](parts.date);
    var file = [parts.stamp, type, "geos.epak"].join("-");
    return geosUrl(parts.dir + "/" + file, date);
  }

  function camsDate(date, stride) {
    var _ref = date === "current" ? _utc__WEBPACK_IMPORTED_MODULE_3__["parts"](_clock__WEBPACK_IMPORTED_MODULE_4__["now"]()) : date,
        year = _ref.year,
        month = _ref.month,
        day = _ref.day,
        hour = _ref.hour;

    return {
      year: year,
      month: month,
      day: day,
      hour: Math.floor(hour / stride) * stride,
      minute: 0
    };
  }

  function camsStep(date, stride, step) {
    var offset = (step > 1 ? 8 : step < -1 ? -8 : step) * stride;
    return _utc__WEBPACK_IMPORTED_MODULE_3__["add"](date, {
      hour: offset
    });
  }

  function camsPath(attr, param, stride) {
    var date = camsDate(attr.date, stride),
        isCurrent = attr.date === "current";
    var dir = isCurrent ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{yyyy}/{MM}/{dd}");
    var stamp = isCurrent ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{hh}{mm}");
    return gaia("/data/cams/".concat(dir, "/").concat(stamp, "-").concat(param, "-cams.epak"));
  }

  function wave30mPath(attr, type, surface, level) {
    var parts = gfsPathParts(attr),
        date = _utc__WEBPACK_IMPORTED_MODULE_3__["date"](parts.date);
    var file = [parts.stamp, type, surface, level, "wave", "30m"].filter(_micro__WEBPACK_IMPORTED_MODULE_2__["isValue"]).join("-") + ".epak";
    return ww3Url(parts.dir + "/" + file, date);
  }
  /**
   * Returns the file name for the most recent OSCAR data layer to the specified date. If offset is non-zero,
   * the file name that many entries from the most recent is returned.
   *
   * The result is undefined if there is no entry for the specified date and offset can be found.
   *
   * UNDONE: the catalog object itself should encapsulate this logic. GFS can also be a "virtual" catalog, and
   *         provide a mechanism for eliminating the need for /data/weather/current/* files.
   *
   * @param {Array} catalog array of file names, sorted and prefixed with yyyyMMdd. Last item is most recent.
   * @param {Object} date parts or "current"
   * @param {Number?} offset
   * @returns {String} file name
   */


  function lookupOscar(catalog, date, offset) {
    offset = +offset || 0;

    if (date === "current") {
      return catalog[catalog.length - 1 + offset];
    }

    var prefix = _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{yyyy}{MM}{dd}");

    var i = underscore__WEBPACK_IMPORTED_MODULE_0__.sortedIndex(catalog, prefix);

    i = (catalog[i] || "").indexOf(prefix) === 0 ? i : i - 1;
    return catalog[i + offset];
  }
  /**
   * @param catalog
   * @param date the date parts
   * @returns {Object} date parts
   */


  function oscarDate(catalog, date) {
    var file = lookupOscar(catalog, date);
    return file ? _utc__WEBPACK_IMPORTED_MODULE_3__["parse"](file, /(\d{4})(\d\d)(\d\d)/) : null;
  }
  /**
   * @param {Array} catalog array of file names, sorted and prefixed with yyyyMMdd. Last item is most recent.
   * @param {Object} date parts or the string "current".
   * @param {number} step
   * @returns {Object} the chronologically next or previous OSCAR data layer. How far forward or backward in
   * time to jump is determined by the step and the catalog of available layers. A step of ±1 moves to the
   * next/previous entry in the catalog (about 5 days), and a step of ±10 moves to the entry six positions away
   * (about 30 days).
   */


  function oscarStep(catalog, date, step) {
    var file = lookupOscar(catalog, date, step > 1 ? 6 : step < -1 ? -6 : step);
    return file ? _utc__WEBPACK_IMPORTED_MODULE_3__["parse"](file, /(\d{4})(\d\d)(\d\d)/) : null;
  }

  function oscarPath(catalog, attr) {
    var file = lookupOscar(catalog, attr.date);
    return file ? oscarUrl(file) : null;
  }

  function fetchOscarCatalog() {
    // The OSCAR catalog is an array of file names, sorted and prefixed with yyyyMMdd. Last item is the
    // most recent. For example: [ 20140101-abc.epak, 20140106-abc.epak, 20140112-abc.epak, ... ]
    return _micro__WEBPACK_IMPORTED_MODULE_2__["loadJsonOnce"](oscarUrl("oscar-catalog.json"));
  }

  function rtgDate(date) {
    var parts;

    if (date === "current") {
      // Each day, SST data for the previous day is made available. So "current" means yesterday.
      var now = underscore__WEBPACK_IMPORTED_MODULE_0__.pick(_utc__WEBPACK_IMPORTED_MODULE_3__["parts"](_clock__WEBPACK_IMPORTED_MODULE_4__["now"]()), "year", "month", "day");

      parts = _utc__WEBPACK_IMPORTED_MODULE_3__["add"](now, {
        day: -1
      });
    } else {
      parts = underscore__WEBPACK_IMPORTED_MODULE_0__.clone(date);
    }

    return parts;
  }
  /**
   * Returns a date for the chronologically next or previous RTG SST data layer. How far forward or backward in time
   * to jump is determined by the step. Steps of ±1 move in 1 day jumps, and steps of ±10 move in 5-day jumps.
   */


  function rtgStep(date, step) {
    var offset = step > 1 ? 5 : step < -1 ? -5 : step;
    return _utc__WEBPACK_IMPORTED_MODULE_3__["add"](date, {
      day: offset
    });
  }
  /**
   * @param attr
   * @param {String} type
   * @param {String?} surface
   * @param {String?} level
   * @returns {String}
   */


  function rtgPath(attr, type, surface, level) {
    var date = _utc__WEBPACK_IMPORTED_MODULE_3__["date"](rtgDate(attr.date));
    var dir = attr.date === "current" ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](attr.date, "{yyyy}/{MM}");
    var stamp = dir === "current" ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](attr.date, "{yyyy}{MM}{dd}");
    var file = [stamp, type, surface, level, "rtg", "0.5"].filter(_micro__WEBPACK_IMPORTED_MODULE_2__["isValue"]).join("-") + ".epak";
    return rtgsstUrl(dir + "/" + file, date);
  }

  function ovationDate(date) {
    var _ref2 = date === "current" ? _utc__WEBPACK_IMPORTED_MODULE_3__["parts"](_clock__WEBPACK_IMPORTED_MODULE_4__["now"]()) : date,
        year = _ref2.year,
        month = _ref2.month,
        day = _ref2.day,
        hour = _ref2.hour,
        minute = _ref2.minute;

    return {
      year: year,
      month: month,
      day: day,
      hour: hour,
      minute: Math.floor(minute / 5) * 5
    };
  }

  function ovationStep(date, step) {
    var offset = step > 1 ? 12 : step < -1 ? -12 : step;
    return _utc__WEBPACK_IMPORTED_MODULE_3__["normalize"](_utc__WEBPACK_IMPORTED_MODULE_3__["add"](date, {
      minute: offset * 5
    }));
  }

  function ovationPath(attr) {
    var date = ovationDate(attr.date),
        isCurrent = attr.date === "current";
    var dir = isCurrent ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{yyyy}/{MM}/{dd}");
    var stamp = isCurrent ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{yyyy}{MM}{dd}{hh}{mm}");
    return gaia("/data/ovation/".concat(dir, "/").concat(stamp, "-ovation.json"));
  }
  /*
      /!**
       * @param {Object} date the date parts or the string "current"
       * @returns {Object} the actual date parts
       *!/
      function argoDate(date) {
          const parts = date === "current" ?
              _.pick(utc.parts(clock.now()), "year", "month") :  // use current time
              _.clone(date);
          return utc.normalize(parts);
      }
  
      /!**
       * @param {Object} date the date parts
       * @param {number} step the number of steps away: ±1 or ±10
       *!/
      function argoStep(date, step) {
          return utc.add(date, {month: step < 0 ? -1 : 1});
      }
  
      function argoPath(date, type, pressureLevel) {
          date = argoDate(date);
          const dir = "https://data.scripps.earth/argo/" + utc.print(date, "{yyyy}/");
          // const dir = "/data/argo/" + utc.print(date, "{yyyy}/");
          const file = ["argo", utc.print(date, "{yyyy}{MM}"), type, pressureLevel, "1p0"].join("-") + ".json";
          return dir + file;
      }
  */


  function describeSurface(attr) {
    return attr.surface === "surface" ? "Surface" : _micro__WEBPACK_IMPORTED_MODULE_2__["capitalize"](attr.level);
  }

  function describeSurfaceJa(attr) {
    return attr.surface === "surface" ? "地上" : _micro__WEBPACK_IMPORTED_MODULE_2__["capitalize"](attr.level);
  }
  /**
   * Returns a function f(langCode) that, given table:
   *     {foo: {en: "A", ja: "あ"}, bar: {en: "I", ja: "い"}}
   * will return the following when called with "en":
   *     {foo: "A", bar: "I"}
   * or when called with "ja":
   *     {foo: "あ", bar: "い"}
   */


  function localize(table) {
    return function (langCode) {
      var result = {};

      underscore__WEBPACK_IMPORTED_MODULE_0__.forEach(table, function (value, key) {
        result[key] = value[langCode] || value.en || value;
      });

      return result;
    };
  }

  function localizeString(table) {
    return table[_micro__WEBPACK_IMPORTED_MODULE_2__["siteLangCode"]()] || table.en;
  }

  var FACTORIES = {
    "wind": {
      matchesPrimary: function matchesPrimary() {
        return true;
      },
      // HACK: default matcher, must come first.
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "wind"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "wind",
          descriptionHTML: localize({
            name: {
              en: "Wind",
              ja: "風速"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: "＠" + describeSurfaceJa(attr)
            }
          }),
          paths: [gfsPath(attr, "wind", attr.surface, attr.level)],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_gfs_wind__WEBPACK_IMPORTED_MODULE_10__["default"])(file);
          },
          units: [{
            label: "km/h",
            conversion: function conversion(x) {
              return x * 3.6;
            },
            precision: 0,
            convention: "into"
          }, {
            label: "m/s",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1,
            convention: "into"
          }, {
            label: "kn",
            conversion: function conversion(x) {
              return x * 1.943844;
            },
            precision: 0,
            convention: "into"
          }, {
            label: "mph",
            conversion: function conversion(x) {
              return x * 2.236936;
            },
            precision: 0,
            convention: "into"
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["wind"](),
          particles: {
            velocityScale: 1 / 100,
            maxIntensity: 15
          }
        });
      }
    },
    "temp": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "temp"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "temp",
          descriptionHTML: localize({
            name: {
              en: "Temp",
              ja: "気温"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: " @ " + describeSurfaceJa(attr)
            }
          }),
          paths: [gfsPath(attr, "temp", attr.surface, attr.level)],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // "Temperature_isobaric", "Temperature_height_above_ground"
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Temperature/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"], ["Temperature"]);
          },
          units: [{
            label: "°C",
            conversion: function conversion(x) {
              return x - 273.15;
            },
            precision: 1
          }, {
            label: "°F",
            conversion: function conversion(x) {
              return x * 9 / 5 - 459.67;
            },
            precision: 1
          }, {
            label: "K",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["temp"]()
        });
      }
    },
    "relative_humidity": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "relative_humidity"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "relative_humidity",
          descriptionHTML: localize({
            name: {
              en: "Relative Humidity",
              ja: "相対湿度"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: " @ " + describeSurfaceJa(attr)
            }
          }),
          paths: [gfsPath(attr, "relative_humidity", attr.surface, attr.level)],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // "Relative_humidity_isobaric", "Relative_humidity_height_above_ground"
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Relative_humidity/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"]);
          },
          units: [{
            label: "%",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["rh"]()
        });
      }
    },
    "air_density": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "air_density"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "air_density",
          descriptionHTML: localize({
            name: {
              en: "Air Density",
              ja: "空気密度"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: " @ " + describeSurfaceJa(attr)
            }
          }),
          paths: [gfsPath(attr, "air_density", attr.surface, attr.level)],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /air_density/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"]);
          },
          units: [{
            label: "kg/m³",
            conversion: function conversion(x) {
              return x;
            },
            precision: 2
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["airdens"]()
        });
      }
    },
    "wind_power_density": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "wind_power_density"
      }),
      create: function create(attr) {
        var windProduct = FACTORIES.wind.create(attr);
        var airdensProduct = FACTORIES.air_density.create(attr);
        return buildProduct({
          type: "wind_power_density",
          descriptionHTML: localize({
            name: {
              en: "Instant Wind Power Density",
              ja: "風力エネルギー密度"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: " @ " + describeSurfaceJa(attr)
            }
          }),
          paths: [windProduct.paths[0], airdensProduct.paths[0]],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(windFile, airdensFile) {
            return Object(_product_gfs_wpd__WEBPACK_IMPORTED_MODULE_11__["default"])(windFile, airdensFile);
          },
          units: [{
            label: "kW/m<sup>2</sup>",
            tooltip: "kW/m²",
            conversion: function conversion(x) {
              return x / 1000;
            },
            precision: 1
          }, {
            label: "W/m<sup>2</sup>",
            tooltip: "W/m²",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["wpd"]()
        });
      }
    },
    "misery_index": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "misery_index"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "misery_index",
          descriptionHTML: localize({
            name: {
              en: "Misery (Wind Chill & Heat Index)",
              ja: "体感温度"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: " @ " + describeSurfaceJa(attr)
            }
          }),
          paths: [gfsPath(attr, "misery_index")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /misery_index/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"]);
          },
          units: function () {
            var perceived = localizeString({
              en: " (feels like)",
              ja: "（体感温度）"
            });
            return [{
              label: "°C" + perceived,
              conversion: function conversion(x) {
                return x - 273.15;
              },
              precision: 1
            }, {
              label: "°F" + perceived,
              conversion: function conversion(x) {
                return x * 9 / 5 - 459.67;
              },
              precision: 1
            }, {
              label: "K" + perceived,
              conversion: function conversion(x) {
                return x;
              },
              precision: 1
            }];
          }(),
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["misery"]()
        });
      }
    },
    "total_cloud_water": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "total_cloud_water"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "total_cloud_water",
          descriptionHTML: localize({
            name: {
              en: "Total Cloud Water",
              ja: "雲水量"
            },
            qualifier: ""
          }),
          paths: [gfsPath(attr, "total_cloud_water")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // "Cloud_water_entire_atmosphere", "Cloud_water_entire_atmosphere_single_layer"
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Cloud_water/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"], ["Cloud_water"]);
          },
          units: [{
            label: "kg/m<sup>2</sup>",
            tooltip: "kg/m²",
            conversion: function conversion(x) {
              return x;
            },
            precision: 3
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["tcw"]()
        });
      }
    },
    "total_precipitable_water": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "total_precipitable_water"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "total_precipitable_water",
          descriptionHTML: localize({
            name: {
              en: "Total Precipitable Water",
              ja: "可降水量"
            },
            qualifier: ""
          }),
          paths: [gfsPath(attr, "total_precipitable_water")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // "Precipitable_water_entire_atmosphere", "Precipitable_water_entire_atmosphere_single_layer"
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Precipitable_water/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"], ["Precipitable_water"]);
          },
          units: [{
            label: "kg/m<sup>2</sup>",
            tooltip: "kg/m²",
            conversion: function conversion(x) {
              return x;
            },
            precision: 3
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["tpw"]()
        });
      }
    },
    "mean_sea_level_pressure": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "mean_sea_level_pressure"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "mean_sea_level_pressure",
          descriptionHTML: localize({
            name: {
              en: "Mean Sea Level Pressure",
              ja: "海面更正気圧"
            },
            qualifier: ""
          }),
          paths: [gfsPath(attr, "mean_sea_level_pressure")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // Pressure_reduced_to_MSL_msl
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Pressure_reduced_to_MSL/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"], ["Pressure_reduced_to_MSL"]);
          },
          units: [{
            label: "hPa",
            conversion: function conversion(x) {
              return x / 100;
            },
            precision: 0
          }, {
            label: "mmHg",
            conversion: function conversion(x) {
              return x / 133.322387415;
            },
            precision: 0
          }, {
            label: "inHg",
            conversion: function conversion(x) {
              return x / 3386.389;
            },
            precision: 1
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["mslp"]()
        });
      }
    },
    "precip_3hr": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "precip_3hr"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "precip_3hr",
          descriptionHTML: localize({
            name: {
              en: "Next 3-hr Precip Accumulation",
              ja: "3時間の降水量"
            },
            qualifier: ""
          }),
          paths: [gfsPath(attr, "precip_3hr")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /precip_accumulation_3hr/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"]);
          },
          units: [{
            label: "mm",
            tooltip: "mm",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }, {
            label: "in",
            tooltip: "in",
            conversion: function conversion(x) {
              return x / 25.4;
            },
            precision: 2
          }, {
            label: "kg/m<sup>2</sup>",
            tooltip: "kg/m²",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }],
          alpha: {
            single: 160,
            animated: 160
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["precip"]()
        });
      }
    },
    "cape": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "cape"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "cape",
          descriptionHTML: localize({
            name: {
              en: "CAPE (Surface)",
              ja: "対流有効位置エネルギー（地上）"
            },
            qualifier: ""
          }),
          paths: [gfsPath(attr, "cape")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Convective_available_potential_energy_surface/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"]);
          },
          units: [{
            label: "J/kg",
            tooltip: "J/kg",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["cape"]()
        });
      }
    },
    "co2": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "co2"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "co2",
          descriptionHTML: localize({
            name: {
              en: "Carbon Dioxide Mixing Ratio",
              ja: "二酸化炭素混合比"
            },
            qualifier: ""
          }),
          paths: [geosPath(attr, "co2")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /CO2CL/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"]);
          },
          units: [// CO2 Bulk Mixing Ratio (Column Mass/ps), units: mol/mol
          // {label: "ppmv", conversion: function(x) { return x * 1e6; }, precision: 1},
          {
            label: "µmol/mol",
            conversion: function conversion(x) {
              return x * 1e6;
            },
            precision: 1
          }],
          alpha: {
            single: 160,
            animated: 160
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["co2"]()
        });
      }
    },
    "cosc": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "cosc"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "cosc",
          descriptionHTML: localize({
            name: {
              en: "Carbon Monoxide Conc.",
              ja: "一酸化炭素濃度"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [geosPath(attr, "cosc")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /COSC/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"]);
          },
          units: [// CO Surface Concentration in ppbv, units: 1e-9
          {
            label: "ppbv",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }, {
            label: "ppmv",
            conversion: function conversion(x) {
              return x / 1000;
            },
            precision: 2
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["cosc"]()
        });
      }
    },
    "so2smass": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "so2smass"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "so2smass",
          descriptionHTML: localize({
            name: {
              en: "Sulfur Dioxide Mass",
              ja: "二酸化硫黄質量"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [geosPath(attr, "so2smass")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /SO2SMASS/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"]);
          },
          units: [// SO2 Surface Mass Concentration, units: kg/m3
          {
            label: "µg/m<sup>3</sup>",
            tooltip: "µg/m³",
            conversion: function conversion(x) {
              return x * 1e9;
            },
            precision: 2
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["so2smass"]()
        });
      }
    },
    "duexttau": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "duexttau"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "duexttau",
          descriptionHTML: localize({
            name: {
              en: "Dust Extinction " + aotLink,
              ja: "粒子消散係数 " + aotLink
            },
            qualifier: ""
          }),
          paths: [geosPath(attr, "duexttau")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /DUEXTTAU/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"]);
          },
          units: [// Dust Extinction AOT (aerosol optical thickness) [550 nm], units: τ
          {
            label: "τ",
            conversion: function conversion(x) {
              return x;
            },
            precision: 4
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["duexttau"]()
        });
      }
    },
    "suexttau": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "suexttau"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "suexttau",
          descriptionHTML: localize({
            name: {
              en: "Sulfate Extinction " + aotLink,
              ja: "硫酸塩消散係数 " + aotLink
            },
            qualifier: ""
          }),
          paths: [geosPath(attr, "suexttau")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /SUEXTTAU/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"]);
          },
          units: [// SO4 Extinction AOT (aerosol optical thickness) [550 nm], units: τ
          {
            label: "τ",
            conversion: function conversion(x) {
              return x;
            },
            precision: 3
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["suexttau"]()
        });
      }
    },
    "co2sc": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "co2sc"
      }),
      create: function create(attr) {
        var _date = gfsDate(attr.date, {
          minute: 90
        });

        var cutoff = _utc__WEBPACK_IMPORTED_MODULE_3__["date"]({
          year: 2017,
          month: 1,
          day: 24,
          hour: 4,
          minute: 30
        });
        var adjustmentRequired = _utc__WEBPACK_IMPORTED_MODULE_3__["date"](_date) < cutoff; // old version of GEOS-5 needs CO2 offset

        var Δ = adjustmentRequired ? 32 : 0;
        return buildProduct({
          type: "co2sc",
          descriptionHTML: localize({
            name: {
              en: "Carbon Dioxide Concentration",
              ja: "二酸化炭素濃度"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [geosPath(attr, "co2sc", {
            minute: 90
          })],
          date: function date() {
            return _date;
          },
          navigate: function navigate(step) {
            return gfsStep(this.date(), step);
          },
          navigateTo: function navigateTo(date) {
            return gfsDate(date, {
              minute: 90
            });
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /CO2SC/, adjustmentRequired ? _product_strings__WEBPACK_IMPORTED_MODULE_7__["geosAdjustedCO2"] : _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"], null, function (data) {
              for (var i = 0; i < data.length; i++) {
                data[i] += Δ;
              }
            });
          },
          units: [// CO2 Surface Concentration, units: ppmv
          {
            label: "ppmv",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }],
          alpha: {
            single: 200,
            animated: 150
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["co2sc"](adjustmentRequired ? -8 : 0)
        });
      }
    },
    // "hrrrwind": {
    //     matchesPrimary: _.matches({param: "hrrrwind"}),
    //     matchesOverlay: _.matches({param: "hrrrwind"}),
    //     create: function(attr) {
    //         return buildProduct({
    //             type: "wind",
    //             descriptionHTML: localize({
    //                 name: {en: "Wind", ja: "風速"},
    //                 qualifier: {en: " @ " + describeSurface(attr), ja: "＠" + describeSurfaceJa(attr)}
    //             }),
    //             paths: [hrrrPath(attr, "wind", attr.surface, attr.level)],
    //             date: function() {
    //                 return hrrrDate(attr.date);
    //             },
    //             /**
    //              * @param {number} step the number of steps away: ±1 or ±10
    //              * @returns {Object} the date parts for the specified number of steps away from this product's date.
    //              */
    //             navigate: function(step) {
    //                 return hrrrStep(this.date(), step);
    //             },
    //             /**
    //              * @param {Object} date the desired date parts or the string "current".
    //              * @returns {Object} the actual date parts.
    //              */
    //             navigateTo: function(date) {
    //                 return hrrrDate(date);
    //             },
    //             builder: function(file) {
    //                 return require("./product/hrrr-wind.js")(file);
    //             },
    //             units: [
    //                 {label: "km/h", conversion: x => x * 3.6,      precision: 0, convention: "into"},
    //                 {label: "m/s",  conversion: x => x,            precision: 1, convention: "into"},
    //                 {label: "kn",   conversion: x => x * 1.943844, precision: 0, convention: "into"},
    //                 {label: "mph",  conversion: x => x * 2.236936, precision: 0, convention: "into"}
    //             ],
    //             scale: require("./palette/wind.js")(),
    //             particles: {velocityScale: 1/200, maxIntensity: 15},
    //         });
    //     }
    // },
    //
    // "hrrrtemp": {
    //     matchesOverlay: _.matches({overlayType: "hrrrtemp"}),
    //      create: function(attr) {
    //          return buildProduct({
    //              type: "hrrrtemp",
    //              descriptionHTML: localize({
    //                  name: {en: "HRRR Temp", ja: ""},
    //                  qualifier: ""
    //              }),
    //              paths: [hrrrPath(attr, "temp", attr.surface, attr.level)],
    //              date: function() {
    //                  return hrrrDate(attr.date);
    //              },
    //              /**
    //               * @param {number} step the number of steps away: ±1 or ±10
    //               * @returns {Object} the date parts for the specified number of steps away from this product's date.
    //               */
    //              navigate: function(step) {
    //                  return hrrrStep(this.date(), step);
    //              },
    //              /**
    //               * @param {Object} date the desired date parts or the string "current".
    //               * @returns {Object} the actual date parts.
    //               */
    //              navigateTo: function(date) {
    //                  return hrrrDate(date);
    //              },
    //              builder: function(file) {
    //                  return require("./product/hrrr-scalar.js")(file, /Temperature_height_above_ground/);
    //              },
    //              units: [
    //                  {label: "°C", conversion: function(x) { return x - 273.15; },       precision: 1},
    //                  {label: "°F", conversion: function(x) { return x * 9/5 - 459.67; }, precision: 1},
    //                  {label: "K",  conversion: function(x) { return x; },                precision: 1}
    //              ],
    //              scale: require("./palette/temp.js")(),
    //          });
    //      }
    // },
    //
    // "hrrrradar": {
    //     matchesOverlay: _.matches({overlayType: "hrrrradar"}),
    //      create: function(attr) {
    //          return buildProduct({
    //              type: "hrrrradar",
    //              descriptionHTML: localize({
    //                  name: {en: "HRRR Radar", ja: ""},
    //                  qualifier: ""
    //              }),
    //              paths: [hrrrPath(attr, "composite_reflectivity")],
    //              date: function() {
    //                  return hrrrDate(attr.date);
    //              },
    //              /**
    //               * @param {number} step the number of steps away: ±1 or ±10
    //               * @returns {Object} the date parts for the specified number of steps away from this product's date.
    //               */
    //              navigate: function(step) {
    //                  return hrrrStep(this.date(), step);
    //              },
    //              /**
    //               * @param {Object} date the desired date parts or the string "current".
    //               * @returns {Object} the actual date parts.
    //               */
    //              navigateTo: function(date) {
    //                  return hrrrDate(date);
    //              },
    //              builder: function(file) {
    //                  return require("./product/hrrr-scalar.js")(file, /Composite_reflectivity_entire_atmosphere/);
    //              },
    //              units: [
    //                  {label: "dB", conversion: function(x) { return x; }, precision: 1}
    //              ],
    //              scale: palette.buildScaleFromSegments([-10, 64], [
    //                  [-10,  [  0,   0,   0]],
    //                  [ 64,  [255, 255, 255]]
    //                  // [0.4,  [ 24, 255,  93]],
    //                  // [0.65, [255, 233, 102]],
    //                  // [1.0,  [255, 233,  15]],
    //                  // [1.5,  [255,  15,  15]]
    //              ], 1000),
    //              // scale: {
    //              //     bounds: [-10, 64],
    //              //     gradient: µ.segmentedColorScale([
    //              //         [-10,     [255, 255, 255]],
    //              //         [ 64,     [0, 0, 0]]
    //              //     ])
    //              // },
    //          });
    //      }
    // },
    "currents": {
      matchesPrimary: function () {
        var a = underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
          surface: "surface",
          level: "currents"
        });

        var b = underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
          param: "argo",
          surface: "pressure"
        });

        return function (o) {
          return a(o) || b(o);
        };
      }(),
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "currents"
      }),
      create: function create(attr) {
        return fetchOscarCatalog().then(function (catalog) {
          return buildProduct({
            type: "currents",
            descriptionHTML: localize({
              name: {
                en: "Ocean Currents",
                ja: "海流"
              },
              qualifier: {
                en: " @ Surface",
                ja: "＠地上"
              }
            }),
            paths: [oscarPath(catalog, attr)],
            date: function date() {
              return oscarDate(catalog, attr.date);
            },
            navigate: function navigate(step) {
              return oscarStep(catalog, this.date(), step);
            },
            navigateTo: function navigateTo(date) {
              return oscarStep(catalog, date, 0);
            },
            builder: function builder(file) {
              return Object(_product_oscar__WEBPACK_IMPORTED_MODULE_8__["default"])(file);
            },
            units: [{
              label: "m/s",
              conversion: function conversion(x) {
                return x;
              },
              precision: 2,
              convention: "with"
            }, {
              label: "km/h",
              conversion: function conversion(x) {
                return x * 3.6;
              },
              precision: 1,
              convention: "with"
            }, {
              label: "kn",
              conversion: function conversion(x) {
                return x * 1.943844;
              },
              precision: 1,
              convention: "with"
            }, {
              label: "mph",
              conversion: function conversion(x) {
                return x * 2.236936;
              },
              precision: 1,
              convention: "with"
            }],
            scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["currents"](),
            particles: {
              velocityScale: 1 / 7,
              maxIntensity: 0.7
            }
          });
        });
      }
    },
    "primary_waves": {
      matchesPrimary: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        param: "ocean",
        surface: "primary",
        level: "waves"
      }),
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "primary_waves"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "primary_waves",
          descriptionHTML: localize({
            name: {
              en: "Peak Wave Period",
              ja: "ピーク波周期"
            },
            qualifier: ""
          }),
          paths: [wave30mPath(attr, "primary")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_ww3_primary__WEBPACK_IMPORTED_MODULE_9__["default"])(file);
          },
          units: [{
            label: "sec",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1,
            convention: "with"
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["primaryWaves"](),
          particles: {
            velocityScale: 1 / 612,
            maxIntensity: 12,
            waves: true
          }
        });
      }
    },
    "sea_surface_temp": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "sea_surface_temp"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "sea_surface_temp",
          descriptionHTML: localize({
            name: {
              en: "Sea Surface Temp",
              ja: "海面水温"
            },
            qualifier: ""
          }),
          paths: [rtgPath(attr, "sea_surface_temp")],
          date: function date() {
            return rtgDate(attr.date);
          },
          navigate: function navigate(step) {
            return rtgStep(this.date(), step);
          },
          navigateTo: function navigateTo(date) {
            return rtgStep(date, 0);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Temperature_surface_sparse/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["rtgsst"]);
          },
          units: [{
            label: "°C",
            conversion: function conversion(x) {
              return x - 273.15;
            },
            precision: 1
          }, {
            label: "°F",
            conversion: function conversion(x) {
              return x * 9 / 5 - 459.67;
            },
            precision: 1
          }, {
            label: "K",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["sst"]()
        });
      }
    },

    /*
            "argo_mean_temp": {
                matchesOverlay: _.matches({overlayType: "argo_mean_temp"}),
                create: function(attr) {
                    return buildProduct({
                        type: "argo_mean_temp",
                        descriptionHTML: function() {
                            return "Argo Ocean Mean Temp"
                        },
                        paths: [argoPath(attr.date, "temp", attr.level)],
                        date: function() {
                            return argoDate(attr.date);
                        },
                        navigate: function(step) {
                            return argoStep(this.date(), step);
                        },
                        navigateTo: function(date) {
                            return argoStep(date, 0);
                        },
                        builder: function(file) {
                            return simpleProduct(file);
                        },
                        units: [
                            {label: "°C", conversion: function(x) { return x; },            precision: 1},
                            {label: "°F", conversion: function(x) { return x * 9/5 + 32; }, precision: 1},
                            {label: "K",  conversion: function(x) { return x + 273.15; },   precision: 1}
                        ],
                        scale: palette.buildScaleFromSegments([270-273.15, 304.65-273.15], [
                            [270   -273.15, [255, 255, 255]],
                            [271.25-273.15, [255, 255, 255]],  // -1.9 C sea water freeze
                            [271.30-273.15, [ 15,   4, 168]],
                            [273.15-273.15, [ 15,  54, 208]],  // 0 C fresh water freeze
                            [273.25-273.15, [ 15,  54, 188]],
                            [275.65-273.15, [ 15,   4, 168]],  // lower boundary for cool currents
                            [281.65-273.15, [ 24, 132,  14]],  // upper boundary for cool currents
                            [291.15-273.15, [247, 251,  59]],  // lower boundary for warm currents
                            [295   -273.15, [235, 167,   0]],
                            [299.65-273.15, [245,   0,  39]],  // minimum needed for tropical cyclone formation
                            [303   -273.15, [ 87,  17,   0]],
                            [304.65-273.15, [238,   0, 242]]
                        ], 1000),
                        // scale: palette.buildScaleFromSegments([-2, 30], [
                        //     [-2,  [0,0,255]],
                        //     [13,  [255,255,255]],
                        //     [18,  [255,255,0 ]],
                        //     [23,  [255,111,0]],
                        //     [28,  [255,0,0]]
                        // ], 1000),
                    });
                }
            },
    
            "argo_temp_anom": {
                matchesOverlay: _.matches({overlayType: "argo_temp_anom"}),
                create: function(attr) {
                    return buildProduct({
                        type: "argo_temp_anom",
                        descriptionHTML: function() {
                            return "Argo Ocean Temp Anomaly"
                        },
                        paths: [argoPath(attr.date, "temp_anom", attr.level)],
                        date: function() {
                            return argoDate(attr.date);
                        },
                        navigate: function(step) {
                            return argoStep(this.date(), step);
                        },
                        navigateTo: function(date) {
                            return argoStep(date, 0);
                        },
                        builder: function(file) {
                            return simpleProduct(file);
                        },
                        units: [
                            {label: "°C", conversion: function(x) { return x; },            precision: 1},
                            {label: "°F", conversion: function(x) { return x * 9/5 + 32; }, precision: 1},
                            {label: "K",  conversion: function(x) { return x + 273.15; },   precision: 1}
                        ],
                        scale: palette.buildScaleFromSegments([-10, 10], [
                            [-10,  [0,75,30]],
                            [-6,   [0,150,0]],
                            [-0.5, [161,217,155]],
                            [0,    [255,255,255]],
                            [0.5,  [255,175,100]],
                            [6,    [255,111,0]],
                            [10,   [166,50,0]]
                        ], 1000),
                    });
                }
            },
    
            "argo_mean_salinity": {
                matchesOverlay: _.matches({overlayType: "argo_mean_salinity"}),
                create: function(attr) {
                    return buildProduct({
                        type: "argo_mean_salinity",
                        descriptionHTML: function() {
                            return "Argo Ocean Salinity"
                        },
                        paths: [argoPath(attr.date, "salinity", attr.level)],
                        date: function() {
                            return argoDate(attr.date);
                        },
                        navigate: function(step) {
                            return argoStep(this.date(), step);
                        },
                        navigateTo: function(date) {
                            return argoStep(date, 0);
                        },
                        builder: function(file) {
                            return simpleProduct(file);
                        },
                        units: [
                            {label: "PSU", conversion: function(x) { return x; }, precision: 2},
                        ],
                        scale: palette.buildScaleFromSegments([32, 39], [
                            [ 32.0,  [66, 99, 51]],
                            [ 33.6,  [108, 145, 81]],
                            [ 35.2,  [149, 191, 110]],
                            [ 36.0,  [205, 154, 176]],
                            [ 37.6,  [173, 104, 132]],
                            [ 39.0,  [140, 55, 107]]
                        ], 1000),
                    });
                }
            },
    
            "argo_salinity_anom": {
                matchesOverlay: _.matches({overlayType: "argo_salinity_anom"}),
                create: function(attr) {
                    return buildProduct({
                        type: "argo_salinity_anom",
                        descriptionHTML: function() {
                            return "Argo Ocean Salinity Anomaly"
                        },
                        paths: [argoPath(attr.date, "salinity_anom", attr.level)],
                        date: function() {
                            return argoDate(attr.date);
                        },
                        navigate: function(step) {
                            return argoStep(this.date(), step);
                        },
                        navigateTo: function(date) {
                            return argoStep(date, 0);
                        },
                        builder: function(file) {
                            return simpleProduct(file);
                        },
                        units: [
                            {label: "PSU", conversion: function(x) { return x; }, precision: 2},
                        ],
                        scale: palette.buildScaleFromSegments([-0.8, 0.8], [
                            [ -0.8,  [7, 62, 94]],
                            [ -0.6/2,  [27, 88, 121]],
                            [ -0.4/2,  [47, 113, 148]],
                            [ -0.2/4,  [74, 138, 175 ]],
                            [ -0.1/4,  [101, 163, 201]],
                            [  0.1/4,  [249, 163, 120]],
                            [  0.2/4,  [222, 135, 100]],
                            [  0.4/2,  [194, 106, 80]],
                            [  0.6/2,  [166, 77, 40]],
                            [  0.8,  [138, 48, 0]]
    
    
                            // [ -0.8/4,  [169, 104, 54]],
                            // [ -0.6/4,  [183, 126, 82]],
                            // [ -0.4/4,  [198, 148, 109]],
                            // [ -0.2/4,  [212, 171, 137]],
                            // [ -0.1/4,  [227, 193, 165]],
                            // [ 0.1/4,  [179, 179, 255]],
                            // [ 0.2/4,  [128, 128, 255]],
                            // [ 0.4/4,  [77, 77, 255]],
                            // [ 0.6/4,  [49, 49, 255]],
                            // [ 0.8/4,  [20, 20, 255]]
    
                            // [-6.0,  [255, 255, 255]],
                            // [-3,    [  7, 252, 254]],
                            // [-1.5,  [ 66,  42, 253]],
                            // [-0.75, [ 34,  55, 134]],
                            // [ 0,    [  0,   0,   6]],
                            // [ 0.75, [134,  55,  34]],
                            // [ 1.5,  [253,  14,  16]],
                            // [ 3.0,  [254, 252,   0]],
                            // [ 6.0,  [255, 255, 255]]
                        ], 1000),
                    });
                }
            },
    */
    "sea_surface_temp_anomaly": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "sea_surface_temp_anomaly"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "sea_surface_temp_anomaly",
          descriptionHTML: localize({
            name: {
              en: "SST Anomaly",
              ja: "海面水温異常"
            },
            qualifier: ""
          }),
          paths: [rtgPath(attr, "sea_surface_temp_anomaly")],
          date: function date() {
            return rtgDate(attr.date);
          },
          navigate: function navigate(step) {
            return rtgStep(this.date(), step);
          },
          navigateTo: function navigateTo(date) {
            return rtgStep(date, 0);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Temperature_surface_anomaly_sparse/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["rtgsst"]);
          },
          units: [{
            label: "°C",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }, {
            label: "°F",
            conversion: function conversion(x) {
              return x * 9 / 5;
            },
            precision: 1
          }, {
            label: "K",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["ssta"]()
        });
      }
    },
    "significant_wave_height": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "significant_wave_height"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "significant_wave_height",
          descriptionHTML: localize({
            name: {
              en: "Significant Wave Height",
              ja: "有義波高"
            },
            qualifier: ""
          }),
          paths: [wave30mPath(attr, "sig_height")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // "Significant_height_of_combined_wind_waves_and_swell_surface"
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Significant_height/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["ww3"]);
          },
          units: [{
            label: "m",
            conversion: function conversion(x) {
              return x;
            },
            precision: 2
          }, {
            label: "ft",
            conversion: function conversion(x) {
              return x * 100 / 2.54 / 12;
            },
            precision: 1
          }],
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["htsgw"]()
        });
      }
    },
    "aurora": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "aurora"
      }),
      create: function create(attr) {
        // HACK: Because some time slots will be filled by older data (since the data source is not reliable),
        // we want to use the date in the URL as the basis of navigation rather than the date from the
        // downloaded header. The date() method is replaced by flatProduct to use the header date, so this
        // function can be used to avoid that.
        function dateFromAttributes() {
          return ovationDate(attr.date);
        }

        return buildProduct({
          type: "aurora",
          descriptionHTML: localize({
            name: {
              en: "Probability of Visible Aurora",
              ja: "オーロラが見える確率"
            },
            qualifier: ""
          }),
          paths: [ovationPath(attr)],
          date: dateFromAttributes,
          navigate: function navigate(step) {
            return ovationStep(dateFromAttributes(), step);
          },
          navigateTo: function navigateTo(date) {
            return ovationDate(date);
          },
          builder: function builder(file) {
            return _micro__WEBPACK_IMPORTED_MODULE_2__["assign"](Object(_product_flatProduct__WEBPACK_IMPORTED_MODULE_6__["default"])(file), {
              sourceHTML: _product_strings__WEBPACK_IMPORTED_MODULE_7__["ovation"]
            });
          },
          units: [{
            label: "% Visibility Chance",
            tooltip: "% Visibility Chance",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["aurora"]()
        });
      }
    },
    "pm1": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "pm1"
      }),
      create: function create(attr) {
        var stride = 1;
        return buildProduct({
          type: "pm1",
          descriptionHTML: localize({
            name: {
              en: "Particulate Matter < 1 µm",
              ja: "粒子径1µm以下（PM<sub>1</sub>）"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [camsPath(attr, "pm1", stride)],
          date: function date() {
            return camsDate(attr.date, stride);
          },
          navigate: function navigate(step) {
            return camsStep(this.date(), stride, step);
          },
          navigateTo: function navigateTo(date) {
            return camsDate(date, stride);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /pm1/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["cams"]);
          },
          units: [{
            label: "µg/m<sup>3</sup>",
            tooltip: "µg/m³",
            conversion: function conversion(x) {
              return x * 1e9;
            },
            precision: 0
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["pmx"]()
        });
      }
    },
    "pm2.5": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "pm2.5"
      }),
      create: function create(attr) {
        var stride = 1;
        return buildProduct({
          type: "pm2.5",
          descriptionHTML: localize({
            name: {
              en: "Particulate Matter < 2.5 µm",
              ja: "微小粒子状物質（PM<sub>2.5</sub>）"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [camsPath(attr, "pm2p5", stride)],
          date: function date() {
            return camsDate(attr.date, stride);
          },
          navigate: function navigate(step) {
            return camsStep(this.date(), stride, step);
          },
          navigateTo: function navigateTo(date) {
            return camsDate(date, stride);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /pm2p5/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["cams"]);
          },
          units: [{
            label: "µg/m<sup>3</sup>",
            tooltip: "µg/m³",
            conversion: function conversion(x) {
              return x * 1e9;
            },
            precision: 0
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["pmx"]()
        });
      }
    },
    "pm10": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "pm10"
      }),
      create: function create(attr) {
        var stride = 1;
        return buildProduct({
          type: "pm10",
          descriptionHTML: localize({
            name: {
              en: "Particulate Matter < 10 µm",
              ja: "粒子径10µm以下（PM<sub>10</sub>）"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [camsPath(attr, "pm10", stride)],
          date: function date() {
            return camsDate(attr.date, stride);
          },
          navigate: function navigate(step) {
            return camsStep(this.date(), stride, step);
          },
          navigateTo: function navigateTo(date) {
            return camsDate(date, stride);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /pm10/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["cams"]);
          },
          units: [{
            label: "µg/m<sup>3</sup>",
            tooltip: "µg/m³",
            conversion: function conversion(x) {
              return x * 1e9;
            },
            precision: 0
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: _palette_palettes__WEBPACK_IMPORTED_MODULE_12__["pmx"]()
        });
      }
    },

    /*
            "co": {
                matchesOverlay: _.matches({overlayType: "co"}),
                create: function(attr) {
                    const stride = 3;
                    return buildProduct({
                        type: "co",
                        descriptionHTML: localize({
                            name: {en: "CO", ja: ""},
                            qualifier: ""
                        }),
                        paths: [camsPath(attr, "co", stride)],
                        date: function() {
                            return camsDate(attr.date, stride);
                        },
                        navigate: function(step) {
                            return camsStep(this.date(), stride, step);
                        },
                        navigateTo: function(date) {
                            return camsDate(date, stride);
                        },
                        builder: function(file) {
                            return scalarProduct(file, /co|VAR192.*!/, strings.cams, null, data => {
                                for (let i = 0; i < data.length; i++) {
                                    data[i] *= 1e9;
                                }
                            });
                        },
                        units: [  // CO Surface Concentration in ppbm, units: 1e-9
                            {label: "ppbm", conversion: function(x) { return x; }, precision: 0},
                            {label: "ppmm", conversion: function(x) { return x / 1000; }, precision: 2}
                        ],
                        alpha: {single: 160, animated: 140},
                        scale: require("./palette/cosc")(),
                    });
                }
            },
    
            "o3": {
                matchesOverlay: _.matches({overlayType: "o3"}),
                create: function(attr) {
                    const stride = 3;
                    return buildProduct({
                        type: "o3",
                        descriptionHTML: localize({
                            name: {en: "O3", ja: ""},
                            qualifier: ""
                        }),
                        paths: [camsPath(attr, "go3", stride)],
                        date: function() {
                            return camsDate(attr.date, stride);
                        },
                        navigate: function(step) {
                            return camsStep(this.date(), stride, step);
                        },
                        navigateTo: function(date) {
                            return camsDate(date, stride);
                        },
                        builder: function(file) {
                            return scalarProduct(file, /go3/, strings.cams);
                        },
                        units: [
                            {label: "ppbm", conversion: function(x) { return x * 1e9; }, precision: 0},
                        ],
                        alpha: {single: 160, animated: 140},
                        scale: palette.buildScaleFromSegments([0, 600e-9], [
                            [0,        [  0,   0,   0]],
                            [600e-9,   [255, 255, 255]]
                        ], 1000),
                    });
                }
            },
    
            "no2": {
                matchesOverlay: _.matches({overlayType: "no2"}),
                create: function(attr) {
                    const stride = 3;
                    return buildProduct({
                        type: "no2",
                        descriptionHTML: localize({
                            name: {en: "NO2", ja: ""},
                            qualifier: ""
                        }),
                        paths: [camsPath(attr, "no2", stride)],
                        date: function() {
                            return camsDate(attr.date, stride);
                        },
                        navigate: function(step) {
                            return camsStep(this.date(), stride, step);
                        },
                        navigateTo: function(date) {
                            return camsDate(date, stride);
                        },
                        builder: function(file) {
                            return scalarProduct(file, /no2/, strings.cams);
                        },
                        units: [
                            {label: "ppbm", conversion: function(x) { return x * 1e9; }, precision: 0},
                        ],
                        alpha: {single: 160, animated: 140},
                        scale: palette.buildScaleFromSegments([0, 2000e-9], [
                            [0,       [  0,   0,   0]],
                            [2000e-9, [255, 255, 255]]
                        ], 1000),
                    });
                }
            },
    
            "so2": {
                matchesOverlay: _.matches({overlayType: "so2"}),
                create: function(attr) {
                    const stride = 3;
                    return buildProduct({
                        type: "so2",
                        descriptionHTML: localize({
                            name: {en: "SO2", ja: ""},
                            qualifier: ""
                        }),
                        paths: [camsPath(attr, "so2", stride)],
                        date: function() {
                            return camsDate(attr.date, stride);
                        },
                        navigate: function(step) {
                            return camsStep(this.date(), stride, step);
                        },
                        navigateTo: function(date) {
                            return camsDate(date, stride);
                        },
                        builder: function(file) {
                            return scalarProduct(file, /so2/, strings.cams);
                        },
                        units: [
                            {label: "µg/m<sup>3</sup>", tooltip: "µg/m³", conversion: x => x * 1e9 * 2.86, precision: 2},
                            {label: "ppbm", conversion: x => x * 1e9, precision: 0},
                        ],
                        alpha: {single: 160, animated: 140},
                        scale: require("./palette/so2ppb")(),
                    });
                }
            },
    */
    "off": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__.matches({
        overlayType: "off"
      }),
      create: function create() {
        return null;
      }
    }
  };

  products.productsFor = function (attr) {
    var primary = null,
        overlay = null;

    underscore__WEBPACK_IMPORTED_MODULE_0__.values(FACTORIES).forEach(function (factory) {
      if (underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction(factory.matchesPrimary) && factory.matchesPrimary(attr)) {
        primary = factory;
      }

      if (underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction(factory.matchesOverlay) && factory.matchesOverlay(attr) && factory !== primary) {
        overlay = factory;
      }
    });

    var results = []; // TIME-LAPSE

    if (primary
    /*&& attributes.animate*/
    ) results.push(primary.create(attr));
    if (overlay) results.push(overlay.create(attr));
    return results.filter(_micro__WEBPACK_IMPORTED_MODULE_2__["isTruthy"]);
  };

  products.overlayTypes = function () {
    return _d3__WEBPACK_IMPORTED_MODULE_1__["set"](Object.keys(FACTORIES));
  };

  products.argoUrl = argoUrl;
}();

/***/ }),

/***/ "./src/projection/orthographic.frag":
/*!******************************************!*\
  !*** ./src/projection/orthographic.frag ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform vec2 u_translate;   // screen coords translation (x0, y0)\nuniform float u_R2;         // scale R, squared\nuniform float u_lon0;       // origin longitude\nuniform float u_sinlat0;    // sin(lat0)\nuniform float u_Rcoslat0;   // R * cos(lat0)\nuniform float u_coslat0dR;  // cos(lat0) / R\nuniform float u_flip;       // 1.0 if lat0 in range [-90deg, +90deg], otherwise -1.0\n\n// Handbook of Mathematical Functions, M. Abramowitz and I.A. Stegun, Ed. For input on range [-1, +1]\n// http://http.developer.nvidia.com/Cg/asin.html\nfloat arcsin(in float v) {\n    float x = abs(v);\n    float ret = -0.0187293;\n    ret *= x;\n    ret += 0.0742610;\n    ret *= x;\n    ret -= 0.2121144;\n    ret *= x;\n    ret += 1.5707288;\n    ret = PI / 2.0 - sqrt(1.0 - x) * ret;\n    return sign(v) * ret;\n}\n\n/** @returns [lon, lat] in radians for the specified point [x, y], or [7e37, 7e37] if the point is unprojectable. */\nvec2 invert(in vec2 point) {\n    vec2 pt = (point - u_translate) * u_flip;\n    float d = 1.0 - dot(pt, pt) / u_R2;\n    if (d >= 0.0) {  // CONSIDER: step() to remove branch... worth it?\n        float cosc = sqrt(d);\n        float lon = u_lon0 + atan(pt.x, cosc * u_Rcoslat0 - pt.y * u_sinlat0);  // u_lon0 + [-pi/2, pi/2]\n        float lat = arcsin(cosc * u_sinlat0 + pt.y * u_coslat0dR);              // [-π/2, π/2] [-90°, +90°]\n        return vec2(lon, lat);\n    }\n    return vec2(7e37);  // outside of projection\n}\n"

/***/ }),

/***/ "./src/projection/orthographic.mjs":
/*!*****************************************!*\
  !*** ./src/projection/orthographic.mjs ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return orthographic; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../consts */ "./src/consts.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./src/math.mjs");
/* harmony import */ var _orthographic_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orthographic.frag */ "./src/projection/orthographic.frag");
/*
 * Orthographic projection. Adapted from:
 *    Map Projections: A Working Manual, Snyder, John P: pubs.er.usgs.gov/publication/pp1395
 *    See page 145.
 *
 * γ rotation is not yet supported.
 */



/**
 * @param {number} R radius of the sphere (i.e., scale)
 * @param {number} λ0 longitude of projection center (degrees)
 * @param {number} φ0 latitude of projection center (degrees)
 * @param {number} x0 translation along x axis
 * @param {number} y0 translation along y axis
 * @returns {Function} projection function f([λ, φ]) and f.invert([x, y]), just like D3.
 */

function orthographic(R, λ0, φ0, x0, y0) {
  // Check if φ0 is rotated far enough that the globe is upside down. If so, adjust the projection center and
  // flip the x,y space. For example, rotation of +100 is actually lat of 80 deg with lon on other side.
  var φnorm = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floorMod"])(φ0 + 90, 360); // now on range [0, 360). Anything on range (180, 360) is flipped.

  var flip = 180 < φnorm ? -1 : 1;

  if (flip < 0) {
    φ0 = 270 - φnorm;
    λ0 += 180;
  } else {
    φ0 = φnorm - 90;
  }

  φ0 *= _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
  λ0 = (Object(_math__WEBPACK_IMPORTED_MODULE_1__["floorMod"])(λ0 + 180, 360) - 180) * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"]; // normalize to [-180, 180)

  var R2 = R * R;
  var sinφ0 = Math.sin(φ0);
  var cosφ0 = Math.cos(φ0);
  var Rcosφ0 = R * cosφ0;
  var cosφ0dR = cosφ0 / R;
  var center = [x0, y0];
  /**
   * @param {number[]} coord [λ, φ] in degrees
   * @returns {number[]} resulting [x, y] or [NaN, NaN] if the coordinates are not defined for the projection.
   */

  function project(coord) {
    var lon = coord[0];
    var lat = coord[1];

    if (lon !== lon || lat !== lat) {
      return [NaN, NaN];
    }

    var λ = lon * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
    var φ = lat * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
    var Δλ = λ - λ0;
    var sinΔλ = Math.sin(Δλ);
    var cosΔλ = Math.cos(Δλ);
    var sinφ = Math.sin(φ);
    var cosφ = Math.cos(φ);
    var Rcosφ = R * cosφ; // const cosc = sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ;  // test if clip angle > 90°
    // if (cosc < 0) return [NaN, NaN];

    var x = Rcosφ * sinΔλ;
    var y = Rcosφ * cosΔλ * sinφ0 - Rcosφ0 * sinφ; // negates y because it grows downward

    var px = x * flip + x0;
    var py = y * flip + y0;
    return [px, py];
  }
  /**
   * @param {number[]} point [x, y]
   * @returns {number[]} resulting [λ, φ] in degrees or [NaN, NaN] if the point is not defined for the projection.
   */


  function invert(point) {
    var px = point[0];
    var py = point[1];
    var x = (px - x0) * flip;
    var y = (y0 - py) * flip; // negate y because it grows downward
    // const ρ = Math.sqrt(x * x + y * y);   // positive number
    // const c = Math.asin(ρ / R);           // [0, π/2] or NaN when ρ > R (meaning the point is outside the globe)
    // const sinc = Math.sin(c);             // [0, 1] because c in range [0, π/2]
    // const cosc = Math.cos(c);             // [0, 1] because c in range [0, π/2]
    // const ysinc = y * sinc;
    // const λ = λ0 + Math.atan2(x * sinc, ρ * cosc * cosφ0 - ysinc * sinφ0);
    // const φ = ρ === 0 ? φ0 : Math.asin(cosc * sinφ0 + ysinc * cosφ0 / ρ);

    var ρ2 = x * x + y * y;
    var d = 1 - ρ2 / R2;

    if (d >= 0) {
      var cosc = Math.sqrt(d); // cos(asin(x)) == sqrt(1 - x*x)

      var λ = λ0 + Math.atan2(x, cosc * Rcosφ0 - y * sinφ0);
      var φ = Math.asin(cosc * sinφ0 + y * cosφ0dR);
      return [λ * _consts__WEBPACK_IMPORTED_MODULE_0__["DEG"], φ * _consts__WEBPACK_IMPORTED_MODULE_0__["DEG"]];
    }

    return [NaN, NaN]; // outside of projection
  }

  project.invert = invert;
  /**
   * @param {GLUStick} glu
   */

  function webgl(glu) {
    return {
      shaderSource: function shaderSource() {
        return _orthographic_frag__WEBPACK_IMPORTED_MODULE_2__;
      },
      textures: function textures() {
        return {};
      },
      uniforms: function uniforms() {
        return {
          u_translate: center,
          // screen coords translation (x0, y0)
          u_R2: R2,
          // scale R, squared
          u_lon0: λ0,
          // origin longitude
          u_sinlat0: sinφ0,
          // sin(lat0)
          u_Rcoslat0: Rcosφ0,
          // R * cos(lat0)
          u_coslat0dR: cosφ0dR,
          // cos(lat0) / R
          u_flip: flip // 1.0 if lat0 in range [-90deg, +90deg], otherwise -1.0

        };
      }
    };
  }

  project.webgl = webgl;
  return project;
}
/**
 * @param p d3 version of orthographic projection.
 * @returns {Function} projection function f([λ, φ]) and f.invert([x, y]), just like D3.
 */

orthographic.fromD3 = function (p) {
  var t = p.translate(),
      r = p.rotate();

  if (r[2] !== 0) {
    throw new Error("γ rotation not supported");
  }

  return orthographic(p.scale(), -r[0], -r[1], t[0], t[1]);
};

/***/ }),

/***/ "./src/utc.mjs":
/*!*********************!*\
  !*** ./src/utc.mjs ***!
  \*********************/
/*! exports provided: parts, localParts, date, normalize, add, compare, print, parse, printISO, largest, smallest, chop, carry, accumulate, range, dayOfYear */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parts", function() { return parts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localParts", function() { return localParts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "date", function() { return date; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compare", function() { return compare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return print; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "printISO", function() { return printISO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "largest", function() { return largest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smallest", function() { return smallest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chop", function() { return chop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "carry", function() { return carry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "accumulate", function() { return accumulate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dayOfYear", function() { return dayOfYear; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/**
 * utc: utilities for working with datetimes.
 *
 * CONSIDER: a datetime starts at year, a duration is a partial datetime. So is {year: 2015} a datetime or a duration?
 * How about {year: 2016, month: 2, day: 14}?
 */

var all = ["year", "month", "day", "hour", "minute", "second", "milli"];

function coalesce(a, b) {
  return a !== undefined && a !== null ? a : b;
}
/**
 * Returns the string representation of a number padded with leading characters to make
 * it at least "width" length.
 *
 * @param {Number} n the number to convert to a padded string
 * @param {Number} width the desired minimum width of the resulting string
 * @param {string} [char] the character to use for padding, default is "0"
 * @returns {string} the padded string
 */


function pad(n, width, char) {
  var s = n.toString();
  var i = Math.max(width - s.length, 0);
  return new Array(i + 1).join(char || "0") + s;
}
/**
 * @param {Date|String|Number} date a Date object, or parsable date string (Note: "yyyy-MM-ddThh:mm:ss" and its
 *        prefixes are interpreted in UTC zone.)
 * @returns {Date} a Date object
 */


function asDate(date) {
  date = coalesce(date, "");

  if (underscore__WEBPACK_IMPORTED_MODULE_0__.isString(date) || underscore__WEBPACK_IMPORTED_MODULE_0__.isNumber(date)) {
    date = new Date(date);
  }

  return date;
}
/**
 * @param {Date|String|Number} date a Date object, or parsable date string (Note: "yyyy-MM-ddThh:mm:ss" and its
 *        prefixes are interpreted in UTC zone.)
 * @returns {Object} all UTC parts of the date: "year", "month", "day", "hour", "minute", "second", "milli"
 */


function parts(date) {
  date = asDate(date);
  return {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    day: date.getUTCDate(),
    hour: date.getUTCHours(),
    minute: date.getUTCMinutes(),
    second: date.getUTCSeconds(),
    milli: date.getUTCMilliseconds()
  };
}
/**
 * @param {Date|String|Number} date a Date object, or parsable date string (Note: "yyyy-MM-ddThh:mm:ss" and its
 *        prefixes are interpreted in UTC zone.)
 * @returns {Object} all Local parts of the date: "year", "month", "day", "hour", "minute", "second", "milli"
 */

function localParts(date) {
  date = asDate(date);
  return {
    year: date.getFullYear(),
    month: date.getMonth() + 1,
    day: date.getDate(),
    hour: date.getHours(),
    minute: date.getMinutes(),
    second: date.getSeconds(),
    milli: date.getMilliseconds()
  };
}
/**
 * @param {Object} parts the UTC date parts.
 * @returns {Date} the Date representation of the specified parts.
 */

function date(parts) {
  var year = +coalesce(parts.year, 0);
  var result = new Date(Date.UTC(year, coalesce(parts.month, 1) - 1, coalesce(parts.day, 1), coalesce(parts.hour, 0), coalesce(parts.minute, 0), coalesce(parts.second, 0), coalesce(parts.milli, 0)));

  if (+result === +result && 0 <= year && year <= 99) {
    result.setUTCFullYear(year); // fix issue that two digit years are mapped to 1900-1999
  }

  return result;
}
/**
 * Adjusts UTC date parts so that they represent an actual date. Parts that overflow, like {hour: 36}, are
 * adjusted to their proper range by carrying-over to the next larger part. Missing parts are added.
 *
 * @param parts the UTC date parts to normalize.
 * @returns {{year: number, month: number, day: number, hour: number, minute: number, second: number, milli:
 *     number}} all UTC parts adjusted to represent an actual date.
 */

function normalize(parts) {
  return _parts(date(parts));
}
var _parts = parts;
/**
 * @param {Object} parts the UTC date parts.
 * @param {Object} delta the parts to add. For example: {hour: 1, minute: 30}.
 * @returns {{year: number, month: number, day: number, hour: number, minute: number, second: number, milli:
 *     number}} all UTC parts with the delta added.
 */

function add(parts, delta) {
  var result = underscore__WEBPACK_IMPORTED_MODULE_0__.clone(parts);

  underscore__WEBPACK_IMPORTED_MODULE_0__.intersection(Object.keys(delta), all).forEach(function (key) {
    result[key] = +coalesce(result[key], 0) + +delta[key];
  });

  return result;
}
/**
 * @returns {Number} standard comparator result. Both arguments are converted to Unix millis then compared.
 *          Invalid dates are smaller/earlier than all valid dates.
 */

function compare(aParts, bParts) {
  var a = date(aParts).getTime();

  if (isNaN(a)) {
    a = -Infinity;
  }

  var b = date(bParts).getTime();

  if (isNaN(b)) {
    b = -Infinity;
  }

  return a < b ? -1 : a > b ? 1 : 0;
}
/**
 * @param {Object} parts the UTC date parts.
 * @param {string} format the format specification. Example: "{yyyy}-{MM}-{dd}T{hh}:{mm}:{ss}.{SSS}"
 * @returns {string} the formatted date.
 */

function print(parts, format) {
  var builder = [];

  for (var i = 0; i < format.length; i++) {
    var c = format[i];

    if (c !== "{") {
      builder.push(c);
      continue;
    }

    var spec = "";

    for (i++; i < format.length; i++) {
      c = format[i];

      if (c !== "}") {
        spec += c;
        continue;
      }

      var value = NaN;

      switch (spec[0]) {
        case "y":
          value = +parts.year;
          break;

        case "M":
          value = +parts.month;
          break;

        case "d":
          value = +parts.day;
          break;

        case "h":
          value = +parts.hour;
          break;

        case "m":
          value = +parts.minute;
          break;

        case "s":
          value = +parts.second;
          break;

        case "S":
          value = +parts.milli;
          break;
      }

      if (value === value) {
        builder.push(pad(value, spec.length));
      } else {
        builder.push("{", spec, "}");
      }

      break;
    }
  }

  return builder.join("");
}
function parse(s, format, groups) {
  var parts = {};

  function assign(key, value) {
    if (value === value) {
      parts[key] = value;
    }
  }

  groups = groups || {
    year: 1,
    month: 2,
    day: 3,
    hour: 4,
    minute: 5,
    second: 6,
    milli: 7
  };
  var match = format.exec(s);

  if (match) {
    assign("year", +match[groups.year]);
    assign("month", +match[groups.month]);
    assign("day", +match[groups.day]);
    assign("hour", +match[groups.hour]);
    assign("minute", +match[groups.minute]);
    assign("second", +match[groups.second]);
    assign("milli", +match[groups.milli]);
  }

  return parts;
}
function printISO(parts) {
  return date(parts).toISOString();
}
function largest(parts) {
  for (var i = 0; i < all.length; i++) {
    if (all[i] in parts) {
      return all[i];
    }
  }

  return undefined;
}
function smallest(parts) {
  for (var i = all.length - 1; i >= 0; i--) {
    if (all[i] in parts) {
      return all[i];
    }
  }

  return undefined;
}
function chop(key, dt) {
  var result = {};

  for (var i = 0; i < all.length; i++) {
    var field = all[i];

    if (field in dt) {
      result[field] = dt[field];
    }

    if (field === key) {
      break;
    }
  }

  return result;
}
/**
 * Carry-over any overflowing field to the next biggest.
 *     {hour: 2, minute: 65}  ->  {hour: 3, minute: 5}
 *
 * Overflowing stops at the largest defined field, up to "day". For example:
 *              {minute: 65}  ->  {minute: 65}
 *     {hour: 0, minute: 65}  ->  {hour: 1, minute: 5}
 *
 * @param {Object} parts the UTC date parts.
 * @returns {Object} new UTC date parts where any overflow has been carried over to the next biggest field.
 */

function carry(parts) {
  // CONSIDER: normalize and carry are pretty similar, except that carry is meant for durations (stops at "day").
  var result = {};
  if (parts.year !== undefined) result.year = parts.year;
  if (parts.month !== undefined) result.month = parts.month;
  var stop = largest(parts);
  var day = parts.day;
  var hour = parts.hour;
  var minute = parts.minute;
  var second = parts.second;
  var milli = parts.milli;

  if (stop !== "milli") {
    if (milli >= 1000) {
      second = coalesce(second, 0) + Math.floor(milli / 1000);
      milli %= 1000;
    }

    if (stop !== "second") {
      if (second >= 60) {
        minute = coalesce(minute, 0) + Math.floor(second / 60);
        second %= 60;
      }

      if (stop !== "minute") {
        if (minute >= 60) {
          hour = coalesce(hour, 0) + Math.floor(minute / 60);
          minute %= 60;
        }

        if (stop !== "hour") {
          if (hour >= 24) {
            day = coalesce(day, 0) + Math.floor(hour / 24);
            hour %= 24;
          }
        }
      }
    }
  }

  if (day !== undefined) result.day = day;
  if (hour !== undefined) result.hour = hour;
  if (minute !== undefined) result.minute = minute;
  if (second !== undefined) result.second = second;
  if (milli !== undefined) result.milli = milli;
  return result;
}
/**
 * @param parts the input datetime.
 * @returns {Object} a datetime with all parts specified, filled in with zero when undefined.
 */

function fill(parts) {
  return {
    year: parts.year || 0,
    month: parts.month || 0,
    day: parts.day || 0,
    hour: parts.hour || 0,
    minute: parts.minute || 0,
    second: parts.second || 0,
    milli: parts.milli || 0
  };
}
/**
 * Accumulates the total duration of time into one part specified by key. Standard durations are used. Years and
 * months are ignored because they convert to a variable number of days.
 *
 *       "hour", {hour: 2, minute: 65}  ->  {hour: 3}
 *     "minute", {hour: 2, minute: 65}  ->  {minute: 185}
 *     "second", {hour: 2, minute: 65}  ->  {second: 11100}
 *
 * @param {string} key the part to accumulate time into.
 * @param {Object} parts the input duration.
 * @returns {Object} datetime with one part, {key: }, where all the time has been accumulated into it.
 */


function accumulate(key, parts) {
  var smoothed = carry(fill(parts));
  var accum = smoothed.day;

  if (key === "day") {
    return {
      day: accum
    };
  }

  accum = accum * 24 + smoothed.hour;

  if (key === "hour") {
    return {
      hour: accum
    };
  }

  accum = accum * 60 + smoothed.minute;

  if (key === "minute") {
    return {
      minute: accum
    };
  }

  accum = accum * 60 + smoothed.second;

  if (key === "second") {
    return {
      second: accum
    };
  }

  accum = accum * 1000 + smoothed.milli;

  if (key === "milli") {
    return {
      milli: accum
    };
  }

  var result = {};
  result[key] = undefined;
  return result;
}
/**
 * @param start the starting UTC parts, inclusive
 * @param end the ending UTC parts, inclusive
 * @param delta the UTC parts
 * @returns {Array} a range of UTC parts separated by delta
 */

function range(start, end, delta) {
  var results = [];

  for (var i = start; compare(i, end) <= 0; i = add(i, delta)) {
    results.push(carry(i));
  }

  return results;
}
/**
 * @param {Object} dt the datetime.
 * @returns {number} the ordinal number of days from Jan 1 of the input year, starting at 1.
 */

function dayOfYear(dt) {
  var d1 = date(dt),
      d0 = date({
    year: d1.getUTCFullYear()
  });
  return Math.floor((d1 - d0) / (24 * 60 * 60 * 1000)) + 1; // No daylight savings in UTC.
}

/***/ })

/******/ });
//# sourceMappingURL=bundle.js.map